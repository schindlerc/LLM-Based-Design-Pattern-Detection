File: CH.ifa.draw.util.Iconkit
```java

package CH.ifa.draw.util;

import java.awt.Component;
import java.awt.Image;
import java.awt.MediaTracker;
import java.awt.Toolkit;
import java.awt.image.ImageProducer;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

public class Iconkit {
	private Hashtable           fMap;
	private Vector              fRegisteredImages;
	private Component           fComponent;
	private final static int    ID = 123;
	private static Iconkit      fgIconkit = null;
	private static boolean      fgDebug = false;

	public Iconkit(Component component) {
		fMap = new Hashtable(53);
		fRegisteredImages = new Vector(10);
		fComponent = component;
		fgIconkit = this;
	}

	public static Iconkit instance() {
		return fgIconkit;
	}

	public void loadRegisteredImages(Component component) {
		if (fRegisteredImages.size() == 0)
			return;

		MediaTracker tracker = new MediaTracker(component);

		Enumeration k = fRegisteredImages.elements();
		while (k.hasMoreElements()) {
			String fileName = (String) k.nextElement();
			if (basicGetImage(fileName) == null) {
				tracker.addImage(loadImage(fileName), ID);
			}
		}
		fRegisteredImages.removeAllElements();

		try {
			tracker.waitForAll();
		} catch (Exception e) {  }
	}

	public void registerImage(String fileName) {
		fRegisteredImages.addElement(fileName);
	}

	public Image registerAndLoadImage(Component component, String fileName) {
		registerImage(fileName);
		loadRegisteredImages(component);
		return getImage(fileName);
	}

	public Image loadImage(String filename) {
		if (fMap.containsKey(filename))
			return (Image) fMap.get(filename);
		Image image = loadImageResource(filename);
		if (image != null)
			fMap.put(filename, image);
		return image;
	}

	public Image loadImageResource(String resourcename) {
		Toolkit toolkit = Toolkit.getDefaultToolkit();
		try {
			java.net.URL url = getClass().getResource(resourcename);
			if (fgDebug)
				System.out.println(resourcename);
			return toolkit.createImage((ImageProducer) url.getContent());
		} catch (Exception ex) {
			return null;
		}
	}

	public Image getImage(String filename) {
		Image image = basicGetImage(filename);
		if (image != null)
			return image;
		loadRegisteredImages(fComponent);
		return basicGetImage(filename);
	}

	private Image basicGetImage(String filename) {
		if (fMap.containsKey(filename))
			return (Image) fMap.get(filename);
		return null;
	}
}
```

File: CH.ifa.draw.util.Geom
```java

package CH.ifa.draw.util;

import java.awt.Point;
import java.awt.Rectangle;

public class Geom {

	private Geom() {}; // never instantiated

	static public boolean lineContainsPoint(int x1, int y1,
							int x2, int y2,
							int px, int py) {

		Rectangle r = new Rectangle(new Point(x1, y1));
		r.add(x2, y2);

		r.grow(2,2);
		if (! r.contains(px,py))
			return false;

		double a, b, x, y;

		if (x1 == x2)
			return (Math.abs(px - x1) < 3);

		if (y1 == y2)
			return (Math.abs(py - y1) < 3);

		a = (double)(y1 - y2) / (double)(x1 - x2);
		b = (double)y1 - a * (double)x1;
		x = (py - b) / a;
		y = a * px + b;

		return (Math.min(Math.abs(x - px), Math.abs(y - py)) < 4);
	}


	static public final int NORTH = 1;
	static public final int SOUTH = 2;
	static public final int WEST = 3;
	static public final int EAST = 4;

	static public int direction(int x1, int y1, int x2, int y2) {
		int direction = 0;
		int vx = x2 - x1;
		int vy = y2 - y1;

		if (vy < vx && vx > -vy)
			direction = EAST;
		else if (vy > vx && vy > -vx)
			direction = NORTH;
		else if (vx < vy && vx < -vy)
			direction = WEST;
		else
			direction = SOUTH;
		return direction;
	}

	static public Point south(Rectangle r) {
		return new Point(r.x + r.width /2, r.y + r.height);
	}

	static public Point center(Rectangle r) {
		return new Point(r.x + r.width /2, r.y + r.height/2);
	}

	static public Point west(Rectangle r) {
		return new Point(r.x, r.y + r.height/ 2);
	}

	static public Point east(Rectangle r) {
		return new Point(r.x+r.width, r.y + r.height/ 2);
	}

	static public Point north(Rectangle r) {
		return new Point(r.x+r.width/2, r.y);
	}

	static public int range(int min, int max, int value) {
		if (value < min)
			value = min;
		if (value > max)
			value = max;
		return value;
	}

	static public long length2(int x1, int y1, int x2, int y2) {
		return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
	}

	static public long length(int x1, int y1, int x2, int y2) {
		return (long)Math.sqrt(length2(x1, y1, x2, y2));
	}

	static public double pointToAngle(Rectangle r, Point p) {
		int px = p.x - (r.x+r.width/2);
		int py = p.y - (r.y+r.height/2);
		return Math.atan2(py*r.width, px*r.height);
	}

	static public Point angleToPoint(Rectangle r, double angle) {
		double si = Math.sin(angle);
		double co = Math.cos(angle);
		double e = 0.0001;

		int x= 0, y= 0;
	    if (Math.abs(si) > e) {
		    x= (int) ((1.0 + co/Math.abs(si))/2.0 * r.width);
		    x= range(0, r.width, x);
	    } else if (co >= 0.0)
		    x= r.width;
	    if (Math.abs(co) > e) {
		    y= (int) ((1.0 + si/Math.abs(co))/2.0 * r.height);
		    y= range(0, r.height, y);
	    } else if (si >= 0.0)
		    y= r.height;
	    return new Point(r.x + x, r.y + y);
	}

	static public Point polarToPoint(double angle, double fx, double fy) {
		double si = Math.sin(angle);
		double co = Math.cos(angle);
	    return new Point((int)(fx*co+0.5), (int)(fy*si+0.5));
	}

	static public Point ovalAngleToPoint(Rectangle r, double angle) {
		Point center = Geom.center(r);
		Point p = Geom.polarToPoint(angle, r.width/2, r.height/2);
		return new Point(center.x + p.x, center.y + p.y);
	}

  static public Point intersect(int xa, // line 1 point 1 x
								int ya, // line 1 point 1 y
								int xb, // line 1 point 2 x
								int yb, // line 1 point 2 y
								int xc, // line 2 point 1 x
								int yc, // line 2 point 1 y
								int xd, // line 2 point 2 x
								int yd) { // line 2 point 2 y


	double denom = ((xb - xa) * (yd - yc) - (yb - ya) * (xd - xc));

	double rnum = ((ya - yc) * (xd - xc) - (xa - xc) * (yd - yc));

	if (denom == 0.0) { // parallel
	  if (rnum == 0.0) { // coincident; pick one end of first line
		if ((xa < xb && (xb < xc || xb < xd)) ||
			(xa > xb && (xb > xc || xb > xd)))
		  return new Point(xb, yb);
		else
		  return new Point(xa, ya);
	  }
	  else
		return null;
	}

	double r = rnum / denom;

	double snum = ((ya - yc) * (xb - xa) - (xa - xc) * (yb - ya));
	double s = snum / denom;

	if (0.0 <= r && r <= 1.0 && 0.0 <= s && s <= 1.0) {
	  int px = (int)(xa + (xb - xa) * r);
	  int py = (int)(ya + (yb - ya) * r);
	  return new Point(px, py);
	}
	else
	  return null;
  }  

}
```

File: CH.ifa.draw.util.CommandChoice
```java

package CH.ifa.draw.util;

import java.awt.Choice;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.util.Vector;



public  class CommandChoice
		extends Choice implements ItemListener {

	private Vector   fCommands;

	public CommandChoice() {
		fCommands = new Vector(10);
		addItemListener(this);
	}

	public synchronized void addItem(Command command) {
		addItem(command.name());
		fCommands.addElement(command);
	}

	public void itemStateChanged(ItemEvent e) {
		Command command = (Command)fCommands.elementAt(getSelectedIndex());
		command.execute();
	}
}


```

File: CH.ifa.draw.util.PaletteListener
```java

package CH.ifa.draw.util;



public interface PaletteListener {
	void paletteUserSelected(PaletteButton button);

	void paletteUserOver(PaletteButton button, boolean inside);
}
```

File: CH.ifa.draw.util.CommandButton
```java

package CH.ifa.draw.util;

import java.awt.Button;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;


public  class CommandButton
		extends Button implements ActionListener {

	private Command   fCommand;

	public CommandButton(Command command) {
		super(command.name());
		fCommand = command;
		addActionListener(this);
	}

	public void actionPerformed(ActionEvent e) {
		fCommand.execute();
		if (!getLabel().equals(fCommand.name()) ) {
			setLabel(fCommand.name());
		}
	}
}


```

File: CH.ifa.draw.util.Command
```java

package CH.ifa.draw.util;



public abstract class Command {

	private String  fName;

	public Command(String name) {
		fName = name;
	}

	public abstract void execute();

	public boolean isExecutable() {
		return true;
	}

	public String name() {
		return fName;
	}
}
```

File: CH.ifa.draw.util.Storable
```java

package CH.ifa.draw.util;

import java.io.IOException;

public interface Storable {
	public void write(StorableOutput dw);

	public void read(StorableInput dr) throws IOException;
}
```

File: CH.ifa.draw.util.Clipboard
```java

package CH.ifa.draw.util;



public class Clipboard {
	static Clipboard fgClipboard = new Clipboard();

	static public Clipboard getClipboard() {
		return fgClipboard;
	}

	private Object fContents;

	private Clipboard() {
	}

	public void setContents(Object contents) {
		fContents = contents;
	}

	public Object getContents() {
		return fContents;
	}
}
```

File: CH.ifa.draw.util.ColorEntry
```java

package CH.ifa.draw.util;

import java.awt.Color;


class ColorEntry {
	public String 	fName;
	public Color 	fColor;

	ColorEntry(String name, Color color) {
	    fColor = color;
	    fName = name;
	}
}

```

File: CH.ifa.draw.util.Animatable
```java

package CH.ifa.draw.util;


public interface Animatable {
	void animationStep();
}
```

File: CH.ifa.draw.util.ReverseVectorEnumerator
```java

package CH.ifa.draw.util;

import java.util.Enumeration;
import java.util.NoSuchElementException;
import java.util.Vector;

public class ReverseVectorEnumerator
implements Enumeration {

	Vector vector;
	int count;

	public ReverseVectorEnumerator(Vector v) {
	    vector = v;
	    count = vector.size() - 1;
	}

	public boolean hasMoreElements() {
	    return count >= 0;
	}

	public Object nextElement() {
	    if (count >= 0) {
		    return vector.elementAt(count--);
	    }
	    throw new NoSuchElementException("ReverseVectorEnumerator");
	}

}
```

File: CH.ifa.draw.util.PaletteButton
```java

package CH.ifa.draw.util;

import java.awt.Canvas;
import java.awt.Graphics;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;


public abstract class PaletteButton
				extends Canvas
				implements MouseListener, MouseMotionListener {

	static final int NORMAL = 1;
	static final int PRESSED = 2;
	static final int SELECTED = 3;

	private PaletteListener  fListener;
	private int             fState;
	private int             fOldState;


	public PaletteButton(PaletteListener listener) {
		fListener = listener;
		fState = fOldState = NORMAL;
		addMouseListener(this);
		addMouseMotionListener(this);
	}

	public abstract void paintBackground(Graphics g);
	public abstract void paintNormal(Graphics g);
	public abstract void paintPressed(Graphics g);
	public abstract void paintSelected(Graphics g);

	public Object value() {
		return null;
	}

	public String name() {
		return "";
	}

	public void reset() {
		fState = NORMAL;
		repaint();
	}

	public void select() {
		fState = SELECTED;
		repaint();
	}

	public void mousePressed(MouseEvent e) {
		fOldState = fState;
		fState = PRESSED;
		repaint();
	}

	public void mouseDragged(MouseEvent e) {
		if (contains(e.getX(),e.getY()))
			fState = PRESSED;
		else
			fState = fOldState;
		repaint();
	}

	public void mouseReleased(MouseEvent e) {
		fState = fOldState;
		repaint();
		if (contains(e.getX(),e.getY()))
			fListener.paletteUserSelected(this);
	}

	public void mouseMoved(MouseEvent e) {
		fListener.paletteUserOver(this, true);
	}

	public void mouseExited(MouseEvent e) {
		if (fState == PRESSED) // JDK1.1 on Windows sometimes looses mouse released
			mouseDragged(e);
		fListener.paletteUserOver(this, false);
	}

	public void mouseClicked(MouseEvent e) {}
	public void mouseEntered(MouseEvent e) {}

	public void update(Graphics g) {
		paint(g);
	}

	public void paint(Graphics g) {
		paintBackground(g);

		switch (fState) {
		case PRESSED:
			paintPressed(g);
			break;
		case SELECTED:
			paintSelected(g);
			break;
		case NORMAL:
		default:
			paintNormal(g);
			break;
		}
	}
}
```

File: CH.ifa.draw.util.PaletteIcon
```java

package CH.ifa.draw.util;

import java.awt.Dimension;
import java.awt.Image;


public  class PaletteIcon extends Object {

	Image       fNormal;
	Image       fPressed;
	Image       fSelected;
	Dimension   fSize;

	public PaletteIcon(Dimension size, Image normal, Image pressed, Image selected) {
		fSize = size;
		fNormal = normal;
		fPressed = pressed;
		fSelected = selected;
	}

	public Image normal() { return fNormal; }
	public Image pressed() { return fPressed; }
	public Image selected() { return fSelected; }

	public int getWidth() { return fSize.width; }
	public int getHeight() { return fSize.height; }

}
```

File: CH.ifa.draw.util.PaletteLayout
```java

package CH.ifa.draw.util;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager;
import java.awt.Point;


public  class PaletteLayout
		implements LayoutManager {

	private int         fGap;
	private Point       fBorder;
	private boolean     fVerticalLayout;

	public PaletteLayout(int gap) {
		this(gap, new Point(0,0), true);
	}

	public PaletteLayout(int gap, Point border) {
		this(gap, border, true);
	}

	public PaletteLayout(int gap, Point border, boolean vertical) {
		fGap = gap;
		fBorder = border;
		fVerticalLayout = vertical;
	}

	public void addLayoutComponent(String name, Component comp) {
	}

	public void removeLayoutComponent(Component comp) {
	}

	public Dimension preferredLayoutSize(Container target) {
		return minimumLayoutSize(target);
	}

	public Dimension minimumLayoutSize(Container target) {
	    Dimension dim = new Dimension(0, 0);
	    int nmembers = target.getComponentCount();

	    for (int i = 0 ; i < nmembers ; i++) {
	        Component m = target.getComponent(i);
	        if (m.isVisible()) {
		        Dimension d = m.getMinimumSize();
		        if (fVerticalLayout) {
		            dim.width = Math.max(dim.width, d.width);
		            if (i > 0)
		                dim.height += fGap;
		            dim.height += d.height;
		        } else {
		            dim.height = Math.max(dim.height, d.height);
		            if (i > 0)
		                dim.width += fGap;
		            dim.width += d.width;
	            }
	        }
	    }

	    Insets insets = target.getInsets();
	    dim.width += insets.left + insets.right;
	    dim.width += 2 * fBorder.x;
	    dim.height += insets.top + insets.bottom;
	    dim.height += 2 * fBorder.y;
	    return dim;
	}

	public void layoutContainer(Container target) {
	    Insets insets = target.getInsets();
	    int nmembers = target.getComponentCount();
	    int x = insets.left + fBorder.x;
	    int y = insets.top + fBorder.y;

	    for (int i = 0 ; i < nmembers ; i++) {
	        Component m = target.getComponent(i);
	        if (m.isVisible()) {
		        Dimension d = m.getMinimumSize();
		        m.setBounds(x, y, d.width, d.height);
		        if (fVerticalLayout) {
		            y += d.height;
		            y += fGap;
		        } else {
		            x += d.width;
		            x += fGap;
		        }
		    }
	    }
	}
}
```

File: CH.ifa.draw.util.StorableInput
```java

package CH.ifa.draw.util;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StreamTokenizer;
import java.util.Vector;


public  class StorableInput
		extends Object {

	private StreamTokenizer fTokenizer;
	private Vector          fMap;

	public StorableInput(InputStream stream) {
		Reader r = new BufferedReader(new InputStreamReader(stream));
		fTokenizer = new StreamTokenizer(r);
		fMap = new Vector();
	}

	public Storable readStorable() throws IOException {
		Storable storable;
		String s = readString();

		if (s.equals("NULL"))
			return null;

		if (s.equals("REF")) {
			int ref = readInt();
			return (Storable) retrieve(ref);
		}

		storable = (Storable) makeInstance(s);
		map(storable);
		storable.read(this);
		return storable;
	}

	public String readString() throws IOException {
		int token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_WORD || token == '"') {
			return fTokenizer.sval;
		}

		String msg = "String expected in line: " + fTokenizer.lineno();
		throw new IOException(msg);
	}

	public int readInt() throws IOException {
		int token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_NUMBER)
			return (int) fTokenizer.nval;

		String msg = "Integer expected in line: " + fTokenizer.lineno();
		throw new IOException(msg);
	}

	public Color readColor() throws IOException {
		return new Color(readInt(), readInt(), readInt());
	}

	public double readDouble() throws IOException {
		int token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_NUMBER)
			return fTokenizer.nval;

		String msg = "Double expected in line: " + fTokenizer.lineno();
		throw new IOException(msg);
	}

	public boolean readBoolean() throws IOException {
		int token = fTokenizer.nextToken();
		if (token == StreamTokenizer.TT_NUMBER)
			return ((int) fTokenizer.nval) == 1;

		String msg = "Integer expected in line: " + fTokenizer.lineno();
		throw new IOException(msg);
	}

	private Object makeInstance(String className) throws IOException {
		try {
			Class cl = Class.forName(className);
			return cl.newInstance();
		} catch (NoSuchMethodError e) {
			throw new IOException("Class " + className
				+ " does not seem to have a no-arg constructor");
		} catch (ClassNotFoundException e) {
			throw new IOException("No class: " + className);
		} catch (InstantiationException e) {
			throw new IOException("Cannot instantiate: " + className);
		} catch (IllegalAccessException e) {
			throw new IOException("Class (" + className + ") not accessible");
		}
	}

	private void map(Storable storable) {
		if (!fMap.contains(storable))
			fMap.addElement(storable);
	}

	private Storable retrieve(int ref) {
		return (Storable) fMap.elementAt(ref);
	}
}
```

File: CH.ifa.draw.util.StorableOutput
```java

package CH.ifa.draw.util;

import java.awt.Color;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Vector;



public  class StorableOutput extends Object {

	private PrintWriter     fStream;
	private Vector          fMap;
	private int             fIndent;

	public StorableOutput(OutputStream stream) {
		fStream = new PrintWriter(stream);
		fMap = new Vector();
		fIndent = 0;
	}

	public void writeStorable(Storable storable) {
		if (storable == null) {
			fStream.print("NULL");
			space();
			return;
		}

		if (mapped(storable)) {
			writeRef(storable);
			return;
		}

		incrementIndent();
		startNewLine();
		map(storable);
		fStream.print(storable.getClass().getName());
		space();
		storable.write(this);
		space();
		decrementIndent();
	}

	public void writeInt(int i) {
		fStream.print(i);
		space();
	}

	public void writeColor(Color c) {
		writeInt(c.getRed());
		writeInt(c.getGreen());
		writeInt(c.getBlue());
	}

	public void writeDouble(double d) {
		fStream.print(d);
		space();
	}

	public void writeBoolean(boolean b) {
		if (b)
			fStream.print(1);
		else
			fStream.print(0);
		space();
	}

	public void writeString(String s) {
		fStream.print('"');
		for(int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			switch(c) {
				case '\n': fStream.print('\\'); fStream.print('n'); break;
				case '"' : fStream.print('\\'); fStream.print('"'); break;
				case '\\': fStream.print('\\'); fStream.print('\\'); break;
				case '\t': fStream.print('\\'); fStream.print('\t'); break;
				default: fStream.print(c);
			}

		}
		fStream.print('"');
		space();
	}

	public void close() {
		fStream.close();
	}

	private boolean mapped(Storable storable) {
		return fMap.contains(storable);
	}

	private void map(Storable storable) {
		if (!fMap.contains(storable))
			fMap.addElement(storable);
	}

	private void writeRef(Storable storable) {
		int ref = fMap.indexOf(storable);

		fStream.print("REF");
		space();
		fStream.print(ref);
		space();
	}

	private void incrementIndent() {
		fIndent += 4;
	}

	private void decrementIndent() {
		fIndent -= 4;
		if (fIndent < 0) fIndent = 0;
	}

	private void startNewLine() {
		fStream.println();
		for (int i=0; i<fIndent; i++)
			space();
	}

	private void space() {
		fStream.print(' ');
	}

}
```

File: CH.ifa.draw.util.FloatingTextField
```java

package CH.ifa.draw.util;

import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Rectangle;
import java.awt.TextField;
import java.awt.event.ActionListener;

public  class FloatingTextField extends Object {

	private TextField   fEditWidget;
	private Container   fContainer;

	public FloatingTextField() {
		fEditWidget = new TextField(20);
	}

	public void createOverlay(Container container) {
		createOverlay(container, null);
	}

	public void createOverlay(Container container, Font font) {
		container.add(fEditWidget, 0);
		if (font != null)
			fEditWidget.setFont(font);
		fContainer = container;

	}

	public void addActionListener(ActionListener listener) {
	    fEditWidget.addActionListener(listener);
	}

	public void removeActionListener(ActionListener listener) {
	    fEditWidget.removeActionListener(listener);
	}

	public void setBounds(Rectangle r, String text) {
	    fEditWidget.setText(text);
		fEditWidget.setBounds(r.x, r.y, r.width, r.height);
		fEditWidget.setVisible(true);
	    fEditWidget.selectAll();
	    fEditWidget.requestFocus();
	}

	public String getText() {
		return fEditWidget.getText();
	}

	public Dimension getPreferredSize(int cols) {
		return fEditWidget.getPreferredSize(cols);
	}

	public void endOverlay() {
	    fContainer.requestFocus();
	    if (fEditWidget == null)
	        return;
	    fEditWidget.setVisible(false);
	    fContainer.remove(fEditWidget);

	    Rectangle bounds = fEditWidget.getBounds();
	    fContainer.repaint(bounds.x, bounds.y, bounds.width, bounds.height);
	}
}

```

File: CH.ifa.draw.util.ColorMap
```java

package CH.ifa.draw.util;

import java.awt.Color;



public  class ColorMap
		extends Object {

	static ColorEntry fMap[] = {
				new ColorEntry("Black",         Color.black),
				new ColorEntry("Blue",          Color.blue),
				new ColorEntry("Green",         Color.green),
				new ColorEntry("Red",           Color.red),
				new ColorEntry("Pink",          Color.pink),
				new ColorEntry("Magenta",       Color.magenta),
				new ColorEntry("Orange",        Color.orange),
				new ColorEntry("Yellow",        Color.yellow),
				new ColorEntry("New Tan",       new Color(0xEBC79E)),
				new ColorEntry("Aquamarine",    new Color(0x70DB93)),
				new ColorEntry("Sea Green",     new Color(0x238E68)),
				new ColorEntry("Dark Gray",     Color.darkGray),
				new ColorEntry("Light Gray",    Color.lightGray),
				new ColorEntry("White",         Color.white),
				new ColorEntry("None",          new Color(0xFFC79E))
	};


	public static int size() {
		return fMap.length;
	}

	public static Color color(int index) {
	    if (index < size() && index >= 0)
	        return fMap[index].fColor;

	    throw new ArrayIndexOutOfBoundsException("Color index: " + index);
	}

	public static Color color(String name) {
		for (int i = 0; i < fMap.length; i++)
			if (fMap[i].fName.equals(name))
				return fMap[i].fColor;

	    return Color.black;
	}

	public static String name(int index) {
	    if (index < size() && index >= 0)
	        return fMap[index].fName;

	    throw new ArrayIndexOutOfBoundsException("Color index: " + index);
	}

	public static int colorIndex(Color color) {
		for (int i=0; i<fMap.length; i++)
			if (fMap[i].fColor.equals(color))
				return i;
		return 0;
	}

	public static boolean isTransparent(Color color) {
		return color.equals(color("None"));
	}
}
```

File: CH.ifa.draw.util.Filler
```java

package CH.ifa.draw.util;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Dimension;



public  class Filler
		extends Canvas {

	private int     fWidth;
	private int     fHeight;
	private Color   fBackground;


	public Filler(int width, int height) {
		this(width, height, null);
	}

	public Filler(int width, int height, Color background) {
		fWidth = width;
		fHeight = height;
		fBackground = background;
	}

	public Dimension getMinimumSize() {
		return new Dimension(fWidth, fHeight);
	}

	public Dimension getPreferredSize() {
		return getMinimumSize();
	}

	public Color getBackground() {
		if (fBackground != null)
			return fBackground;
		return super.getBackground();
	}
}

```

File: CH.ifa.draw.util.CommandMenu
```java

package CH.ifa.draw.util;

import java.awt.Menu;
import java.awt.MenuItem;
import java.awt.MenuShortcut;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Vector;

public  class CommandMenu
		extends Menu implements ActionListener {

	private Vector   fCommands;

	public CommandMenu(String name) {
		super(name);
		fCommands = new Vector(10);
	}

	public synchronized void add(Command command) {
		MenuItem m = new MenuItem(command.name());
		m.addActionListener(this);
		add(m);
		fCommands.addElement(command);
	}

	public synchronized void add(Command command, MenuShortcut shortcut) {
		MenuItem m = new MenuItem(command.name(), shortcut);
		m.setName(command.name());
		m.addActionListener(this);
		add(m);
		fCommands.addElement(command);
	}

	public synchronized void remove(Command command) {
		System.out.println("not implemented");
	}

	public synchronized void remove(MenuItem item) {
		System.out.println("not implemented");
	}

	public synchronized void enable(String name, boolean state) {
		for (int i = 0; i < getItemCount(); i++) {
			MenuItem item = getItem(i);
			if (name.equals(item.getLabel())) {
				item.setEnabled(state);
				return;
			}
		}
	}

	public synchronized void checkEnabled() {
		int j = 0;
		for (int i = 0; i < getItemCount(); i++) {
			MenuItem item = getItem(i);
			if (item.getLabel().equals("-"))
				continue;
			Command cmd = (Command)fCommands.elementAt(j);
			item.setEnabled(cmd.isExecutable());
			j++;
		}
	}

	public void actionPerformed(ActionEvent e) {
		int j = 0;
		Object source = e.getSource();
		for (int i = 0; i < getItemCount(); i++) {
			MenuItem item = getItem(i);
			if (item.getLabel().equals("-"))
				continue;
			if (source == item) {
				Command cmd = (Command)fCommands.elementAt(j);
				cmd.execute();
				break;
			}
			j++;
		}
	}
}


```

File: CH.ifa.draw.framework.FigureSelection
```java

package CH.ifa.draw.framework;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public class FigureSelection extends Object {

	private byte[] fData; // flattend figures, ready to be resurrected
	public final static String TYPE = "CH.ifa.draw.Figures";

	public FigureSelection(Vector figures) {
		ByteArrayOutputStream output = new ByteArrayOutputStream(200);
		StorableOutput writer = new StorableOutput(output);
		writer.writeInt(figures.size());
		Enumeration selected = figures.elements();
		while (selected.hasMoreElements()) {
			Figure figure = (Figure) selected.nextElement();
			writer.writeStorable(figure);
		}
		writer.close();
		fData = output.toByteArray();
	}

	public String getType() {
		return TYPE;
	}

	public Object getData(String type) {
		if (type.equals(TYPE)) {
			InputStream input = new ByteArrayInputStream(fData);
			Vector result = new Vector(10);
			StorableInput reader = new StorableInput(input);
			int numRead = 0;
			try {
				int count = reader.readInt();
				while (numRead < count) {
					Figure newFigure = (Figure) reader.readStorable();
					result.addElement(newFigure);
					numRead++;
				}
			} catch (IOException e) {
				System.out.println(e.toString());
			}
			return result;
		}
		return null;
	}
}

```

File: CH.ifa.draw.framework.DrawingEditor
```java

package CH.ifa.draw.framework;



public interface DrawingEditor {

	DrawingView view();

	Drawing     drawing();

	Tool        tool();

	void        toolDone();

	void        selectionChanged(DrawingView view);

	void        showStatus(String string);

}
```

File: CH.ifa.draw.framework.HJDError
```java

package CH.ifa.draw.framework;


public class HJDError extends Error {

	public HJDError(String msg) {
	    super(msg);
	}
}
```

File: CH.ifa.draw.framework.Figure
```java

package CH.ifa.draw.framework;

import CH.ifa.draw.util.*;
import java.awt.*;
import java.util.*;
import java.io.Serializable;


public interface Figure
				extends Storable, Cloneable, Serializable {

	public void moveBy(int dx, int dy);

	public void basicDisplayBox(Point origin, Point corner);

	public void displayBox(Point origin, Point corner);

	public Rectangle displayBox();

	public void draw(Graphics g);

	public Vector handles();

	public Dimension size();

	public Point center();

	public boolean isEmpty();

	public FigureEnumeration figures();

	public Figure findFigureInside(int x, int y);

	public boolean containsPoint(int x, int y);

	public Object clone();

	public void displayBox(Rectangle r);

	public boolean includes(Figure figure);

	public FigureEnumeration decompose();

	public void addToContainer(FigureChangeListener c);

	public void removeFromContainer(FigureChangeListener c);

	public FigureChangeListener listener();

	public void addFigureChangeListener(FigureChangeListener l);

	public void removeFigureChangeListener(FigureChangeListener l);

	public void release();

	public void invalidate();

	public void willChange();

	public void changed();

	public boolean canConnect();

	public Connector connectorAt(int x, int y);

	public void connectorVisibility(boolean isVisible);

	public Insets connectionInsets();

	public Locator connectedTextLocator(Figure text);

	public Object getAttribute(String name);

	public void setAttribute(String name, Object value);
}
```

File: CH.ifa.draw.framework.Locator
```java

package CH.ifa.draw.framework;

import java.awt.Point;
import java.io.Serializable;

import CH.ifa.draw.util.Storable;


public interface Locator extends Storable, Serializable, Cloneable {

	public Point locate(Figure owner);
}

```

File: CH.ifa.draw.framework.DrawingChangeListener
```java

package CH.ifa.draw.framework;

import java.util.EventListener;

public interface DrawingChangeListener extends EventListener {

	public void drawingInvalidated(DrawingChangeEvent e);

	public void drawingRequestUpdate(DrawingChangeEvent e);
}
```

File: CH.ifa.draw.framework.FigureChangeEvent
```java

package CH.ifa.draw.framework;

import java.awt.Rectangle;
import java.util.EventObject;

public class FigureChangeEvent extends EventObject {

	private Rectangle fRectangle;
	private static final Rectangle  fgEmptyRectangle = new Rectangle(0, 0, 0, 0);

	public FigureChangeEvent(Figure source, Rectangle r) {
		super(source);
		fRectangle = r;
	}

	public FigureChangeEvent(Figure source) {
		super(source);
		fRectangle = fgEmptyRectangle;
	}

	public Figure getFigure() {
		return (Figure)getSource();
	}

	public Rectangle getInvalidatedRectangle() {
		return fRectangle;
	}
}
```

File: CH.ifa.draw.framework.FigureEnumeration
```java

package CH.ifa.draw.framework;

import java.util.Enumeration;

public interface FigureEnumeration extends Enumeration {
	public Figure nextFigure();
}
```

File: CH.ifa.draw.framework.DrawingView
```java

package CH.ifa.draw.framework;

import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.image.ImageObserver;
import java.util.Vector;



public interface DrawingView extends ImageObserver, DrawingChangeListener {

	public void setEditor(DrawingEditor editor);

	public Tool tool();

	public Drawing drawing();

	public void setDrawing(Drawing d);

	public DrawingEditor editor();

	public Figure add(Figure figure);

	public Figure remove(Figure figure);

	public void addAll(Vector figures);

	public Dimension getSize();

	public Dimension getMinimumSize();

	public Dimension getPreferredSize();

	public void setDisplayUpdate(Painter updateStrategy);

	public Vector selection();

	public FigureEnumeration selectionElements();

	public Vector selectionZOrdered();

	public int selectionCount();

	public void addToSelection(Figure figure);

	public void addToSelectionAll(Vector figures);

	public void removeFromSelection(Figure figure);

	public void toggleSelection(Figure figure);

	public void clearSelection();

	public FigureSelection getFigureSelection();

	public Handle findHandle(int x, int y);

	public Point lastClick();

	public void setConstrainer(PointConstrainer p);

	public PointConstrainer getConstrainer();

	public void checkDamage();

	public void repairDamage();

	public void paint(Graphics g);

	public Image createImage(int width, int height);

	public Graphics getGraphics();

	public Color getBackground();

	public void setBackground(Color c);

	public void drawAll(Graphics g);

	public void drawHandles(Graphics g);

	public void drawDrawing(Graphics g);

	public void drawBackground(Graphics g);

	public void setCursor(Cursor c);

	public void freezeView();

	public void unfreezeView();
}
```

File: CH.ifa.draw.framework.ConnectionFigure
```java

package CH.ifa.draw.framework;

import java.awt.Point;


public interface ConnectionFigure extends Figure, FigureChangeListener {

	public void connectStart(Connector start);

	public void connectEnd(Connector end);

	public void updateConnection();

	public void disconnectStart();

	public void disconnectEnd();

	public Connector start();

	public Connector end();

	public boolean canConnect(Figure start, Figure end);

	public boolean connectsSame(ConnectionFigure other);

	public void startPoint(int x, int y);

	public void endPoint(int x, int y);

	public Point startPoint();

	public Point endPoint();

	public void setPointAt(Point p, int index);

	public Point pointAt(int index);

	public int pointCount();

	public int splitSegment(int x, int y);


	public boolean joinSegments(int x, int y);
}
```

File: CH.ifa.draw.framework.DrawingChangeEvent
```java

package CH.ifa.draw.framework;

import java.awt.Rectangle;
import java.util.EventObject;

public class DrawingChangeEvent extends EventObject {

	private Rectangle fRectangle;

	public DrawingChangeEvent(Drawing source, Rectangle r) {
		super(source);
		fRectangle = r;
	}

	public Drawing getDrawing() {
		return (Drawing)getSource();
	}

	public Rectangle getInvalidatedRectangle() {
		return fRectangle;
	}
}
```

File: CH.ifa.draw.framework.Tool
```java

package CH.ifa.draw.framework;

import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;


public interface Tool {

	public void activate();

	public void deactivate();

	public void mouseDown(MouseEvent e, int x, int y);

	public void mouseDrag(MouseEvent e, int x, int y);

	public void mouseUp(MouseEvent e, int x, int y);

	public void mouseMove(MouseEvent evt, int x, int y);

	public void keyDown(KeyEvent evt, int key);
}
```

File: CH.ifa.draw.framework.Connector
```java

package CH.ifa.draw.framework;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.Serializable;

import CH.ifa.draw.util.Storable;

public interface Connector extends Serializable, Storable {

	public abstract Point findStart(ConnectionFigure connection);

	public abstract Point findEnd(ConnectionFigure connection);

	public abstract Figure owner();

	public abstract Rectangle displayBox();

	public abstract boolean containsPoint(int x, int y);

	public abstract void draw(Graphics g);

}

```

File: CH.ifa.draw.framework.FigureChangeListener
```java

package CH.ifa.draw.framework;

import java.util.EventListener;

public interface FigureChangeListener extends EventListener {

	public void figureInvalidated(FigureChangeEvent e);

	public void figureChanged(FigureChangeEvent e);

	public void figureRemoved(FigureChangeEvent e);

	public void figureRequestRemove(FigureChangeEvent e);

	public void figureRequestUpdate(FigureChangeEvent e);

}
```

File: CH.ifa.draw.framework.Drawing
```java

package CH.ifa.draw.framework;

import java.awt.Graphics;
import java.awt.Rectangle;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.util.Storable;


public interface Drawing
		extends Storable, FigureChangeListener, Serializable {

	public void release();

	public FigureEnumeration figures();

	public FigureEnumeration figuresReverse();

	public Figure findFigure(int x, int y);

	public Figure findFigure(Rectangle r);

	public Figure findFigureWithout(int x, int y, Figure without);

	public Figure findFigure(Rectangle r, Figure without);

	public Figure findFigureInside(int x, int y);

	public Figure findFigureInsideWithout(int x, int y, Figure without);

	public void addDrawingChangeListener(DrawingChangeListener listener);

	public void removeDrawingChangeListener(DrawingChangeListener listener);

	public Enumeration drawingChangeListeners();

	public Figure add(Figure figure);

	public void addAll(Vector newFigures);

	public Figure remove(Figure figure);

	public Figure orphan(Figure figure);

	public void orphanAll(Vector newFigures);

	public void removeAll(Vector figures);

	public void replace(Figure figure, Figure replacement);

	public void sendToBack(Figure figure);

	public void bringToFront(Figure figure);

	public void draw(Graphics g);

	public void figureInvalidated(FigureChangeEvent e);

	public void figureRequestUpdate(FigureChangeEvent e);

	public void figureRequestRemove(FigureChangeEvent e);

	public void lock();

	public void unlock();

}
```

File: CH.ifa.draw.framework.Painter
```java

package CH.ifa.draw.framework;

import java.awt.Graphics;
import java.io.Serializable;


public interface Painter extends Serializable {

	public void draw(Graphics g, DrawingView view);

}
```

File: CH.ifa.draw.framework.PointConstrainer
```java

package CH.ifa.draw.framework;

import java.awt.Point;



public interface PointConstrainer {
	public Point constrainPoint(Point p);

	public int getStepX();

	public int getStepY();

}
```

File: CH.ifa.draw.framework.Handle
```java

package CH.ifa.draw.framework;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;

public interface Handle {

	public static final int HANDLESIZE = 8;

	public abstract Point locate();

	public void invokeStart(int  x, int  y, Drawing drawing);

	public void invokeStart(int  x, int  y, DrawingView view);

	public void invokeStep (int dx, int dy, Drawing drawing);

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view);

	public void invokeEnd(int x, int y, int anchorX, int anchorY, DrawingView view);

	public void invokeEnd  (int dx, int dy, Drawing drawing);

	public Figure owner();

	public Rectangle displayBox();

	public boolean containsPoint(int x, int y);

	public void draw(Graphics g);
}


```

File: CH.ifa.draw.applet.DrawApplet
```java

package CH.ifa.draw.applet;

import java.applet.Applet;
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Choice;
import java.awt.Color;
import java.awt.GraphicsEnvironment;
import java.awt.Label;
import java.awt.Panel;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.net.URL;
import java.util.StringTokenizer;

import CH.ifa.draw.figures.AttributeFigure;
import CH.ifa.draw.figures.GroupCommand;
import CH.ifa.draw.figures.PolyLineFigure;
import CH.ifa.draw.figures.UngroupCommand;
import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.BufferedUpdateStrategy;
import CH.ifa.draw.standard.ChangeAttributeCommand;
import CH.ifa.draw.standard.DeleteCommand;
import CH.ifa.draw.standard.DuplicateCommand;
import CH.ifa.draw.standard.SelectionTool;
import CH.ifa.draw.standard.SimpleUpdateStrategy;
import CH.ifa.draw.standard.StandardDrawing;
import CH.ifa.draw.standard.StandardDrawingView;
import CH.ifa.draw.standard.ToolButton;
import CH.ifa.draw.util.ColorMap;
import CH.ifa.draw.util.CommandButton;
import CH.ifa.draw.util.CommandChoice;
import CH.ifa.draw.util.Filler;
import CH.ifa.draw.util.Iconkit;
import CH.ifa.draw.util.PaletteButton;
import CH.ifa.draw.util.PaletteLayout;
import CH.ifa.draw.util.PaletteListener;
import CH.ifa.draw.util.StorableInput;


public class DrawApplet
	extends Applet
	implements DrawingEditor, PaletteListener {

	transient private Drawing fDrawing;
	transient private Tool fTool;

	transient private StandardDrawingView fView;
	transient private ToolButton fDefaultToolButton;
	transient private ToolButton fSelectedToolButton;

	transient private boolean fSimpleUpdate;
	transient private Button fUpdateButton;

	transient private Choice fFrameColor;
	transient private Choice fFillColor;
	transient private Choice fArrowChoice;
	transient private Choice fFontChoice;

	transient private Thread fSleeper;
	private Iconkit fIconkit;

	static String fgUntitled = "untitled";

	private static final String fgDrawPath = "/CH/ifa/draw/";
	public static final String IMAGES = fgDrawPath + "images/";

	public void init() {
		fIconkit = new Iconkit(this);

		setLayout(new BorderLayout());

		fView = createDrawingView();

		Panel attributes = createAttributesPanel();
		createAttributeChoices(attributes);
		add("North", attributes);

		Panel toolPanel = createToolPalette();
		createTools(toolPanel);
		add("West", toolPanel);

		add("Center", fView);
		Panel buttonPalette = createButtonPanel();
		createButtons(buttonPalette);
		add("South", buttonPalette);

		initDrawing();
		setBufferedDisplayUpdate();
		setupAttributes();
	}



	protected Panel createAttributesPanel() {
		Panel panel = new Panel();
		panel.setLayout(new PaletteLayout(2, new Point(2, 2), false));
		return panel;
	}

	protected void createAttributeChoices(Panel panel) {
		panel.add(new Label("Fill"));
		fFillColor = createColorChoice("FillColor");
		panel.add(fFillColor);


		panel.add(new Label("Pen"));
		fFrameColor = createColorChoice("FrameColor");
		panel.add(fFrameColor);

		panel.add(new Label("Arrow"));
		CommandChoice choice = new CommandChoice();
		fArrowChoice = choice;
		choice.addItem(
			new ChangeAttributeCommand(
				"none",
				"ArrowMode",
				new Integer(PolyLineFigure.ARROW_TIP_NONE),
				fView));
		choice.addItem(
			new ChangeAttributeCommand(
				"at Start",
				"ArrowMode",
				new Integer(PolyLineFigure.ARROW_TIP_START),
				fView));
		choice.addItem(
			new ChangeAttributeCommand(
				"at End",
				"ArrowMode",
				new Integer(PolyLineFigure.ARROW_TIP_END),
				fView));
		choice.addItem(
			new ChangeAttributeCommand(
				"at Both",
				"ArrowMode",
				new Integer(PolyLineFigure.ARROW_TIP_BOTH),
				fView));
		panel.add(fArrowChoice);

		panel.add(new Label("Font"));
		fFontChoice = createFontChoice();
		panel.add(fFontChoice);
	}

	protected Choice createColorChoice(String attribute) {
		CommandChoice choice = new CommandChoice();
		for (int i = 0; i < ColorMap.size(); i++)
			choice.addItem(
				new ChangeAttributeCommand(
					ColorMap.name(i),
					attribute,
					ColorMap.color(i),
					fView));
		return choice;
	}

	protected Choice createFontChoice() {
		CommandChoice choice = new CommandChoice();
		String fonts[] =
			GraphicsEnvironment
				.getLocalGraphicsEnvironment()
				.getAvailableFontFamilyNames();
		for (int i = 0; i < fonts.length; i++)
			choice.addItem(
				new ChangeAttributeCommand(
					fonts[i],
					"FontName",
					fonts[i],
					fView));
		return choice;
	}

	protected Panel createButtonPanel() {
		Panel panel = new Panel();
		panel.setLayout(new PaletteLayout(2, new Point(2, 2), false));
		return panel;
	}

	protected void createButtons(Panel panel) {
		panel.add(new Filler(24, 20));

		Choice drawingChoice = new Choice();
		drawingChoice.addItem(fgUntitled);

		String param = getParameter("DRAWINGS");
		if (param == null)
			param = "";
		StringTokenizer st = new StringTokenizer(param);
		while (st.hasMoreTokens())
			drawingChoice.addItem(st.nextToken());
		if (drawingChoice.getItemCount() > 1)
			panel.add(drawingChoice);
		else
			panel.add(new Label(fgUntitled));

		drawingChoice.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent e) {
				if (e.getStateChange() == ItemEvent.SELECTED) {
					loadDrawing((String) e.getItem());
				}
			}
		});

		panel.add(new Filler(6, 20));

		Button button;
		button = new CommandButton(new DeleteCommand("Delete", fView));
		panel.add(button);

		button = new CommandButton(new DuplicateCommand("Duplicate", fView));
		panel.add(button);

		button = new CommandButton(new GroupCommand("Group", fView));
		panel.add(button);

		button = new CommandButton(new UngroupCommand("Ungroup", fView));
		panel.add(button);

		button = new Button("Help");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				showHelp();
			}
		});
		panel.add(button);

		fUpdateButton = new Button("Simple Update");
		fUpdateButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				if (fSimpleUpdate)
					setBufferedDisplayUpdate();
				else
					setSimpleDisplayUpdate();
			}
		});

	}

	protected Panel createToolPalette() {
		Panel palette = new Panel();
		palette.setLayout(new PaletteLayout(2, new Point(2, 2)));
		return palette;
	}

	protected void createTools(Panel palette) {
		Tool tool = createSelectionTool();

		fDefaultToolButton =
			createToolButton(IMAGES + "SEL", "Selection Tool", tool);
		palette.add(fDefaultToolButton);
	}

	protected Tool createSelectionTool() {
		return new SelectionTool(view());
	}

	protected ToolButton createToolButton(
		String iconName,
		String toolName,
		Tool tool) {
		return new ToolButton(this, iconName, toolName, tool);
	}

	protected Drawing createDrawing() {
		return new StandardDrawing();
	}

	protected StandardDrawingView createDrawingView() {
		return new StandardDrawingView(this, 410, 370);
	}

	public void paletteUserSelected(PaletteButton button) {
		ToolButton toolButton = (ToolButton) button;
		setTool(toolButton.tool(), toolButton.name());
		setSelected(toolButton);
	}

	public void paletteUserOver(PaletteButton button, boolean inside) {
		if (inside)
			showStatus(((ToolButton) button).name());
		else
			showStatus(fSelectedToolButton.name());
	}

	public Drawing drawing() {
		return fDrawing;
	}

	public Tool tool() {
		return fTool;
	}

	public DrawingView view() {
		return fView;
	}

	public void toolDone() {
		setTool(fDefaultToolButton.tool(), fDefaultToolButton.name());
		setSelected(fDefaultToolButton);
	}

	public void selectionChanged(DrawingView view) {
		setupAttributes();
	}

	private void initDrawing() {
		fDrawing = createDrawing();
		fView.setDrawing(fDrawing);
		toolDone();
	}

	private void setTool(Tool t, String name) {
		if (fTool != null)
			fTool.deactivate();
		fTool = t;
		if (fTool != null) {
			showStatus(name);
			fTool.activate();
		}
	}

	private void setSelected(ToolButton button) {
		if (fSelectedToolButton != null)
			fSelectedToolButton.reset();
		fSelectedToolButton = button;
		if (fSelectedToolButton != null)
			fSelectedToolButton.select();
	}

	protected void loadDrawing(String param) {
		if (param == fgUntitled) {
			fDrawing.release();
			initDrawing();
			return;
		}

		String filename = getParameter(param);
		if (filename != null)
			readDrawing(filename);
	}

	private void readDrawing(String filename) {
		toolDone();
		String type = guessType(filename);
		if (type.equals("storable"))
			readFromStorableInput(filename);
		else if (type.equals("serialized"))
			readFromObjectInput(filename);
		else
			showStatus("Unknown file type");
	}

	private void readFromStorableInput(String filename) {
		try {
			URL url = new URL(getCodeBase(), filename);
			InputStream stream = url.openStream();
			StorableInput input = new StorableInput(stream);
			fDrawing.release();

			fDrawing = (Drawing) input.readStorable();
			fView.setDrawing(fDrawing);
		}
		catch (IOException e) {
			initDrawing();
			showStatus("Error:" + e);
		}
	}

	private void readFromObjectInput(String filename) {
		try {
			URL url = new URL(getCodeBase(), filename);
			InputStream stream = url.openStream();
			ObjectInput input = new ObjectInputStream(stream);
			fDrawing.release();
			fDrawing = (Drawing) input.readObject();
			fView.setDrawing(fDrawing);
		}
		catch (IOException e) {
			initDrawing();
			showStatus("Error: " + e);
		}
		catch (ClassNotFoundException e) {
			initDrawing();
			showStatus("Class not found: " + e);
		}
	}

	private String guessType(String file) {
		if (file.endsWith(".draw"))
			return "storable";
		if (file.endsWith(".ser"))
			return "serialized";
		return "unknown";
	}

	private void setupAttributes() {
		Color frameColor =
			(Color) AttributeFigure.getDefaultAttribute("FrameColor");
		Color fillColor =
			(Color) AttributeFigure.getDefaultAttribute("FillColor");
		Integer arrowMode =
			(Integer) AttributeFigure.getDefaultAttribute("ArrowMode");
		String fontName =
			(String) AttributeFigure.getDefaultAttribute("FontName");

		FigureEnumeration k = fView.selectionElements();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();
			frameColor = (Color) f.getAttribute("FrameColor");
			fillColor = (Color) f.getAttribute("FillColor");
			arrowMode = (Integer) f.getAttribute("ArrowMode");
			fontName = (String) f.getAttribute("FontName");
		}

		fFrameColor.select(ColorMap.colorIndex(frameColor));
		fFillColor.select(ColorMap.colorIndex(fillColor));
		if (arrowMode != null)
			fArrowChoice.select(arrowMode.intValue());
		if (fontName != null)
			fFontChoice.select(fontName);
	}

	protected void setSimpleDisplayUpdate() {
		fView.setDisplayUpdate(new SimpleUpdateStrategy());
		fUpdateButton.setLabel("Simple Update");
		fSimpleUpdate = true;
	}

	protected void setBufferedDisplayUpdate() {
		fView.setDisplayUpdate(new BufferedUpdateStrategy());
		fUpdateButton.setLabel("Buffered Update");
		fSimpleUpdate = false;
	}

	protected void showHelp() {
		try {
			String appletPath = getClass().getName().replace('.', '/');
			URL url = new URL(getCodeBase(), appletPath + "Help.html");
			getAppletContext().showDocument(url, "Help");
		}
		catch (IOException e) {
			showStatus("Help file not found");
		}

	}

	private void startSleeper() {
		if (fSleeper == null)
			fSleeper = new SleeperThread(this);
		fSleeper.start();
	}

	private void stopSleeper() {
		if (fSleeper != null)
			fSleeper.stop();
	}
}
```

File: CH.ifa.draw.applet.SleeperThread
```java

package CH.ifa.draw.applet;

import java.applet.Applet;


class SleeperThread extends Thread {

	Applet  fApplet;

	SleeperThread(Applet applet) {
		fApplet = applet;
	}

	public void run() {
		try {
			for (;;) {
				fApplet.showStatus("loading icons...");
				sleep(50);
			}
		} catch (InterruptedException e) {
			return;
		}
	}

}

```

File: CH.ifa.draw.contrib.PolygonHandle
```java

package CH.ifa.draw.contrib;

import java.awt.Point;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.AbstractHandle;


public class PolygonHandle extends AbstractHandle {

  private int fIndex;
  private Locator fLocator;

  public PolygonHandle(PolygonFigure owner, Locator l, int index) {
	super(owner);
	fLocator = l;
	fIndex = index;
  }  

  public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
	myOwner().setPointAt(new Point(x, y), fIndex);
  }  

  public void invokeEnd  (int x, int y, int anchorX, int anchorY, DrawingView view) {
	myOwner().smoothPoints();
  }  

  public Point locate() {
	return fLocator.locate(owner());
  }  

  private PolygonFigure myOwner() {
	return (PolygonFigure)owner();
  }  
}


```

File: CH.ifa.draw.contrib.TriangleRotationHandle
```java

package CH.ifa.draw.contrib;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.standard.AbstractHandle;
import CH.ifa.draw.util.Geom;


class TriangleRotationHandle extends AbstractHandle {

  private Point fOrigin = null;
  private Point fCenter = null;

  public TriangleRotationHandle(TriangleFigure owner) {
	super(owner);
 } 

  public void invokeStart(int  x, int  y, Drawing drawing) {
	fCenter = owner().center();
	fOrigin = getOrigin();
  }  

  public void invokeStep (int dx, int dy, Drawing drawing) {
	double angle = Math.atan2(fOrigin.y + dy - fCenter.y,
							  fOrigin.x + dx - fCenter.x);
	((TriangleFigure)(owner())).rotate(angle);
  }  

  public void invokeEnd  (int dx, int dy, Drawing drawing) {
	fOrigin = null;
	fCenter = null;
  }  

  public Point locate() {
	return getOrigin();
  }  

  Point getOrigin() { // find a nice place to put handle
	Polygon p = ((TriangleFigure)(owner())).polygon();
	Point first = new Point(p.xpoints[0], p.ypoints[0]);
	Point ctr = owner().center();
	double len = Geom.length(first.x, first.y, ctr.x, ctr.y);
	if (len == 0) // best we can do?
	  return new Point(first.x - HANDLESIZE/2, first.y + HANDLESIZE/2);

	double u = HANDLESIZE / len;
	if (u > 1.0) // best we can do?
	  return new Point((first.x * 3 + ctr.x)/4, (first.y * 3 + ctr.y)/4);
	else
	  return new Point((int)(first.x * (1.0 - u) + ctr.x * u),
					   (int)(first.y * (1.0 - u) + ctr.y * u));
  }  

  public void draw(Graphics g) {
	Rectangle r = displayBox();

	g.setColor(Color.yellow);
	g.fillOval(r.x, r.y, r.width, r.height);

	g.setColor(Color.black);
	g.drawOval(r.x, r.y, r.width, r.height);
  }  
}

```

File: CH.ifa.draw.contrib.ChopPolygonConnector
```java

package CH.ifa.draw.contrib;

import java.awt.Point;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.ChopBoxConnector;

public class ChopPolygonConnector extends ChopBoxConnector {

	private static final long serialVersionUID = -156024908227796826L;

	public ChopPolygonConnector() {
	}

	public ChopPolygonConnector(Figure owner) {
		super(owner);
	}

	protected Point chop(Figure target, Point from) {
		return ((PolygonFigure)target).chop(from);
	}
}

```

File: CH.ifa.draw.contrib.TriangleFigure
```java

package CH.ifa.draw.contrib;

import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Vector;

import CH.ifa.draw.figures.RectangleFigure;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public  class TriangleFigure extends RectangleFigure {

  static double[] rotations = {
	-Math.PI/2, -Math.PI/4,
	0.0, Math.PI/4,
	Math.PI/2, Math.PI * 3/4,
	Math.PI,  -Math.PI * 3/4
  };

  protected int fRotation = 0;

  public TriangleFigure() {
	super(new Point(0,0), new Point(0,0));
  }  

  public TriangleFigure(Point origin, Point corner) {
	super(origin, corner);
  }  

  public Vector handles() {
	Vector h = super.handles();
	h.addElement(new TriangleRotationHandle(this));
	return h;
  }  

  public void rotate(double angle) {
	willChange();
	double dist = Double.MAX_VALUE;
	int best = 0;
	for (int i = 0; i < rotations.length; ++i) {
	  double d = Math.abs(angle - rotations[i]);
	  if (d < dist) {
		dist = d;
		best = i;
	  }
	}
	fRotation = best;
	changed();
  }  

  public Polygon polygon() {
	Rectangle r = displayBox();
	Polygon p = new Polygon();
	switch (fRotation) {
	case 0:
	  p.addPoint(r.x+r.width/2, r.y);
	  p.addPoint(r.x+r.width, r.y+r.height);
	  p.addPoint(r.x, r.y+r.height);
	  break;
	case 1:
	  p.addPoint(r.x + r.width, r.y);
	  p.addPoint(r.x+r.width, r.y+r.height);
	  p.addPoint(r.x, r.y);
	  break;
	case 2:
	  p.addPoint(r.x + r.width, r.y+r.height/2);
	  p.addPoint(r.x, r.y+r.height);
	  p.addPoint(r.x, r.y);
	  break;
	case 3:
	  p.addPoint(r.x+r.width, r.y+r.height);
	  p.addPoint(r.x, r.y+r.height);
	  p.addPoint(r.x + r.width, r.y);
	  break;
	case 4:
	  p.addPoint(r.x+r.width/2, r.y+r.height);
	  p.addPoint(r.x, r.y);
	  p.addPoint(r.x + r.width, r.y);
	  break;
	case 5:
	  p.addPoint(r.x, r.y+r.height);
	  p.addPoint(r.x, r.y);
	  p.addPoint(r.x+r.width, r.y+r.height);
	  break;
	case 6:
	  p.addPoint(r.x, r.y+r.height/2);
	  p.addPoint(r.x + r.width, r.y);
	  p.addPoint(r.x+r.width, r.y+r.height);
	  break;
	case 7:
	  p.addPoint(r.x, r.y);
	  p.addPoint(r.x + r.width, r.y);
	  p.addPoint(r.x, r.y+r.height);
	  break;
	}
	return p;
  }  


  public void draw(Graphics g) {
	Polygon p = polygon();
	g.setColor(getFillColor());
	g.fillPolygon(p);
	g.setColor(getFrameColor());
	g.drawPolygon(p);
  }  


  public Insets connectionInsets() {
	Rectangle r = displayBox();
	switch(fRotation) {
	case 0:
	  return new Insets(r.height, r.width/2, 0, r.width/2);
	case 1:
	  return new Insets(0, r.width, r.height, 0);
	case 2:
	  return new Insets(r.height/2, 0, r.height/2, r.width);
	case 3:
	  return new Insets(r.height, r.width, 0, 0);
	case 4:
	  return new Insets(0, r.width/2, r.height, r.width/2);
	case 5:
	  return new Insets(r.height, 0, 0, r.width);
	case 6:
	  return new Insets(r.height/2, r.width, r.height/2, 0);
	case 7:
	  return new Insets(0, 0, r.height, r.width);
	default:
	  return null;
	}
  }  

  public boolean containsPoint(int x, int y) {
	return polygon().contains(x, y);
  }  

  public Point center() {
	return PolygonFigure.center(polygon());
  }  

  public Point chop(Point p) {
	return PolygonFigure.chop(polygon(), p);
  }  

  public Object clone() {
	TriangleFigure figure = (TriangleFigure) super.clone();
	figure.fRotation = fRotation;
	return figure;
  }  


	public void write(StorableOutput dw) {
	  super.write(dw);
	  dw.writeInt(fRotation);
	}

	public void read(StorableInput dr) throws IOException {
	  super.read(dr);
	  fRotation = dr.readInt();
	}
}
```

File: CH.ifa.draw.contrib.DiamondFigure
```java

package CH.ifa.draw.contrib;

import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;

import CH.ifa.draw.figures.RectangleFigure;

public  class DiamondFigure extends RectangleFigure {


  public DiamondFigure() {
	super(new Point(0,0), new Point(0,0));
  }  

  public DiamondFigure(Point origin, Point corner) {
	super(origin,corner);
  }  

  protected Polygon polygon() {
	Rectangle r = displayBox();
	Polygon p = new Polygon();
	p.addPoint(r.x, r.y+r.height/2);
	p.addPoint(r.x+r.width/2, r.y);
	p.addPoint(r.x+r.width, r.y+r.height/2);
	p.addPoint(r.x+r.width/2, r.y+r.height);
	return p;
  }  

  public void draw(Graphics g) {
	Polygon p = polygon();
	g.setColor(getFillColor());
	g.fillPolygon(p);
	g.setColor(getFrameColor());
	g.drawPolygon(p);
  }  

  public Insets connectionInsets() {
	Rectangle r = displayBox();
	return new Insets(r.height/2, r.width/2, r.height/2, r.width/2);
  }  

  public boolean containsPoint(int x, int y) {
	return polygon().contains(x, y);
  }  


}
```

File: CH.ifa.draw.contrib.PolygonTool
```java

package CH.ifa.draw.contrib;

import java.awt.Point;
import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.standard.AbstractTool;


public class PolygonTool extends AbstractTool {

  private PolygonFigure  fPolygon;
  private int            fLastX, fLastY;

  public PolygonTool(DrawingView view) {
	super(view);
  }  

  public void activate() {
	super.activate();
	fPolygon = null;
  }  

  public void deactivate() {
	super.deactivate();
	if (fPolygon != null) {
	  fPolygon.smoothPoints();
	  if (fPolygon.pointCount() < 3 ||
		  fPolygon.size().width < 4 || fPolygon.size().height < 4)
		drawing().remove(fPolygon);
	}
	fPolygon = null;
  }  

  private void addPoint(int x, int y) {
	  if (fPolygon == null) {
		  fPolygon = new PolygonFigure(x, y);
		  view().add(fPolygon);
		  fPolygon.addPoint(x, y);
	  } else if (fLastX != x || fLastY != y)
		  fPolygon.addPoint(x, y);

	  fLastX = x;
	  fLastY = y;
  }  

  public void mouseDown(MouseEvent e, int x, int y) {
	x = e.getX();
	y = e.getY();

	if (e.getClickCount() >= 2) {
		if (fPolygon != null) {
			fPolygon.smoothPoints();
			editor().toolDone();
		}
		fPolygon = null;

	} else {
		addPoint(e.getX(), e.getY());
	}
  }  

  public void mouseMove(MouseEvent e, int x, int y) {
	if (fPolygon != null) {
	   if (fPolygon.pointCount() > 1) {
		   fPolygon.setPointAt(new Point(x, y), fPolygon.pointCount()-1);
		   view().checkDamage();
	   }
	}
  }  

  public void mouseDrag(MouseEvent e, int x, int y) {
	x = e.getX();
	y = e.getY();
	addPoint(x, y);
  }  


  public void mouseUp(MouseEvent e, int x, int y) {
  }  

}
```

File: CH.ifa.draw.contrib.PolygonScaleHandle
```java

package CH.ifa.draw.contrib;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.standard.AbstractHandle;
import CH.ifa.draw.util.Geom;


class PolygonScaleHandle extends AbstractHandle {

  private Point fOrigin = null;
  private Point fCurrent = null;
  private Polygon fOrigPoly = null;

  public PolygonScaleHandle(PolygonFigure owner) {
	super(owner);
 } 

  public void invokeStart(int  x, int  y, Drawing drawing) {
	fOrigPoly = ((PolygonFigure)(owner())).getPolygon();
	fOrigin = getOrigin();
	fCurrent = new Point(fOrigin.x, fOrigin.y);
  }  

  public void invokeStep (int dx, int dy, Drawing drawing) {
	fCurrent = new Point(fOrigin.x + dx, fOrigin.y + dy);
	((PolygonFigure)(owner())).scaleRotate(fOrigin, fOrigPoly, fCurrent);
  }  

  public void invokeEnd  (int dx, int dy, Drawing drawing) {
	fOrigPoly = null;
	fOrigin = null;
	fCurrent = null;
  }  

  public Point locate() {
	if (fCurrent != null)
	  return fCurrent;
	else
	  return getOrigin();
  }  

  Point getOrigin() { // find a nice place to put handle


	Point outer = ((PolygonFigure)(owner())).outermostPoint();
	Point ctr = ((PolygonFigure)(owner())).center();
	double len = Geom.length(outer.x, outer.y, ctr.x, ctr.y);
	if (len == 0) // best we can do?
	  return new Point(outer.x - HANDLESIZE/2, outer.y + HANDLESIZE/2);

	double u = HANDLESIZE / len;
	if (u > 1.0) // best we can do?
	  return new Point((outer.x * 3 + ctr.x)/4, (outer.y * 3 + ctr.y)/4);
	else
	  return new Point((int)(outer.x * (1.0 - u) + ctr.x * u),
					   (int)(outer.y * (1.0 - u) + ctr.y * u));
  }  

  public void draw(Graphics g) {
	Rectangle r = displayBox();

	g.setColor(Color.yellow);
	g.fillOval(r.x, r.y, r.width, r.height);

	g.setColor(Color.black);
	g.drawOval(r.x, r.y, r.width, r.height);

  }  
}

```

File: CH.ifa.draw.contrib.PolygonFigure
```java

package CH.ifa.draw.contrib;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.figures.AttributeFigure;
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.AbstractLocator;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public  class PolygonFigure extends AttributeFigure {

  static final int TOO_CLOSE = 2;

  private static final long serialVersionUID = 6254089689239215026L;
  private int polygonFigureSerializedDataVersion = 1;

  protected Polygon fPoly = new Polygon();

  public PolygonFigure() {
	super();
  }  

  public PolygonFigure(int x, int y) {
	fPoly.addPoint(x, y);
  }  

  public PolygonFigure(Polygon p) {
	fPoly = new Polygon(p.xpoints, p.ypoints, p.npoints);
  }  

  public Rectangle displayBox() {
	return bounds(fPoly);
  }  


  public boolean isEmpty() {
	return (fPoly.npoints < 3 ||
			(size().width < TOO_CLOSE) && (size().height < TOO_CLOSE));
  }  

  public Vector handles() {
	Vector handles = new Vector(fPoly.npoints);
	for (int i = 0; i < fPoly.npoints; i++)
	  handles.addElement(new PolygonHandle(this, locator(i), i));
	handles.addElement(new PolygonScaleHandle(this));
	return handles;
  }  


  public void basicDisplayBox(Point origin, Point corner) {
	Rectangle r = displayBox();
	int dx = origin.x - r.x;
	int dy = origin.y - r.y;
	fPoly.translate(dx, dy);
	r = displayBox();
	Point oldCorner = new Point(r.x + r.width, r.y + r.height);
	Polygon p = getPolygon();
	scaleRotate(oldCorner, p, corner);
  }  

  public Polygon getPolygon() {
	return new Polygon(fPoly.xpoints, fPoly.ypoints, fPoly.npoints);
  }  

  public Point center() {
	return center(fPoly);
  }  

  public Enumeration points() {
	Vector pts = new Vector(fPoly.npoints);
	for (int i = 0; i < fPoly.npoints; ++i)
	  pts.addElement(new Point(fPoly.xpoints[i], fPoly.ypoints[i]));
	return pts.elements();
  }  

  public int pointCount() {
	return fPoly.npoints;
  }  

  public void basicMoveBy(int dx, int dy) {
	fPoly.translate(dx, dy);
  }  

  public void drawBackground(Graphics g) {
	  g.fillPolygon(fPoly);
  }  

  public void drawFrame(Graphics g) {
	  g.drawPolygon(fPoly);
  }  

  public boolean containsPoint(int x, int y) {
	return fPoly.contains(x, y);
  }  

  public Connector connectorAt(int x, int y) {
	return new ChopPolygonConnector(this);
  }  

  public  void addPoint(int x, int y) {
	fPoly.addPoint(x, y);
	changed();
  }  


  public  void setPointAt(Point p, int i) {
	willChange();
	fPoly.xpoints[i] = p.x;
	fPoly.ypoints[i] = p.y;
	changed();
  }  

  public  void insertPointAt(Point p, int i) {
	willChange();
	int n = fPoly.npoints + 1;
	int[] xs = new int[n];
	int[] ys = new int[n];
	for (int j = 0; j < i; ++j) {
	  xs[j] = fPoly.xpoints[j];
	  ys[j] = fPoly.ypoints[j];
	}
	xs[i] = p.x;
	ys[i] = p.y;
	for (int j = i; j < fPoly.npoints; ++j) {
	  xs[j+1] = fPoly.xpoints[j];
	  ys[j+1] = fPoly.ypoints[j];
	}

	fPoly = new Polygon(xs, ys, n);
	changed();
  }  

  public  void removePointAt(int i) {
	willChange();
	int n = fPoly.npoints - 1;
	int[] xs = new int[n];
	int[] ys = new int[n];
	for (int j = 0; j < i; ++j) {
	  xs[j] = fPoly.xpoints[j];
	  ys[j] = fPoly.ypoints[j];
	}
	for (int j = i; j < n; ++j) {
	  xs[j] = fPoly.xpoints[j+1];
	  ys[j] = fPoly.ypoints[j+1];
	}
	fPoly = new Polygon(xs, ys, n);
	changed();
  }  

  public  void scaleRotate(Point anchor, Polygon originalPolygon, Point p) {
	willChange();

	Point ctr = center(originalPolygon);
	double anchorLen = Geom.length(ctr.x, ctr.y, anchor.x, anchor.y);

	if (anchorLen > 0.0) {
	  double newLen = Geom.length(ctr.x, ctr.y, p.x, p.y);
	  double ratio = newLen / anchorLen;

	  double anchorAngle = Math.atan2(anchor.y - ctr.y, anchor.x - ctr.x);
	  double newAngle = Math.atan2(p.y - ctr.y, p.x - ctr.x);
	  double rotation = newAngle - anchorAngle;

	  int n = originalPolygon.npoints;
	  int[] xs = new int[n];
	  int[] ys = new int[n];

	  for (int i = 0; i < n; ++i) {
		int x = originalPolygon.xpoints[i];
		int y = originalPolygon.ypoints[i];
		double l = Geom.length(ctr.x, ctr.y, x, y) * ratio;
		double a = Math.atan2(y - ctr.y, x - ctr.x) + rotation;
		xs[i] = (int)(ctr.x + l * Math.cos(a) + 0.5);
		ys[i] = (int)(ctr.y + l * Math.sin(a) + 0.5);
	  }
	  fPoly =  new Polygon(xs, ys, n);
	}
	changed();
  }  


  public void smoothPoints() {
	willChange();
	boolean removed = false;
	int n = fPoly.npoints;
	do {
	  removed = false;
	  int i = 0;
	  while (i < n && n >= 3) {
		int nxt = (i + 1) % n;
		int prv = (i - 1 + n) % n;

		if ((distanceFromLine(fPoly.xpoints[prv], fPoly.ypoints[prv],
							  fPoly.xpoints[nxt], fPoly.ypoints[nxt],
							  fPoly.xpoints[i], fPoly.ypoints[i]) < TOO_CLOSE)) {
		  removed = true;
		  --n;
		  for (int j = i; j < n; ++j) {
			fPoly.xpoints[j] = fPoly.xpoints[j+1];
			fPoly.ypoints[j] = fPoly.ypoints[j+1];
		  }
		}
		else
		  ++i;
	  }
	} while(removed);
	if (n != fPoly.npoints)
	  fPoly =  new Polygon(fPoly.xpoints, fPoly.ypoints, n);
	changed();
  }  

  public int splitSegment(int x, int y) {
	int i = findSegment(x, y);
	if (i != -1) {
	  insertPointAt(new Point(x, y), i+1);
	  return i + 1;
	}
	else
	  return -1;
  }  

  public Point pointAt(int i) {
	return new Point(fPoly.xpoints[i], fPoly.ypoints[i]);
  }  

  public Point outermostPoint() {
	Point ctr = center();
	int outer = 0;
	long dist = 0;

	for (int i = 0; i < fPoly.npoints; ++i) {
	  long d = Geom.length2(ctr.x, ctr.y, fPoly.xpoints[i], fPoly.ypoints[i]);
	  if (d > dist) {
		dist = d;
		outer = i;
	  }
	}

	return new Point(fPoly.xpoints[outer], fPoly.ypoints[outer]);
  }  


  public int findSegment(int x, int y) {
	double dist = TOO_CLOSE;
	int best = -1;

	for (int i = 0; i < fPoly.npoints; i++) {
	  int n = (i + 1) % fPoly.npoints;
	  double d =  distanceFromLine(fPoly.xpoints[i], fPoly.ypoints[i],
								   fPoly.xpoints[n], fPoly.ypoints[n],
								   x, y);
	  if (d < dist) {
		dist = d;
		best = i;
	  }
	}
	return best;
  }  

  public Point chop(Point p) {
	return chop(fPoly, p);
  }  

  public void write(StorableOutput dw) {
	super.write(dw);
	dw.writeInt(fPoly.npoints);
	for (int i = 0; i < fPoly.npoints; ++i) {
	  dw.writeInt(fPoly.xpoints[i]);
	  dw.writeInt(fPoly.ypoints[i]);
	}
  }  

  public void read(StorableInput dr) throws IOException {
	super.read(dr);
	int size = dr.readInt();
	int[] xs = new int[size];
	int[] ys = new int[size];
	for (int i = 0; i < size; i++) {
	  xs[i] = dr.readInt();
	  ys[i] = dr.readInt();
	}
	fPoly = new Polygon(xs, ys, size);
  }  

  public static Locator locator(final int pointIndex) {
	return new AbstractLocator() {
	  public Point locate(Figure owner) {
		PolygonFigure plf = (PolygonFigure)owner;
		if (pointIndex < plf.pointCount())
		  return ((PolygonFigure)owner).pointAt(pointIndex);
		return new Point(-1, -1);
	  }
	};
  }  

  public static double distanceFromLine(int xa, int ya,
										int xb, int yb,
										int xc, int yc) {



	int xdiff = xb - xa;
	int ydiff = yb - ya;
	long l2 = xdiff*xdiff + ydiff*ydiff;

	if (l2 == 0) return Geom.length(xa, ya, xc, yc);

	double rnum =  (ya-yc) * (ya-yb) - (xa-xc) * (xb-xa);
	double r = rnum / l2;

	if (r < 0.0 || r > 1.0) return Double.MAX_VALUE;

	double xi = xa + r * xdiff;
	double yi = ya + r * ydiff;
	double xd = xc - xi;
	double yd = yc - yi;
	return Math.sqrt(xd * xd + yd * yd);

  }  


  public static Rectangle bounds(Polygon p) {
	int minx = Integer.MAX_VALUE;
	int miny = Integer.MAX_VALUE;
	int maxx = Integer.MIN_VALUE;
	int maxy = Integer.MIN_VALUE;
	int n = p.npoints;
	for (int i = 0; i < n; i++) {
	  int x = p.xpoints[i];
	  int y = p.ypoints[i];
	  if (x > maxx) maxx = x;
	  if (x < minx) minx = x;
	  if (y > maxy) maxy = y;
	  if (y < miny) miny = y;
	}

	return new Rectangle(minx, miny, maxx-minx, maxy-miny);
  }  

  public static Point center(Polygon p) {
	long sx = 0;
	long sy = 0;
	int n = p.npoints;
	for (int i = 0; i < n; i++) {
	  sx += p.xpoints[i];
	  sy += p.ypoints[i];
	}

	return new Point((int)(sx/n), (int)(sy/n));
  }  

  public static Point chop(Polygon poly, Point p) {
	Point ctr = center(poly);
	int cx = -1;
	int cy = -1;
	long len = Long.MAX_VALUE;


	for (int i = 0; i < poly.npoints; ++i) {
	  int nxt = (i + 1) % poly.npoints;
	  Point chop = Geom.intersect(poly.xpoints[i],
							 poly.ypoints[i],
							 poly.xpoints[nxt],
							 poly.ypoints[nxt],
							 p.x,
							 p.y,
							 ctr.x,
							 ctr.y);
	  if (chop != null) {
		long cl = Geom.length2(chop.x, chop.y, p.x, p.y);
		if (cl < len) {
		  len = cl;
		  cx = chop.x;
		  cy = chop.y;
		}
	  }
	}
	{ // try anyway
	  for (int i = 0; i < poly.npoints; ++i) {
		long l = Geom.length2(poly.xpoints[i], poly.ypoints[i], p.x, p.y);
		if (l < len) {
		  len = l;
		  cx = poly.xpoints[i];
		  cy = poly.ypoints[i];
		}
	  }
	}
	return new Point(cx, cy);
  }  

}

```

File: CH.ifa.draw.standard.FigureTransferCommand
```java

package CH.ifa.draw.standard;

import java.util.Vector;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.framework.FigureSelection;
import CH.ifa.draw.util.Clipboard;
import CH.ifa.draw.util.Command;

abstract class FigureTransferCommand extends Command {

	protected DrawingView fView;

	protected FigureTransferCommand(String name, DrawingView view) {
		super(name);
		fView = view;
	}

	protected void deleteSelection() {
	   fView.drawing().removeAll(fView.selection());
	   fView.clearSelection();
	}

	protected void copySelection() {
		FigureSelection selection = fView.getFigureSelection();
		Clipboard.getClipboard().setContents(selection);
	}

	protected void insertFigures(Vector figures, int dx, int dy) {
		FigureEnumeration e = new FigureEnumerator(figures);
		while (e.hasMoreElements()) {
			Figure figure = e.nextFigure();
			figure.moveBy(dx, dy);
			figure = fView.add(figure);
			fView.addToSelection(figure);
		}
	}

}


```

File: CH.ifa.draw.standard.SouthHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

class SouthHandle extends LocatorHandle {
	SouthHandle(Figure owner) {
		super(owner, RelativeLocator.south());
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Rectangle r = owner().displayBox();
		owner().displayBox(
			new Point(r.x, r.y),
			new Point(r.x + r.width, Math.max(r.y, y))
		);
	}
}

```

File: CH.ifa.draw.standard.ChopBoxConnector
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.util.Geom;

public class ChopBoxConnector extends AbstractConnector {

	private static final long serialVersionUID = -1461450322712345462L;

	public ChopBoxConnector() { // only used for Storable implementation
	}

	public ChopBoxConnector(Figure owner) {
		super(owner);
	}

	public Point findStart(ConnectionFigure connection) {
		Figure startFigure = connection.start().owner();
		Rectangle r2 = connection.end().displayBox();
		Point r2c = null;

		if (connection.pointCount() == 2)
			r2c = new Point(r2.x + r2.width/2, r2.y + r2.height/2);
		 else
			r2c = connection.pointAt(1);

		return chop(startFigure, r2c);
	}

	public Point findEnd(ConnectionFigure connection) {
		Figure endFigure = connection.end().owner();
		Rectangle r1 = connection.start().displayBox();
		Point r1c = null;

		if (connection.pointCount() == 2)
			r1c = new Point(r1.x + r1.width/2, r1.y + r1.height/2);
		 else
			r1c = connection.pointAt(connection.pointCount()-2);

		return chop(endFigure, r1c);
	}

	protected Point chop(Figure target, Point from) {
		Rectangle r = target.displayBox();
		return Geom.angleToPoint(r, (Geom.pointToAngle(r, from)));
	}
}

```

File: CH.ifa.draw.standard.AbstractConnector
```java

package CH.ifa.draw.standard;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;

import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public abstract class AbstractConnector implements Connector {
	private Figure      fOwner;

	private static final long serialVersionUID = -5170007865562687545L;
	private int abstractConnectorSerializedDataVersion = 1;

	public AbstractConnector() {
		fOwner = null;
	}

	public AbstractConnector(Figure owner) {
		fOwner = owner;
	}

	public Figure owner() {
		return fOwner;
	}

	public Point findStart(ConnectionFigure connection) {
		return findPoint(connection);
	}

	public Point findEnd(ConnectionFigure connection) {
		return findPoint(connection);
	}

	protected Point findPoint(ConnectionFigure connection) {
		return Geom.center(displayBox());
	}

	public Rectangle displayBox() {
		return owner().displayBox();
	}

	public boolean containsPoint(int x, int y) {
		return owner().containsPoint(x, y);
	}

	public void draw(Graphics g) {
	}

	public void write(StorableOutput dw) {
		dw.writeStorable(fOwner);
	}

	public void read(StorableInput dr) throws IOException {
		fOwner = (Figure)dr.readStorable();
	}

}

```

File: CH.ifa.draw.standard.ChangeConnectionHandle
```java

package CH.ifa.draw.standard;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.Geom;

public abstract class ChangeConnectionHandle extends AbstractHandle {

	protected Connector         fOriginalTarget;
	protected Figure            fTarget;
	protected ConnectionFigure  fConnection;
	protected Point             fStart;

	protected ChangeConnectionHandle(Figure owner) {
		super(owner);
		fConnection = (ConnectionFigure) owner();
		fTarget = null;
	}

	protected abstract Connector target();

	protected abstract void disconnect();

	protected abstract void connect(Connector c);

	protected abstract void setPoint(int x, int y);

	protected Connector source() {
		if (target() == fConnection.start())
			return fConnection.end();
		return fConnection.start();
	}

	public void invokeStart(int  x, int  y, DrawingView view) {
		fOriginalTarget = target();
		fStart = new Point(x, y);
		disconnect();
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Point p = new Point(x, y);
		Figure f = findConnectableFigure(x, y, view.drawing());
		if (f != fTarget) {
			if (fTarget != null)
				fTarget.connectorVisibility(false);
			fTarget = f;
			if (fTarget != null)
				fTarget.connectorVisibility(true);
		}

		Connector target = findConnectionTarget(p.x, p.y, view.drawing());
		if (target != null)
			p = Geom.center(target.displayBox());
		setPoint(p.x, p.y);
	}

	public void invokeEnd(int x, int y, int anchorX, int anchorY, DrawingView view) {
		Connector target = findConnectionTarget(x, y, view.drawing());
		if (target == null)
			target = fOriginalTarget;

		setPoint(x, y);
		connect(target);
		fConnection.updateConnection();
		if (fTarget != null) {
			fTarget.connectorVisibility(false);
			fTarget = null;
		}
	}

	private Connector findConnectionTarget(int x, int y, Drawing drawing) {
		Figure target = findConnectableFigure(x, y, drawing);

		if ((target != null) && target.canConnect()
			 && target != fOriginalTarget
			 && !target.includes(owner())
			 && fConnection.canConnect(source().owner(), target)) {
				return findConnector(x, y, target);
		}
		return null;
	}

	protected Connector findConnector(int x, int y, Figure f) {
		return f.connectorAt(x, y);
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();

		g.setColor(Color.green);
		g.fillRect(r.x, r.y, r.width, r.height);

		g.setColor(Color.black);
		g.drawRect(r.x, r.y, r.width, r.height);
	}

	private Figure findConnectableFigure(int x, int y, Drawing drawing) {
		FigureEnumeration k = drawing.figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (!figure.includes(fConnection) && figure.canConnect()) {
				if (figure.containsPoint(x, y))
					return figure;
			}
		}
		return null;
	}
}
```

File: CH.ifa.draw.standard.DeleteCommand
```java

package CH.ifa.draw.standard;

import CH.ifa.draw.framework.DrawingView;

public class DeleteCommand extends FigureTransferCommand {

	public DeleteCommand(String name, DrawingView view) {
		super(name, view);
	}

	public void execute() {
		deleteSelection();
		fView.checkDamage();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}

}


```

File: CH.ifa.draw.standard.AbstractLocator
```java

package CH.ifa.draw.standard;

import java.io.IOException;

import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.util.Storable;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public abstract class AbstractLocator
				implements Locator, Storable, Cloneable {

	protected AbstractLocator() {
	}

	public Object clone() {
		try {
			return super.clone();
		} catch (CloneNotSupportedException e) {
	        throw new InternalError();
		}
	}

	public void write(StorableOutput dw) {
	}

	public void read(StorableInput dr) throws IOException {
	}
}


```

File: CH.ifa.draw.standard.StandardDrawingView
```java

package CH.ifa.draw.standard;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Panel;
import java.awt.Point;
import java.awt.PrintGraphics;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingChangeEvent;
import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.framework.FigureSelection;
import CH.ifa.draw.framework.Handle;
import CH.ifa.draw.framework.Painter;
import CH.ifa.draw.framework.PointConstrainer;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.util.Command;
import CH.ifa.draw.util.Geom;


public  class StandardDrawingView
		extends Panel
		implements DrawingView,
				   MouseListener,
				   MouseMotionListener,
				   KeyListener {

	transient private DrawingEditor   fEditor;

	private Drawing         fDrawing;

	private transient Rectangle fDamage = null;

	transient private Vector fSelection;

	transient private Vector fSelectionHandles;

	private Dimension fViewSize;

	private Point fLastClick;

	private Vector fBackgrounds = null;

	private Vector fForegrounds = null;

	private Painter fUpdateStrategy;

	private PointConstrainer fConstrainer;

	private static final long serialVersionUID = -3878153366174603336L;
	private int drawingViewSerializedDataVersion = 1;

	public StandardDrawingView(DrawingEditor editor, int width, int height) {
		fEditor = editor;
		fViewSize = new Dimension(width,height);
		fLastClick = new Point(0, 0);
		fConstrainer = null;
		fSelection = new Vector();
		setDisplayUpdate(new BufferedUpdateStrategy());
		setBackground(Color.lightGray);

		addMouseListener(this);
		addMouseMotionListener(this);
		addKeyListener(this);
	}

	public void setEditor(DrawingEditor editor) {
		fEditor = editor;
	}

	public Tool tool() {
		return fEditor.tool();
	}

	public Drawing drawing() {
		return fDrawing;
	}

	public void setDrawing(Drawing d) {
		clearSelection();

		if (fDrawing != null)
			fDrawing.removeDrawingChangeListener(this);

		fDrawing = d;
		if (fDrawing != null)
			fDrawing.addDrawingChangeListener(this);
		checkMinimumSize();
		repaint();
	}

	public DrawingEditor editor() {
		return fEditor;
	}

	public Figure add(Figure figure) {
		return drawing().add(figure);
	}

	public Figure remove(Figure figure) {
		return drawing().remove(figure);
	}

	public void addAll(Vector figures) {
		FigureEnumeration k = new FigureEnumerator(figures);
		while (k.hasMoreElements())
			add(k.nextFigure());
	}

	public Dimension getMinimumSize() {
		return fViewSize;
	}

	public Dimension getPreferredSize() {
		return getMinimumSize();
	}

	public void setDisplayUpdate(Painter updateStrategy) {
		fUpdateStrategy = updateStrategy;
	}

	public Vector selection() {
		return (Vector)fSelection.clone();
	}

	public FigureEnumeration selectionElements() {
		return new FigureEnumerator(fSelection);
	}

	public Vector selectionZOrdered() {
		Vector result = new Vector(fSelection.size());
		FigureEnumeration figures = drawing().figures();

		while (figures.hasMoreElements()) {
			Figure f= figures.nextFigure();
			if (fSelection.contains(f)) {
				result.addElement(f);
			}
		}
		return result;
	}

	public int selectionCount() {
		return fSelection.size();
	}

	public void addToSelection(Figure figure) {
		if (!fSelection.contains(figure)) {
			fSelection.addElement(figure);
			fSelectionHandles = null;
			figure.invalidate();
			selectionChanged();
		}
	}

	public void addToSelectionAll(Vector figures) {
		FigureEnumeration k = new FigureEnumerator(figures);
		while (k.hasMoreElements())
			addToSelection(k.nextFigure());
	}

	public void removeFromSelection(Figure figure) {
		if (fSelection.contains(figure)) {
			fSelection.removeElement(figure);
			fSelectionHandles = null;
			figure.invalidate();
			selectionChanged();
		}
	}

	public void toggleSelection(Figure figure) {
		if (fSelection.contains(figure))
			removeFromSelection(figure);
		else
			addToSelection(figure);
		selectionChanged();
	}

	public void clearSelection() {
		Figure figure;

		FigureEnumeration k = selectionElements();

		while (k.hasMoreElements())
			k.nextFigure().invalidate();
		fSelection = new Vector();
		fSelectionHandles = null;
		selectionChanged();
	}

	private Enumeration selectionHandles() {
		if (fSelectionHandles == null) {
			fSelectionHandles = new Vector();
			FigureEnumeration k = selectionElements();
			while (k.hasMoreElements()) {
				Figure figure = k.nextFigure();
				Enumeration kk = figure.handles().elements();
				while (kk.hasMoreElements())
					fSelectionHandles.addElement(kk.nextElement());
			}
		}
		return fSelectionHandles.elements();
	}

	public FigureSelection getFigureSelection() {
		return new FigureSelection(selectionZOrdered());
	}

	public Handle findHandle(int x, int y) {
		Handle handle;

		Enumeration k = selectionHandles();
		while (k.hasMoreElements()) {
			handle = (Handle) k.nextElement();
			if (handle.containsPoint(x, y))
				return handle;
		}
		return null;
	}

	protected void selectionChanged() {
		fEditor.selectionChanged(this);
	}

	public Point lastClick() {
		return fLastClick;
	}

	public void setConstrainer(PointConstrainer c) {
		fConstrainer = c;
	}

	public PointConstrainer getConstrainer() {
		return fConstrainer;
	}

	protected Point constrainPoint(Point p) {
		Dimension size = getSize();
		p.x = Geom.range(1, size.width, p.x);
		p.y = Geom.range(1, size.height, p.y);

		if (fConstrainer != null )
			return fConstrainer.constrainPoint(p);
		return p;
	}

	public void mousePressed(MouseEvent e) {
		requestFocus(); // JDK1.1
		Point p = constrainPoint(new Point(e.getX(), e.getY()));
		fLastClick = new Point(e.getX(), e.getY());
		tool().mouseDown(e, p.x, p.y);
		checkDamage();
	}

	public void mouseDragged(MouseEvent e) {
		Point p = constrainPoint(new Point(e.getX(), e.getY()));
		tool().mouseDrag(e, p.x, p.y);
		checkDamage();
	}

	public void mouseMoved(MouseEvent e) {
		tool().mouseMove(e, e.getX(), e.getY());
	}

	public void mouseReleased(MouseEvent e) {
		Point p = constrainPoint(new Point(e.getX(), e.getY()));
		tool().mouseUp(e, p.x, p.y);
		checkDamage();
	}

	public void keyPressed(KeyEvent e) {
		int code = e.getKeyCode();
		if ((code == KeyEvent.VK_BACK_SPACE) || (code == KeyEvent.VK_DELETE)) {
			Command cmd = new DeleteCommand("Delete", this);
			cmd.execute();
		} else if (code == KeyEvent.VK_DOWN || code == KeyEvent.VK_UP ||
			code == KeyEvent.VK_RIGHT || code == KeyEvent.VK_LEFT) {
			handleCursorKey(code);
		} else {
			tool().keyDown(e, code);
		}
		checkDamage();
	}

	protected void handleCursorKey(int key) {
		int dx = 0, dy = 0;
		int stepX = 1, stepY = 1;
		if (fConstrainer != null) {
			stepX = fConstrainer.getStepX();
			stepY = fConstrainer.getStepY();
		}

		switch (key) {
		case KeyEvent.VK_DOWN:
			dy = stepY;
			break;
		case KeyEvent.VK_UP:
			dy = -stepY;
			break;
		case KeyEvent.VK_RIGHT:
			dx = stepX;
			break;
		case KeyEvent.VK_LEFT:
			dx = -stepX;
			break;
		}
		moveSelection(dx, dy);
	}


	private void moveSelection(int dx, int dy) {
		FigureEnumeration figures = selectionElements();
		while (figures.hasMoreElements())
			figures.nextFigure().moveBy(dx, dy);
		checkDamage();
	}

	public synchronized void checkDamage() {
		Enumeration each = drawing().drawingChangeListeners();
		while (each.hasMoreElements()) {
			Object l = each.nextElement();
			if (l instanceof DrawingView) {
				((DrawingView)l).repairDamage();
			}
		}
	}

	public void repairDamage() {
		if (fDamage != null) {
			repaint(fDamage.x, fDamage.y, fDamage.width, fDamage.height);
			fDamage = null;
		}
	}

	public void drawingInvalidated(DrawingChangeEvent e) {
		Rectangle r = e.getInvalidatedRectangle();
		if (fDamage == null)
			fDamage = r;
		else
			fDamage.add(r);
	}

	public void drawingRequestUpdate(DrawingChangeEvent e) {
		repairDamage();
	}

	public void update(Graphics g) {
		paint(g);
	}

	public void paint(Graphics g) {
		fUpdateStrategy.draw(g, this);
	}

	public void drawAll(Graphics g) {
		boolean isPrinting = g instanceof PrintGraphics;
		drawBackground(g);
		if (fBackgrounds != null && !isPrinting)
			drawPainters(g, fBackgrounds);
		drawDrawing(g);
		if (fForegrounds != null && !isPrinting)
			drawPainters(g, fForegrounds);
		if (!isPrinting)
			drawHandles(g);
	}

	public void drawHandles(Graphics g) {
		Enumeration k = selectionHandles();
		while (k.hasMoreElements())
			((Handle) k.nextElement()).draw(g);
	}

	public void drawDrawing(Graphics g) {
		fDrawing.draw(g);
	}

	public void drawBackground(Graphics g) {
		g.setColor(getBackground());
		g.fillRect(0, 0, getBounds().width, getBounds().height);
	}

	private void drawPainters(Graphics g, Vector v) {
		for (int i = 0; i < v.size(); i++)
			((Painter)v.elementAt(i)).draw(g, this);
	}

	public void addBackground(Painter painter)  {
		if (fBackgrounds == null)
			fBackgrounds = new Vector(3);
		fBackgrounds.addElement(painter);
		repaint();
	}

	public void removeBackground(Painter painter)  {
		if (fBackgrounds != null)
			fBackgrounds.removeElement(painter);
		repaint();
	}

	public void removeForeground(Painter painter)  {
		if (fForegrounds != null)
			fForegrounds.removeElement(painter);
		repaint();
	}

	public void addForeground(Painter painter)  {
		if (fForegrounds == null)
			fForegrounds = new Vector(3);
		fForegrounds.addElement(painter);
		repaint();
	}

	public void freezeView() {
		drawing().lock();
	}

	public void unfreezeView() {
		drawing().unlock();
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		fSelection = new Vector(); // could use lazy initialization instead
		if (fDrawing != null)
			fDrawing.addDrawingChangeListener(this);
	}

	private void checkMinimumSize() {
		FigureEnumeration k = drawing().figures();
		Dimension d = new Dimension(0, 0);
		while (k.hasMoreElements()) {
			Rectangle r = k.nextFigure().displayBox();
			d.width = Math.max(d.width, r.x+r.width);
			d.height = Math.max(d.height, r.y+r.height);
		}
		if (fViewSize.height < d.height || fViewSize.width < d.width) {
			fViewSize.height = d.height+10;
			fViewSize.width = d.width+10;
			setSize(fViewSize);
		}
	}

	public boolean isFocusTraversable() {
		return true;
	}

	public void mouseEntered(MouseEvent e) {}
	public void mouseExited(MouseEvent e) {}
	public void mouseClicked(MouseEvent e) {}
	public void keyTyped(KeyEvent e) {}
	public void keyReleased(KeyEvent e) {}
}
```

File: CH.ifa.draw.standard.SimpleUpdateStrategy
```java

package CH.ifa.draw.standard;

import java.awt.Graphics;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Painter;

public  class SimpleUpdateStrategy implements Painter {

	private static final long serialVersionUID = -7539925820692134566L;

	public void draw(Graphics g, DrawingView view) {
		view.drawAll(g);
	}
}
```

File: CH.ifa.draw.standard.BringToFrontCommand
```java

package CH.ifa.draw.standard;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.Command;

public class BringToFrontCommand
	   extends Command {

	private DrawingView fView;

	public BringToFrontCommand(String name, DrawingView view) {
		super(name);
		fView = view;
	}

	public void execute() {
	   FigureEnumeration k = new FigureEnumerator(fView.selectionZOrdered());
	   while (k.hasMoreElements()) {
			fView.drawing().bringToFront(k.nextFigure());
		}
		fView.checkDamage();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}
}


```

File: CH.ifa.draw.standard.FigureEnumerator
```java

package CH.ifa.draw.standard;

import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;

public final class FigureEnumerator implements FigureEnumeration {
	Enumeration fEnumeration;

	public FigureEnumerator(Vector v) {
	    fEnumeration = v.elements();
	}

	public boolean hasMoreElements() {
	    return fEnumeration.hasMoreElements();
	}

	public Object nextElement() {
		return fEnumeration.nextElement();
	}

	public Figure nextFigure() {
		return (Figure)fEnumeration.nextElement();
	}
}
```

File: CH.ifa.draw.standard.EastHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

class EastHandle extends LocatorHandle {
	EastHandle(Figure owner) {
		super(owner, RelativeLocator.east());
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Rectangle r = owner().displayBox();
		owner().displayBox(
			new Point(r.x, r.y), new Point(Math.max(r.x, x), r.y + r.height)
		);
	}
}

```

File: CH.ifa.draw.standard.NullHandle
```java

package CH.ifa.draw.standard;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;

public class NullHandle extends LocatorHandle {

	protected Locator fLocator;

	public NullHandle(Figure owner, Locator locator) {
		super(owner, locator);
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();

		g.setColor(Color.black);
		g.drawRect(r.x, r.y, r.width, r.height);
	}
}
```

File: CH.ifa.draw.standard.NorthWestHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

class NorthWestHandle extends LocatorHandle {
	NorthWestHandle(Figure owner) {
		super(owner, RelativeLocator.northWest());
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Rectangle r = owner().displayBox();
		owner().displayBox(
			new Point(Math.min(r.x + r.width, x), Math.min(r.y + r.height, y)),
			new Point(r.x + r.width, r.y + r.height)
		);
	}
}

```

File: CH.ifa.draw.standard.DecoratorFigure
```java

package CH.ifa.draw.standard;

import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Vector;

import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.framework.FigureChangeListener;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public abstract class DecoratorFigure
				extends AbstractFigure
				implements FigureChangeListener {

	protected Figure fComponent;

	private static final long serialVersionUID = 8993011151564573288L;
	private int decoratorFigureSerializedDataVersion = 1;

	public DecoratorFigure() { }

	public DecoratorFigure(Figure figure) {
		decorate(figure);
	}

	public Insets connectionInsets() {
		return fComponent.connectionInsets();
	}

	public boolean canConnect() {
		return fComponent.canConnect();
	}

	public boolean containsPoint(int x, int y) {
		return fComponent.containsPoint(x, y);
	}

	public void decorate(Figure figure) {
		fComponent = figure;
		fComponent.addToContainer(this);
	}

	public Figure peelDecoration() {
		fComponent.removeFromContainer(this); //??? set the container to the listener()?
		return fComponent;
	}

	public Rectangle displayBox() {
		return fComponent.displayBox();
	}

	public void basicDisplayBox(Point origin, Point corner) {
		fComponent.basicDisplayBox(origin, corner);
	}

	public void draw(Graphics g) {
		fComponent.draw(g);
	}

	public Figure findFigureInside(int x, int y) {
		return fComponent.findFigureInside(x, y);
	}

	public Vector handles() {
		return fComponent.handles();
	}

	public boolean includes(Figure figure) {
		return (super.includes(figure) || fComponent.includes(figure));
	}

	public void moveBy(int x, int y) {
		fComponent.moveBy(x, y);
	}

	protected void basicMoveBy(int x, int y) {
	}

	public void release() {
		super.release();
		fComponent.removeFromContainer(this);
		fComponent.release();
	}

	public void figureInvalidated(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureInvalidated(e);
	}

	public void figureChanged(FigureChangeEvent e) {
	}

	public void figureRemoved(FigureChangeEvent e) {
	}

	public  void figureRequestUpdate(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestUpdate(e);
	}

	public void figureRequestRemove(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestRemove(new FigureChangeEvent(this));
	}

	public FigureEnumeration figures() {
		return fComponent.figures();
	}

	public FigureEnumeration decompose() {
		return fComponent.decompose();
	}

	public void setAttribute(String name, Object value) {
		fComponent.setAttribute(name, value);
	}

	public Object getAttribute(String name) {
		return fComponent.getAttribute(name);
	}

	public Locator connectedTextLocator(Figure text) {
		return fComponent.connectedTextLocator(text);
	}

	public Connector connectorAt(int x, int y) {
		return fComponent.connectorAt(x, y);
	}

	public void connectorVisibility(boolean isVisible) {
		fComponent.connectorVisibility(isVisible);
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeStorable(fComponent);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		decorate((Figure)dr.readStorable());
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		fComponent.addToContainer(this);
	}
}
```

File: CH.ifa.draw.standard.CutCommand
```java

package CH.ifa.draw.standard;

import CH.ifa.draw.framework.DrawingView;

public class CutCommand extends FigureTransferCommand {

	public CutCommand(String name, DrawingView view) {
		super(name, view);
	}

	public void execute() {
		copySelection();
		deleteSelection();
		fView.checkDamage();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}

}


```

File: CH.ifa.draw.standard.CreationTool
```java

package CH.ifa.draw.standard;

import java.awt.Cursor;
import java.awt.Point;
import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.HJDError;



public class CreationTool extends AbstractTool {

	private Point   fAnchorPoint;

	private Figure  fCreatedFigure;

	private Figure  fPrototype;


	public CreationTool(DrawingView view, Figure prototype) {
		super(view);
		fPrototype = prototype;
	}

	protected CreationTool(DrawingView view) {
		super(view);
		fPrototype = null;
	}

	public void activate() {
		view().setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		fAnchorPoint = new Point(x,y);
		fCreatedFigure = createFigure();
		fCreatedFigure.displayBox(fAnchorPoint, fAnchorPoint);
		view().add(fCreatedFigure);
	}

	protected Figure createFigure() {
		if (fPrototype == null)
		    throw new HJDError("No protoype defined");
		return (Figure) fPrototype.clone();
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
		fCreatedFigure.displayBox(fAnchorPoint, new Point(x,y));
	}

	public void mouseUp(MouseEvent e, int x, int y) {
		if (fCreatedFigure.isEmpty())
			drawing().remove(fCreatedFigure);
		fCreatedFigure = null;
		editor().toolDone();
	}

	protected Figure createdFigure() {
		return fCreatedFigure;
	}
}
```

File: CH.ifa.draw.standard.SouthWestHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

class SouthWestHandle extends LocatorHandle {
	SouthWestHandle(Figure owner) {
		super(owner, RelativeLocator.southWest());
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Rectangle r = owner().displayBox();
		owner().displayBox(
			new Point(Math.min(r.x + r.width, x), r.y),
			new Point(r.x + r.width, Math.max(r.y, y))
		);
	}
}

```

File: CH.ifa.draw.standard.ChangeConnectionEndHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;

import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Figure;


public class ChangeConnectionEndHandle extends ChangeConnectionHandle {

	public ChangeConnectionEndHandle(Figure owner) {
		super(owner);
	}

	protected Connector target() {
		return fConnection.end();
	}

	protected void disconnect() {
		fConnection.disconnectEnd();
	}

	protected void connect(Connector c) {
		fConnection.connectEnd(c);
	}

	protected void setPoint(int x, int y) {
		fConnection.endPoint(x, y);
	}

	public Point locate() {
		return fConnection.endPoint();
	}
}

```

File: CH.ifa.draw.standard.ToggleGridCommand
```java

package CH.ifa.draw.standard;

import java.awt.Point;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.PointConstrainer;
import CH.ifa.draw.util.Command;

public class ToggleGridCommand extends Command {

	private DrawingView fView;
	private Point fGrid;

	public ToggleGridCommand(String name, DrawingView view, Point grid) {
		super(name);
		fView = view;
		fGrid = new Point(grid.x, grid.y);
	}

	public void execute() {
		PointConstrainer grid = fView.getConstrainer();
		if (grid != null) {
			fView.setConstrainer(null);
		}
		else {
			fView.setConstrainer(new GridConstrainer(fGrid.x, fGrid.y));
		}
	}
}


```

File: CH.ifa.draw.standard.AbstractFigure
```java

package CH.ifa.draw.standard;

import CH.ifa.draw.util.*;
import CH.ifa.draw.framework.*;

import java.awt.*;
import java.util.*;
import java.io.*;


public abstract class AbstractFigure implements Figure {

	private transient FigureChangeListener fListener;

	private static final long serialVersionUID = -10857585979273442L;
	private int abstractFigureSerializedDataVersion = 1;

	protected AbstractFigure() { }

	public void moveBy(int dx, int dy) {
		willChange();
		basicMoveBy(dx, dy);
		changed();
	}

	protected abstract void basicMoveBy(int dx, int dy);

	public void displayBox(Point origin, Point corner) {
		willChange();
		basicDisplayBox(origin, corner);
		changed();
	}

	public abstract void basicDisplayBox(Point origin, Point corner);

	public abstract Rectangle displayBox();

	public abstract Vector handles();

	public FigureEnumeration figures() {
		Vector figures = new Vector(1);
		figures.addElement(this);
		return new FigureEnumerator(figures);
	}

	public Dimension size() {
		return new Dimension(displayBox().width, displayBox().height);
	}

	public boolean isEmpty() {
		return (size().width < 3) || (size().height < 3);
	}

	public Figure findFigureInside(int x, int y) {
		if (containsPoint(x, y))
			return this;
		return null;
	}

	public boolean containsPoint(int x, int y) {
		return displayBox().contains(x, y);
	}

	public void displayBox(Rectangle r) {
		displayBox(new Point(r.x, r.y), new Point(r.x+r.width, r.y+r.height));
	}

	public boolean includes(Figure figure) {
		return figure == this;
	}

	public FigureEnumeration decompose() {
		Vector figures = new Vector(1);
		figures.addElement(this);
		return new FigureEnumerator(figures);
	}

	public void addToContainer(FigureChangeListener c) {
		addFigureChangeListener(c);
		invalidate();
	}

	public void removeFromContainer(FigureChangeListener c) {
		invalidate();
		removeFigureChangeListener(c);
		changed();
	}

	public void addFigureChangeListener(FigureChangeListener l) {
		fListener = FigureChangeEventMulticaster.add(fListener, l);
	}

	public void removeFigureChangeListener(FigureChangeListener l) {
		fListener = FigureChangeEventMulticaster.remove(fListener, l);
	}

	public FigureChangeListener listener() {
		return fListener;
	}

	public void release() {
		if (fListener != null)
			fListener.figureRemoved(new FigureChangeEvent(this));
	}

	public void invalidate() {
		if (fListener != null) {
			Rectangle r = displayBox();
			r.grow(Handle.HANDLESIZE, Handle.HANDLESIZE);
			fListener.figureInvalidated(new FigureChangeEvent(this, r));
		}
	}

	public void willChange() {
		invalidate();
	}

	public void changed() {
		invalidate();
		if (fListener != null)
			fListener.figureChanged(new FigureChangeEvent(this));

	}

	public Point center() {
		return Geom.center(displayBox());
	}

	public boolean canConnect() {
		return true;
	}

	public Insets connectionInsets() {
		return new Insets(0, 0, 0, 0);
	}

	public Connector connectorAt(int x, int y) {
		return new ChopBoxConnector(this);
	}

	public void connectorVisibility(boolean isVisible) {
	}

	public Locator connectedTextLocator(Figure text) {
		return RelativeLocator.center();
	}

	public Object getAttribute(String name) {
		return null;
	}

	public void setAttribute(String name, Object value) {
	}

	public Object clone() {
		Object clone = null;
		ByteArrayOutputStream output = new ByteArrayOutputStream(200);
		try {
			ObjectOutput writer = new ObjectOutputStream(output);
			writer.writeObject(this);
			writer.close();
		} catch (IOException e) {
			System.out.println("Class not found: " + e);
		}

		InputStream input = new ByteArrayInputStream(output.toByteArray());
		try {
			ObjectInput reader = new ObjectInputStream(input);
			clone = (Object) reader.readObject();
		} catch (IOException e) {
			System.out.println(e.toString());
		}
		catch (ClassNotFoundException e) {
			System.out.println("Class not found: " + e);
		}
		return clone;
	}

	public void write(StorableOutput dw) {
	}

	public void read(StorableInput dr) throws IOException {
	}

}
```

File: CH.ifa.draw.standard.HandleTracker
```java

package CH.ifa.draw.standard;

import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Handle;

public class HandleTracker extends AbstractTool {

	private Handle  fAnchorHandle;

	public HandleTracker(DrawingView view, Handle anchorHandle) {
		super(view);
		fAnchorHandle = anchorHandle;
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		super.mouseDown(e, x, y);
		fAnchorHandle.invokeStart(x, y, view());
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
		super.mouseDrag(e, x, y);
		fAnchorHandle.invokeStep(x, y, fAnchorX, fAnchorY, view());
	}

	public void mouseUp(MouseEvent e, int x, int y) {
		super.mouseDrag(e, x, y);
		fAnchorHandle.invokeEnd(x, y, fAnchorX, fAnchorY, view());
	}
}
```

File: CH.ifa.draw.standard.ChangeAttributeCommand
```java

package CH.ifa.draw.standard;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.Command;

public  class ChangeAttributeCommand
		extends Command {

	private DrawingView fView;
	private String      fAttribute;
	private Object      fValue;

	public ChangeAttributeCommand(String name, String attributeName,
						   Object value, DrawingView view) {
		super(name);
		fAttribute = attributeName;
		fValue = value;
		fView = view;
	}

	public void execute() {
		FigureEnumeration k = fView.selectionElements();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();
			f.setAttribute(fAttribute, fValue);
		}
		fView.checkDamage();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}

}


```

File: CH.ifa.draw.standard.AlignCommand
```java

package CH.ifa.draw.standard;

import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.Command;

public class AlignCommand extends Command {

	private DrawingView fView;
	private int fOp;

	public final static int LEFTS = 0;
	public final static int CENTERS = 1;
	public final static int RIGHTS = 2;
	public final static int TOPS = 3;
	public final static int MIDDLES = 4;
	public final static int BOTTOMS = 5;


	public AlignCommand(String name, DrawingView view, int op) {
		super(name);
		fView = view;
		fOp = op;
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 1;
	}

	public void execute() {
		FigureEnumeration selection = fView.selectionElements();
		Figure anchorFigure = selection.nextFigure();
		Rectangle r = anchorFigure.displayBox();

		while (selection.hasMoreElements()) {
			Figure f = selection.nextFigure();
			Rectangle rr = f.displayBox();
			switch (fOp) {
			case LEFTS:
				f.moveBy(r.x-rr.x, 0);
				break;
			case CENTERS:
				f.moveBy((r.x+r.width/2) - (rr.x+rr.width/2), 0);
				break;
			case RIGHTS:
				f.moveBy((r.x+r.width) - (rr.x+rr.width), 0);
				break;
			case TOPS:
				f.moveBy(0, r.y-rr.y);
				break;
			case MIDDLES:
				f.moveBy(0, (r.y+r.height/2) - (rr.y+rr.height/2));
				break;
			case BOTTOMS:
				f.moveBy(0, (r.y+r.height) - (rr.y+rr.height));
				break;
			}
		}
		fView.checkDamage();
	}
}


```

File: CH.ifa.draw.standard.GridConstrainer
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.io.Serializable;

import CH.ifa.draw.framework.PointConstrainer;



public class GridConstrainer implements PointConstrainer, Serializable {

	private int fGridX;
	private int fGridY;

	public GridConstrainer(int x, int y) {
		fGridX = Math.max(1, x);
		fGridY = Math.max(1, y);
	}

	public Point constrainPoint(Point p) {
		p.x = ((p.x+fGridX/2) / fGridX) * fGridX;
		p.y = ((p.y+fGridY/2) / fGridY) * fGridY;
		return p;
	}

	public int getStepX() {
		return fGridX;
	}

	public int getStepY() {
		return fGridY;
	}
}
```

File: CH.ifa.draw.standard.SelectionTool
```java

package CH.ifa.draw.standard;

import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Handle;
import CH.ifa.draw.framework.Tool;


public class SelectionTool extends AbstractTool {

	private Tool fChild = null;

	public SelectionTool(DrawingView view) {
		super(view);
	}

	public void mouseDown(MouseEvent e, int x, int y)
	{
		if (fChild != null)
			return;

		view().freezeView();

		Handle handle = view().findHandle(e.getX(), e.getY());
		if (handle != null) {
			fChild = createHandleTracker(view(), handle);
		}
		else {
			Figure figure = drawing().findFigure(e.getX(), e.getY());
			if (figure != null) {
				fChild = createDragTracker(view(), figure);
			}
			else {
				if (!e.isShiftDown()) {
					view().clearSelection();
				}
				fChild = createAreaTracker(view());
			}
		}
		fChild.mouseDown(e, x, y);
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
		if (fChild != null) // JDK1.1 doesn't guarantee mouseDown, mouseDrag, mouseUp
			fChild.mouseDrag(e, x, y);
	}

	public void mouseUp(MouseEvent e, int x, int y) {
		view().unfreezeView();
		if (fChild != null) // JDK1.1 doesn't guarantee mouseDown, mouseDrag, mouseUp
			fChild.mouseUp(e, x, y);
		fChild = null;
	}

	protected Tool createHandleTracker(DrawingView view, Handle handle) {
		return new HandleTracker(view, handle);
	}

	protected Tool createDragTracker(DrawingView view, Figure f) {
		return new DragTracker(view, f);
	}

	protected Tool createAreaTracker(DrawingView view) {
		return new SelectAreaTracker(view);
	}
}
```

File: CH.ifa.draw.standard.BufferedUpdateStrategy
```java

package CH.ifa.draw.standard;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Painter;


public  class BufferedUpdateStrategy
		implements Painter {

	transient private Image   fOffscreen;
	private int     fImagewidth = -1;
	private int     fImageheight = -1;

	private static final long serialVersionUID = 6489532222954612824L;
	private int bufferedUpdateSerializedDataVersion = 1;

	public void draw(Graphics g, DrawingView view) {
		Dimension d = view.getSize();
		if ((fOffscreen == null) || (d.width != fImagewidth)
			|| (d.height != fImageheight)) {
			fOffscreen = view.createImage(d.width, d.height);
			fImagewidth = d.width;
			fImageheight = d.height;
		}

		Graphics g2 = fOffscreen.getGraphics();
		view.drawAll(g2);

		g.drawImage(fOffscreen, 0, 0, view);
	}
}
```

File: CH.ifa.draw.standard.LocatorHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;


public class LocatorHandle extends AbstractHandle {

	private Locator       fLocator;

	public LocatorHandle(Figure owner, Locator l) {
		super(owner);
		fLocator = l;
	}

	public Point locate() {
		return fLocator.locate(owner());
	}
}
```

File: CH.ifa.draw.standard.ConnectionHandle
```java

package CH.ifa.draw.standard;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.util.Geom;


public  class ConnectionHandle extends LocatorHandle {

	private ConnectionFigure fConnection;

	private ConnectionFigure fPrototype;

	private Figure fTarget = null;

	public ConnectionHandle(Figure owner, Locator l, ConnectionFigure prototype) {
		super(owner, l);
		fPrototype = prototype;
	}

	public void invokeStart(int  x, int  y, DrawingView view) {
		fConnection = createConnection();
		Point p = locate();
		fConnection.startPoint(p.x, p.y);
		fConnection.endPoint(p.x, p.y);
		view.drawing().add(fConnection);
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Point p = new Point(x,y);
		Figure f = findConnectableFigure(x, y, view.drawing());
		if (f != fTarget) {
			if (fTarget != null)
				fTarget.connectorVisibility(false);
			fTarget = f;
			if (fTarget != null)
				fTarget.connectorVisibility(true);
		}

		Connector target = findConnectionTarget(p.x, p.y, view.drawing());
		if (target != null)
			p = Geom.center(target.displayBox());
		fConnection.endPoint(p.x, p.y);
	}

	public void invokeEnd(int x, int y, int anchorX, int anchorY, DrawingView view) {
		Connector target = findConnectionTarget(x, y, view.drawing());
		if (target != null) {
			fConnection.connectStart(startConnector());
			fConnection.connectEnd(target);
			fConnection.updateConnection();
		} else
			view.drawing().remove(fConnection);
		fConnection = null;
		if (fTarget != null) {
			fTarget.connectorVisibility(false);
			fTarget = null;
		}
	}

	private Connector startConnector() {
		Point p = locate();
		return owner().connectorAt(p.x, p.y);
	}

	protected ConnectionFigure createConnection() {
		return (ConnectionFigure)fPrototype.clone();
	}

	protected Connector findConnectionTarget(int x, int y, Drawing drawing) {
		Figure target = findConnectableFigure(x, y, drawing);
		if ((target != null) && target.canConnect()
			 && !target.includes(owner())
			 && fConnection.canConnect(owner(), target)) {
				return findConnector(x, y, target);
		}
		return null;
	}

	private Figure findConnectableFigure(int x, int y, Drawing drawing) {
		FigureEnumeration k = drawing.figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (!figure.includes(fConnection) && figure.canConnect()) {
				if (figure.containsPoint(x, y))
					return figure;
			}
		}
		return null;
	}

	protected Connector findConnector(int x, int y, Figure f) {
		return f.connectorAt(x, y);
	}


	public void draw(Graphics g) {
		Rectangle r = displayBox();
		g.setColor(Color.blue);
		g.drawOval(r.x, r.y, r.width, r.height);
	}

}
```

File: CH.ifa.draw.standard.PasteCommand
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureSelection;
import CH.ifa.draw.util.Clipboard;

public class PasteCommand extends FigureTransferCommand {

	public PasteCommand(String name, DrawingView view) {
		super(name, view);
	}

	public void execute() {
		Point lastClick = fView.lastClick();
		FigureSelection selection = (FigureSelection)Clipboard.getClipboard().getContents();
		if (selection != null) {
			Vector figures = (Vector)selection.getData(FigureSelection.TYPE);
			if (figures.size() == 0)
				return;

			Rectangle r = bounds(figures.elements());
			fView.clearSelection();

			insertFigures(figures, lastClick.x-r.x, lastClick.y-r.y);
			fView.checkDamage();
		}
	}

	Rectangle bounds(Enumeration k) {
		Rectangle r = ((Figure) k.nextElement()).displayBox();
		while (k.hasMoreElements())
			r.add(((Figure) k.nextElement()).displayBox());
		return r;
	}
}


```

File: CH.ifa.draw.standard.CopyCommand
```java

package CH.ifa.draw.standard;

import CH.ifa.draw.framework.DrawingView;

public class CopyCommand extends FigureTransferCommand {

	public CopyCommand(String name, DrawingView view) {
		super(name, view);
	}

	public void execute() {
		copySelection();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}

}


```

File: CH.ifa.draw.standard.ToolButton
```java

package CH.ifa.draw.standard;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.MediaTracker;

import CH.ifa.draw.framework.HJDError;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.util.Iconkit;
import CH.ifa.draw.util.PaletteButton;
import CH.ifa.draw.util.PaletteIcon;
import CH.ifa.draw.util.PaletteListener;

public class ToolButton extends PaletteButton {

	private String          fName;
	private Tool            fTool;
	private PaletteIcon     fIcon;

	public ToolButton(PaletteListener listener, String iconName, String name, Tool tool) {
		super(listener);
		Iconkit kit = Iconkit.instance();
		if (kit == null)
			throw new HJDError("Iconkit instance isn't set");

		Image im[] = new Image[3];
		im[0] = kit.loadImageResource(iconName+"1.gif");
		im[1] = kit.loadImageResource(iconName+"2.gif");
		im[2] = kit.loadImageResource(iconName+"3.gif");

		MediaTracker tracker = new MediaTracker(this);
		for (int i = 0; i < 3; i++) {
			tracker.addImage(im[i], i);
		}
		try {
			tracker.waitForAll();
		} catch (Exception e) {  }

		fIcon = new PaletteIcon(new Dimension(24,24), im[0], im[1], im[2]);
		fTool = tool;
		fName = name;
	}

	public Tool tool() {
		return fTool;
	}

	public String name() {
		return fName;
	}

	public Object attributeValue() {
		return tool();
	}

	public Dimension getMinimumSize() {
		return new Dimension(fIcon.getWidth(), fIcon.getHeight());
	}

	public Dimension getPreferredSize() {
		return new Dimension(fIcon.getWidth(), fIcon.getHeight());
	}

	public void paintBackground(Graphics g) { }

	public void paintNormal(Graphics g) {
		if (fIcon.normal() != null)
			g.drawImage(fIcon.normal(), 0, 0, this);
	}

	public void paintPressed(Graphics g) {
		if (fIcon.pressed() != null)
			g.drawImage(fIcon.pressed(), 0, 0, this);
	}

	public void paintSelected(Graphics g) {
		if (fIcon.selected() != null)
			g.drawImage(fIcon.selected(), 0, 0, this);
	}

}

```

File: CH.ifa.draw.standard.ReverseFigureEnumerator
```java

package CH.ifa.draw.standard;

import java.util.Vector;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.ReverseVectorEnumerator;

public final class ReverseFigureEnumerator implements FigureEnumeration {
	ReverseVectorEnumerator fEnumeration;

	public ReverseFigureEnumerator(Vector v) {
	    fEnumeration = new ReverseVectorEnumerator(v);
	}

	public boolean hasMoreElements() {
	    return fEnumeration.hasMoreElements();
	}

	public Object nextElement() {
		return fEnumeration.nextElement();
	}

	public Figure nextFigure() {
		return (Figure)fEnumeration.nextElement();
	}
}
```

File: CH.ifa.draw.standard.DuplicateCommand
```java

package CH.ifa.draw.standard;

import java.util.Vector;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.FigureSelection;

public class DuplicateCommand extends FigureTransferCommand {

	public DuplicateCommand(String name, DrawingView view) {
		super(name, view);
	}

	public void execute() {
		FigureSelection selection = fView.getFigureSelection();

		fView.clearSelection();

		Vector figures = (Vector)selection.getData(FigureSelection.TYPE);
		insertFigures(figures, 10, 10);
		fView.checkDamage();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}

}


```

File: CH.ifa.draw.standard.ChangeConnectionStartHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;

import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Figure;


public class ChangeConnectionStartHandle extends ChangeConnectionHandle {

	public ChangeConnectionStartHandle(Figure owner) {
		super(owner);
	}

	protected Connector target() {
		return fConnection.start();
	}

	protected void disconnect() {
		fConnection.disconnectStart();
	}

	protected void connect(Connector c) {
		fConnection.connectStart(c);
	}

	protected void setPoint(int x, int y) {
		fConnection.startPoint(x, y);
	}

	public Point locate() {
		return fConnection.startPoint();
	}
}
```

File: CH.ifa.draw.standard.DragTracker
```java

package CH.ifa.draw.standard;

import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;

public class DragTracker extends AbstractTool {

	private Figure  fAnchorFigure;
	private int     fLastX, fLastY;      // previous mouse position
	private boolean fMoved = false;

	public DragTracker(DrawingView view, Figure anchor) {
		super(view);
		fAnchorFigure = anchor;
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		super.mouseDown(e, x, y);
		fLastX = x;
		fLastY = y;

		if (e.isShiftDown()) {
		   view().toggleSelection(fAnchorFigure);
		   fAnchorFigure = null;
		} else if (!view().selection().contains(fAnchorFigure)) {
			view().clearSelection();
			view().addToSelection(fAnchorFigure);
		}
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
		super.mouseDrag(e, x, y);
		fMoved = (Math.abs(x - fAnchorX) > 4) || (Math.abs(y - fAnchorY) > 4);

		if (fMoved) {
			FigureEnumeration figures = view().selectionElements();
			while (figures.hasMoreElements())
				figures.nextFigure().moveBy(x - fLastX, y - fLastY);
		}
		fLastX = x;
		fLastY = y;
	}
}
```

File: CH.ifa.draw.standard.SouthEastHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

class SouthEastHandle extends LocatorHandle {
	SouthEastHandle(Figure owner) {
		super(owner, RelativeLocator.southEast());
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Rectangle r = owner().displayBox();
		owner().displayBox(
			new Point(r.x, r.y),
			new Point(Math.max(r.x, x), Math.max(r.y, y))
		);
	}
}

```

File: CH.ifa.draw.standard.AbstractHandle
```java

package CH.ifa.draw.standard;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Handle;

public abstract class AbstractHandle implements Handle {

	public static final int HANDLESIZE = 8;
	private Figure fOwner;

	public AbstractHandle(Figure owner) {
		fOwner = owner;
	}

	public abstract Point locate();

	public void invokeStart(int  x, int  y, Drawing drawing) { }

	public void invokeStart(int  x, int  y, DrawingView view) {
		invokeStart(x, y, view.drawing());
	}

	public void invokeStep (int dx, int dy, Drawing drawing) { }

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		invokeStep(x-anchorX, y-anchorY, view.drawing());
	}

	public void invokeEnd(int x, int y, int anchorX, int anchorY, DrawingView view) {
		invokeEnd(x-anchorX, y-anchorY, view.drawing());
	}

	public void invokeEnd  (int dx, int dy, Drawing drawing) { }

	public Figure owner() {
		return fOwner;
	}

	public Rectangle displayBox() {
		Point p = locate();
		return new Rectangle(
				p.x - HANDLESIZE / 2,
				p.y - HANDLESIZE / 2,
				HANDLESIZE,
				HANDLESIZE);
	}

	public boolean containsPoint(int x, int y) {
		return displayBox().contains(x, y);
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();

		g.setColor(Color.white);
		g.fillRect(r.x, r.y, r.width, r.height);

		g.setColor(Color.black);
		g.drawRect(r.x, r.y, r.width, r.height);
	}
}


```

File: CH.ifa.draw.standard.LocatorConnector
```java

package CH.ifa.draw.standard;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;

import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public class LocatorConnector extends AbstractConnector {

	public static final int SIZE = 8;

	private Locator  fLocator;

	private static final long serialVersionUID = 5062833203337604181L;
	private int locatorConnectorSerializedDataVersion = 1;

	public LocatorConnector() { // only used for Storable
		fLocator = null;
	}

	public LocatorConnector(Figure owner, Locator l) {
		super(owner);
		fLocator = l;
	}

	protected Point locate(ConnectionFigure connection) {
		return fLocator.locate(owner());
	}

	public boolean containsPoint(int x, int y) {
		return displayBox().contains(x, y);
	}

	public Rectangle displayBox() {
		Point p = fLocator.locate(owner());
		return new Rectangle(
				p.x - SIZE / 2,
				p.y - SIZE / 2,
				SIZE,
				SIZE);
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();

		g.setColor(Color.blue);
		g.fillOval(r.x, r.y, r.width, r.height);
		g.setColor(Color.black);
		g.drawOval(r.x, r.y, r.width, r.height);
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeStorable(fLocator);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fLocator = (Locator)dr.readStorable();
	}

}

```

File: CH.ifa.draw.standard.CompositeFigure
```java

package CH.ifa.draw.standard;

import CH.ifa.draw.util.*;
import CH.ifa.draw.framework.*;
import java.awt.*;
import java.util.*;
import java.io.*;


public abstract class CompositeFigure
				extends AbstractFigure
				implements FigureChangeListener {

	protected Vector fFigures;

	private static final long serialVersionUID = 7408153435700021866L;
	private int compositeFigureSerializedDataVersion = 1;

	protected CompositeFigure() {
		fFigures = new Vector();
	}

	public Figure add(Figure figure) {
		if (!fFigures.contains(figure)) {
			fFigures.addElement(figure);
			figure.addToContainer(this);
		}
		return figure;
	}

	public void addAll(Vector newFigures) {
		Enumeration k = newFigures.elements();
		while (k.hasMoreElements())
			add((Figure) k.nextElement());
	}

	public Figure remove(Figure figure) {
		if (fFigures.contains(figure)) {
			figure.removeFromContainer(this);
			fFigures.removeElement(figure);
		}
		return figure;
	}

	public void removeAll(Vector figures) {
		Enumeration k = figures.elements();
		while (k.hasMoreElements())
			remove((Figure) k.nextElement());
	}

	public void removeAll() {
		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			figure.removeFromContainer(this);
		}
		fFigures.removeAllElements();
	}

	public synchronized Figure orphan(Figure figure) {
		fFigures.removeElement(figure);
		return figure;
	}

	public void orphanAll(Vector newFigures) {
		Enumeration k = newFigures.elements();
		while (k.hasMoreElements())
			orphan((Figure) k.nextElement());
	}

	public synchronized void replace(Figure figure, Figure replacement) {
		int index = fFigures.indexOf(figure);
		if (index != -1) {
			replacement.addToContainer(this);   // will invalidate figure
			figure.changed();
			fFigures.setElementAt(replacement, index);
		}
	}

	public synchronized void sendToBack(Figure figure) {
		if (fFigures.contains(figure)) {
			fFigures.removeElement(figure);
			fFigures.insertElementAt(figure,0);
			figure.changed();
		}
	}

	public synchronized void bringToFront(Figure figure) {
		if (fFigures.contains(figure)) {
			fFigures.removeElement(figure);
			fFigures.addElement(figure);
			figure.changed();
		}
	}

	public void draw(Graphics g) {
		FigureEnumeration k = figures();
		while (k.hasMoreElements())
			k.nextFigure().draw(g);
	}

	public Figure figureAt(int i) {
		return (Figure)fFigures.elementAt(i);
	}

	public final FigureEnumeration figures() {
		return new FigureEnumerator(fFigures);
	}

	public int figureCount() {
		return fFigures.size();
	}

	public final FigureEnumeration figuresReverse() {
		return new ReverseFigureEnumerator(fFigures);
	}

	public Figure findFigure(int x, int y) {
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (figure.containsPoint(x, y))
				return figure;
		}
		return null;
	}

	public Figure findFigure(Rectangle r) {
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			Rectangle fr = figure.displayBox();
			if (r.intersects(fr))
				return figure;
		}
		return null;
	}

	public Figure findFigureWithout(int x, int y, Figure without) {
		if (without == null)
			return findFigure(x, y);
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (figure.containsPoint(x, y) && !figure.includes(without))
				return figure;
		}
		return null;
	}

	public Figure findFigure(Rectangle r, Figure without) {
		if (without == null)
			return findFigure(r);
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			Rectangle fr = figure.displayBox();
			if (r.intersects(fr) && !figure.includes(without))
				return figure;
		}
		return null;
	}

	public Figure findFigureInside(int x, int y) {
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure().findFigureInside(x, y);
			if (figure != null)
				return figure;
		}
		return null;
	}

	public Figure findFigureInsideWithout(int x, int y, Figure without) {
		FigureEnumeration k = figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (figure != without) {
				Figure found = figure.findFigureInside(x, y);
				if (found != null)
					return found;
			}
		}
		return null;
	}

	public boolean includes(Figure figure) {
		if (super.includes(figure))
			return true;

		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();
			if (f.includes(figure))
				return true;
		}
		return false;
	}

	protected void basicMoveBy(int x, int y) {
		FigureEnumeration k = figures();
		while (k.hasMoreElements())
			k.nextFigure().moveBy(x,y);
	}

	public void release() {
		super.release();
		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			figure.release();
		}
	}

	public void figureInvalidated(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureInvalidated(e);
	}

	public void figureRequestRemove(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestRemove(new FigureChangeEvent(this));
	}

	public void figureRequestUpdate(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestUpdate(e);
	}

	public void figureChanged(FigureChangeEvent e) {
	}

	public void figureRemoved(FigureChangeEvent e) {
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fFigures.size());
		Enumeration k = fFigures.elements();
		while (k.hasMoreElements())
			dw.writeStorable((Storable) k.nextElement());
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		int size = dr.readInt();
		fFigures = new Vector(size);
		for (int i=0; i<size; i++)
			add((Figure)dr.readStorable());
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			figure.addToContainer(this);
		}
	}
}
```

File: CH.ifa.draw.standard.FigureChangeEventMulticaster
```java

package CH.ifa.draw.standard;

import java.awt.AWTEventMulticaster;
import java.util.EventListener;

import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.framework.FigureChangeListener;



public class FigureChangeEventMulticaster extends
	AWTEventMulticaster implements FigureChangeListener {

	public FigureChangeEventMulticaster(EventListener a, EventListener b) {
		super(a, b);
	}

	public void figureInvalidated(FigureChangeEvent e) {
		((FigureChangeListener)a).figureInvalidated(e);
		((FigureChangeListener)b).figureInvalidated(e);
	}

	public void figureRequestRemove(FigureChangeEvent e) {
		((FigureChangeListener)a).figureRequestRemove(e);
		((FigureChangeListener)b).figureRequestRemove(e);
	}

	public void figureRequestUpdate(FigureChangeEvent e) {
		((FigureChangeListener)a).figureRequestUpdate(e);
		((FigureChangeListener)b).figureRequestUpdate(e);
	}

	public void figureChanged(FigureChangeEvent e) {
		((FigureChangeListener)a).figureChanged(e);
		((FigureChangeListener)b).figureChanged(e);
	}

	public void figureRemoved(FigureChangeEvent e) {
		((FigureChangeListener)a).figureRemoved(e);
		((FigureChangeListener)b).figureRemoved(e);
	}

	public static FigureChangeListener add(FigureChangeListener a, FigureChangeListener b) {
		return (FigureChangeListener)addInternal(a, b);
	}


	public static FigureChangeListener remove(FigureChangeListener l, FigureChangeListener oldl) {
	    return (FigureChangeListener) removeInternal(l, oldl);
	}

	protected EventListener remove(EventListener oldl)
	{
		if (oldl == a)
			return b;
		if (oldl == b)
			return a;
		EventListener a2 = removeInternal((FigureChangeListener)a, oldl);
		EventListener b2 = removeInternal((FigureChangeListener)b, oldl);
		if (a2 == a && b2 == b)
			return this;
		else
			return addInternal((FigureChangeListener)a2, (FigureChangeListener)b2);
	}

	protected static EventListener addInternal(FigureChangeListener a, FigureChangeListener b) {
	    if (a == null)  return b;
	    if (b == null)  return a;
	    return new FigureChangeEventMulticaster(a, b);
	}

	protected static EventListener removeInternal(EventListener l, EventListener oldl) {
		if (l == oldl || l == null) {
		    return null;
		} else if (l instanceof FigureChangeEventMulticaster) {
		    return ((FigureChangeEventMulticaster)l).remove(oldl);
		} else {
		    return l;		// it's not here
		}
	}

}
```

File: CH.ifa.draw.standard.AbstractTool
```java

package CH.ifa.draw.standard;

import java.awt.Cursor;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Tool;


public class AbstractTool implements Tool {

	protected DrawingView  fView;

	protected int     fAnchorX, fAnchorY;

	public AbstractTool(DrawingView itsView) {
		fView = itsView;
	}

	public void activate() {
		fView.clearSelection();
	}

	public void deactivate() {
		fView.setCursor(Cursor.getDefaultCursor());
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		fAnchorX = x;
		fAnchorY = y;
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
	}

	public void mouseUp(MouseEvent e, int x, int y) {
	}

	public void mouseMove(MouseEvent evt, int x, int y) {
	}

	public void keyDown(KeyEvent evt, int key) {
	}

	public Drawing drawing() {
		return fView.drawing();
	}

	public DrawingEditor editor() {
		return fView.editor();
	}

	public DrawingView view() {
		return fView;
	}
}
```

File: CH.ifa.draw.standard.NorthHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

class NorthHandle extends LocatorHandle {
	NorthHandle(Figure owner) {
		super(owner, RelativeLocator.north());
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Rectangle r = owner().displayBox();
		owner().displayBox(
			new Point(r.x, Math.min(r.y + r.height, y)),
			new Point(r.x + r.width, r.y + r.height)
		);
	}
}

```

File: CH.ifa.draw.standard.SelectAreaTracker
```java

package CH.ifa.draw.standard;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;

public class SelectAreaTracker extends AbstractTool {

	private Rectangle fSelectGroup;

	public SelectAreaTracker(DrawingView view) {
		super(view);
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		super.mouseDown(e, e.getX(), e.getY());
		rubberBand(fAnchorX, fAnchorY, fAnchorX, fAnchorY);
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
		super.mouseDrag(e, x, y);
		eraseRubberBand();
		rubberBand(fAnchorX, fAnchorY, x, y);
	}

	public void mouseUp(MouseEvent e, int x, int y) {
		super.mouseUp(e, x, y);
		eraseRubberBand();
		selectGroup(e.isShiftDown());
	}

	private void rubberBand(int x1, int y1, int x2, int y2)
	{
		fSelectGroup = new Rectangle(new Point(x1, y1));
		fSelectGroup.add(new Point(x2, y2));
		drawXORRect(fSelectGroup);
	}

	private void eraseRubberBand()
	{
		drawXORRect(fSelectGroup);
	}

	private void drawXORRect(Rectangle r)
	{
		Graphics g = view().getGraphics();
		g.setXORMode(view().getBackground());
		g.setColor(Color.black);
		g.drawRect(r.x, r.y, r.width, r.height);
	}

	private void selectGroup(boolean toggle)
	{
		FigureEnumeration k = drawing().figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			Rectangle r2 = figure.displayBox();
			if (fSelectGroup.contains(r2.x, r2.y) && fSelectGroup.contains(r2.x+r2.width, r2.y+r2.height)) {
				if (toggle)
					view().toggleSelection(figure);
				else
					view().addToSelection(figure);
			}
		}
	}
}
```

File: CH.ifa.draw.standard.TextHolder
```java

package CH.ifa.draw.standard;

import java.awt.Font;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Figure;


public interface TextHolder {

	public Rectangle textDisplayBox();

	public String getText();

	public void setText(String newText);

	public boolean acceptsTyping();

	public int overlayColumns();

	public void connect(Figure connectedFigure);

	public Font getFont();

}
```

File: CH.ifa.draw.standard.NorthEastHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

class NorthEastHandle extends LocatorHandle {
	NorthEastHandle(Figure owner) {
		super(owner, RelativeLocator.northEast());
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Rectangle r = owner().displayBox();
		owner().displayBox(
			new Point(r.x, Math.min(r.y + r.height, y)),
			new Point(Math.max(r.x, x), r.y + r.height)
		);
	}
}

```

File: CH.ifa.draw.standard.StandardDrawing
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingChangeEvent;
import CH.ifa.draw.framework.DrawingChangeListener;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.framework.FigureEnumeration;


public class StandardDrawing extends CompositeFigure implements Drawing {


	private transient Vector              fListeners;

	private transient Thread    fDrawingLockHolder = null;

	private static final long serialVersionUID = -2602151437447962046L;
	private int drawingSerializedDataVersion = 1;

	public StandardDrawing() {
		super();
		fListeners = new Vector(2);
	}


	public void addDrawingChangeListener(DrawingChangeListener listener) {
		fListeners.addElement(listener);
	}

	public void removeDrawingChangeListener(DrawingChangeListener listener) {
		fListeners.removeElement(listener);
	}

	public Enumeration drawingChangeListeners() {
		return fListeners.elements();
	}


	public synchronized Figure remove(Figure figure) {
		if (figure.listener() != null) {
			figure.listener().figureRequestRemove(new FigureChangeEvent(figure, null));
			return figure;
		}
		return null;
	}


	public void figureRequestRemove(FigureChangeEvent e) {
		Figure figure = e.getFigure();
		if (fFigures.contains(figure)) {
			fFigures.removeElement(figure);
			figure.removeFromContainer(this);   // will invalidate figure
			figure.release();
		} else
			System.out.println("Attempt to remove non-existing figure");
	}

	public void figureInvalidated(FigureChangeEvent e) {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.elementAt(i);
				l.drawingInvalidated(new DrawingChangeEvent(this, e.getInvalidatedRectangle()));
			}
		}
	}

	public void figureRequestUpdate(FigureChangeEvent e) {
		if (fListeners != null) {
			for (int i = 0; i < fListeners.size(); i++) {
				DrawingChangeListener l = (DrawingChangeListener)fListeners.elementAt(i);
				l.drawingRequestUpdate(new DrawingChangeEvent(this, null));
			}
		}
	}

	public Vector handles() {
		Vector handles = new Vector();
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		return handles;
	}

	public Rectangle displayBox() {
		if (fFigures.size() > 0) {
			FigureEnumeration k = figures();

			Rectangle r = k.nextFigure().displayBox();

			while (k.hasMoreElements())
				r.add(k.nextFigure().displayBox());
			return r;
		}
		return new Rectangle(0, 0, 0, 0);
	}

	public void basicDisplayBox(Point p1, Point p2) {
	}

	public synchronized void lock() {
		Thread current = Thread.currentThread();
		if (fDrawingLockHolder == current)
			return;
		while (fDrawingLockHolder != null) {
			try { wait(); } catch (InterruptedException ex) { }
		}
		fDrawingLockHolder = current;
	}

	public synchronized void unlock() {
		if (fDrawingLockHolder != null) {
			fDrawingLockHolder = null;
			notifyAll();
		}
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		fListeners = new Vector(2);
	}
}
```

File: CH.ifa.draw.standard.WestHandle
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

class WestHandle extends LocatorHandle {
	WestHandle(Figure owner) {
		super(owner, RelativeLocator.west());
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		Rectangle r = owner().displayBox();
		owner().displayBox(
			new Point(Math.min(r.x + r.width, x), r.y),
			new Point(r.x + r.width, r.y + r.height)
		);
	}
}
```

File: CH.ifa.draw.standard.BoxHandleKit
```java

package CH.ifa.draw.standard;

import java.util.Vector;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Handle;



public class BoxHandleKit {

	static public void addCornerHandles(Figure f, Vector handles) {
		handles.addElement(southEast(f));
		handles.addElement(southWest(f));
		handles.addElement(northEast(f));
		handles.addElement(northWest(f));
	}

	static public void addHandles(Figure f, Vector handles) {
		addCornerHandles(f, handles);
		handles.addElement(south(f));
		handles.addElement(north(f));
		handles.addElement(east(f));
		handles.addElement(west(f));
	}

	static public Handle south(Figure owner) {
		return new SouthHandle(owner);
	}

	static public Handle southEast(Figure owner) {
		return new SouthEastHandle(owner);
	}

	static public Handle southWest(Figure owner) {
		return new SouthWestHandle(owner);
	}

	static public Handle north(Figure owner) {
		return new NorthHandle(owner);
	}

	static public Handle northEast(Figure owner) {
		return new NorthEastHandle(owner);
	}

	static public Handle northWest(Figure owner) {
		return new NorthWestHandle(owner);
	}

	static public Handle east(Figure owner) {
		return new EastHandle(owner);
	}
	static public Handle west(Figure owner) {
		return new WestHandle(owner);
	}
}

```

File: CH.ifa.draw.standard.ActionTool
```java

package CH.ifa.draw.standard;

import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;

public abstract class ActionTool extends AbstractTool {

	public ActionTool(DrawingView itsView) {
		super(itsView);
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		Figure target = drawing().findFigure(x, y);
		if (target != null) {
			view().addToSelection(target);
			action(target);
		}
	}

	public void mouseUp(MouseEvent e, int x, int y) {
		editor().toolDone();
	}

	public abstract void action(Figure figure);
}
```

File: CH.ifa.draw.standard.ConnectionTool
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.event.MouseEvent;
import java.util.Enumeration;

import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.Geom;


public  class ConnectionTool extends AbstractTool {

	private Connector   fStartConnector;
	private Connector   fEndConnector;
	private Connector   fConnectorTarget = null;

	private Figure fTarget = null;

	private ConnectionFigure  fConnection;

	private int  fSplitPoint;

	private ConnectionFigure  fEditedConnection = null;

	private ConnectionFigure  fPrototype;


	public ConnectionTool(DrawingView view, ConnectionFigure prototype) {
		super(view);
		fPrototype = prototype;
	}

	public void mouseMove(MouseEvent e, int x, int y) {
		trackConnectors(e, x, y);
	}

	public void mouseDown(MouseEvent e, int x, int y)
	{
		int ex = e.getX();
		int ey = e.getY();
		fTarget = findConnectionStart(ex, ey, drawing());
		if (fTarget != null) {
			fStartConnector = findConnector(ex, ey, fTarget);
			if (fStartConnector != null) {
				Point p = new Point(ex, ey);
				fConnection = createConnection();
				fConnection.startPoint(p.x, p.y);
				fConnection.endPoint(p.x, p.y);
				view().add(fConnection);
			}
		}
		else {
			ConnectionFigure connection = findConnection(ex, ey, drawing());
			if (connection != null) {
				if (!connection.joinSegments(ex, ey)) {
					fSplitPoint = connection.splitSegment(ex, ey);
					fEditedConnection = connection;
				} else {
					fEditedConnection = null;
				}
			}
		}
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
		Point p = new Point(e.getX(), e.getY());
		if (fConnection != null) {
			trackConnectors(e, x, y);
			if (fConnectorTarget != null)
				p = Geom.center(fConnectorTarget.displayBox());
			fConnection.endPoint(p.x, p.y);
		}
		else if (fEditedConnection != null) {
			Point pp = new Point(x, y);
			fEditedConnection.setPointAt(pp, fSplitPoint);
		}
	}

	public void mouseUp(MouseEvent e, int x, int y) {
		Figure c = null;
		if (fStartConnector != null)
			c = findTarget(e.getX(), e.getY(), drawing());

		if (c != null) {
			fEndConnector = findConnector(e.getX(), e.getY(), c);
			if (fEndConnector != null) {
				fConnection.connectStart(fStartConnector);
				fConnection.connectEnd(fEndConnector);
				fConnection.updateConnection();
			}
		} else if (fConnection != null)
			view().remove(fConnection);

		fConnection = null;
		fStartConnector = fEndConnector = null;
		editor().toolDone();
	}

	public void deactivate() {
		super.deactivate();
		if (fTarget != null)
			fTarget.connectorVisibility(false);
	}

	protected ConnectionFigure createConnection() {
		return (ConnectionFigure)fPrototype.clone();
	}

	protected Figure findSource(int x, int y, Drawing drawing) {
		return findConnectableFigure(x, y, drawing);
	}

	protected Figure findTarget(int x, int y, Drawing drawing) {
		Figure target = findConnectableFigure(x, y, drawing);
		Figure start = fStartConnector.owner();

		if (target != null
			 && fConnection != null
			 && target.canConnect()
			 && !target.includes(start)
			 && fConnection.canConnect(start, target))
			return target;
		return null;
	}

	protected ConnectionFigure findConnection(int x, int y, Drawing drawing) {
		Enumeration k = drawing.figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = (Figure) k.nextElement();
			figure = figure.findFigureInside(x, y);
			if (figure != null && (figure instanceof ConnectionFigure))
				return (ConnectionFigure)figure;
		}
		return null;
	}

	protected ConnectionFigure createdFigure() {
		return fConnection;
	}

	protected void trackConnectors(MouseEvent e, int x, int y) {
		Figure c = null;

		if (fStartConnector == null)
			c = findSource(x, y, drawing());
		else
			c = findTarget(x, y, drawing());

		if (c != fTarget) {
			if (fTarget != null)
				fTarget.connectorVisibility(false);
			fTarget = c;
			if (fTarget != null)
				fTarget.connectorVisibility(true);
		}

		Connector cc = null;
		if (c != null)
			cc = findConnector(e.getX(), e.getY(), c);
		if (cc != fConnectorTarget)
			fConnectorTarget = cc;

		view().checkDamage();
	}

	private Connector findConnector(int x, int y, Figure f) {
		return f.connectorAt(x, y);
	}

	protected Figure findConnectionStart(int x, int y, Drawing drawing) {
		Figure target = findConnectableFigure(x, y, drawing);
		if ((target != null) && target.canConnect())
			return target;
		return null;
	}

	private Figure findConnectableFigure(int x, int y, Drawing drawing) {
		FigureEnumeration k = drawing.figuresReverse();
		while (k.hasMoreElements()) {
			Figure figure = k.nextFigure();
			if (!figure.includes(fConnection) && figure.canConnect()) {
				if (figure.containsPoint(x, y))
					return figure;
			}
		}
		return null;
	}

	protected Connector getStartConnector() {
		return fStartConnector;
	}

	protected Connector getEndConnector() {
		return fEndConnector;
	}

	protected Connector getTarget() {
		return fConnectorTarget;
	}

}
```

File: CH.ifa.draw.standard.OffsetLocator
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.io.IOException;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public  class OffsetLocator extends AbstractLocator {

	private static final long serialVersionUID = 2679950024611847621L;
	private int offsetLocatorSerializedDataVersion = 1;

	private Locator fBase;
	private int     fOffsetX;
	private int     fOffsetY;

	public OffsetLocator() {
		fBase = null;
		fOffsetX = 0;
		fOffsetY = 0;
	}

	public OffsetLocator(Locator base) {
		this();
		fBase = base;
	}

	public OffsetLocator(Locator base, int offsetX, int offsetY) {
		this(base);
		fOffsetX = offsetX;
		fOffsetY = offsetY;
	}

	public Point locate(Figure owner) {
		Point p = fBase.locate(owner);
		p.x += fOffsetX;
		p.y += fOffsetY;
		return p;
	}

	public void moveBy(int dx, int dy) {
		fOffsetX += dx;
		fOffsetY += dy;
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fOffsetX);
		dw.writeInt(fOffsetY);
		dw.writeStorable(fBase);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fOffsetX = dr.readInt();
		fOffsetY = dr.readInt();
		fBase = (Locator)dr.readStorable();
	}
}

```

File: CH.ifa.draw.standard.RelativeLocator
```java

package CH.ifa.draw.standard;

import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public class RelativeLocator extends AbstractLocator {
	private static final long serialVersionUID = 2619148876087898602L;
	private int relativeLocatorSerializedDataVersion = 1;

	double  fRelativeX;
	double  fRelativeY;

	public RelativeLocator() {
		fRelativeX = 0.0;
		fRelativeY = 0.0;
	}

	public RelativeLocator(double relativeX, double relativeY) {
		fRelativeX = relativeX;
		fRelativeY = relativeY;
	}

	public Point locate(Figure owner) {
		Rectangle r = owner.displayBox();
		return new Point(
			r.x + (int)(r.width*fRelativeX),
			r.y + (int)(r.height*fRelativeY)
		);
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeDouble(fRelativeX);
		dw.writeDouble(fRelativeY);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fRelativeX = dr.readDouble();
		fRelativeY = dr.readDouble();
	}

	static public Locator east() {
		return new RelativeLocator(1.0, 0.5);
	}

	static public Locator north() {
		return new RelativeLocator(0.5, 0.0);
	}

	static public Locator west() {
		return new RelativeLocator(0.0, 0.5);
	}

	static public Locator northEast() {
		return new RelativeLocator(1.0, 0.0);
	}

	static public Locator northWest() {
		return new RelativeLocator(0.0, 0.0);
	}

	static public Locator south() {
		return new RelativeLocator(0.5, 1.0);
	}

	static public Locator southEast() {
		return new RelativeLocator(1.0, 1.0);
	}

	static public Locator southWest() {
		return new RelativeLocator(0.0, 1.0);
	}

	static public Locator center() {
		return new RelativeLocator(0.5, 0.5);
	}

}
```

File: CH.ifa.draw.standard.SendToBackCommand
```java

package CH.ifa.draw.standard;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.Command;

public class SendToBackCommand extends Command {

	private DrawingView fView;

	public SendToBackCommand(String name, DrawingView view) {
		super(name);
		fView = view;
	}

	public void execute() {
	   FigureEnumeration k = new ReverseFigureEnumerator(fView.selectionZOrdered());
	   while (k.hasMoreElements()) {
			fView.drawing().sendToBack(k.nextFigure());
		}
		fView.checkDamage();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}

}


```

File: CH.ifa.draw.samples.net.NetApp
```java

package CH.ifa.draw.samples.net;

import java.awt.Panel;

import CH.ifa.draw.application.DrawApplication;
import CH.ifa.draw.figures.LineConnection;
import CH.ifa.draw.figures.TextTool;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.ConnectionTool;
import CH.ifa.draw.standard.CreationTool;

public  class NetApp extends DrawApplication {

	NetApp() {
		super("Net");
	}

	protected void createTools(Panel palette) {
		super.createTools(palette);

		Tool tool = new TextTool(view(), new NodeFigure());
		palette.add(createToolButton(IMAGES+"TEXT", "Text Tool", tool));

		tool = new CreationTool(view(), new NodeFigure());
		palette.add(createToolButton(IMAGES+"RECT", "Create Org Unit", tool));

		tool = new ConnectionTool(view(), new LineConnection());
		palette.add(createToolButton(IMAGES+"CONN", "Connection Tool", tool));
	}


	public static void main(String[] args) {
		DrawApplication window = new NetApp();
		window.open();
	}
}
```

File: CH.ifa.draw.samples.net.NodeFigure
```java

package CH.ifa.draw.samples.net;

import java.awt.Font;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.figures.LineConnection;
import CH.ifa.draw.figures.TextFigure;
import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.standard.ConnectionHandle;
import CH.ifa.draw.standard.LocatorConnector;
import CH.ifa.draw.standard.NullHandle;
import CH.ifa.draw.standard.RelativeLocator;
import CH.ifa.draw.util.Geom;


public class NodeFigure extends TextFigure {
	private static final int BORDER = 6;
	private Vector      fConnectors;
	private boolean     fConnectorsVisible;

	public NodeFigure() {
		initialize();
		fConnectors = null;
	}

	public Rectangle displayBox() {
		Rectangle box = super.displayBox();
		int d = BORDER;
		box.grow(d, d);
		return box;
	}

	public boolean containsPoint(int x, int y) {
		if (fConnectorsVisible) {
			Rectangle r = displayBox();
			int d = LocatorConnector.SIZE/2;
			r.grow(d, d);
			return r.contains(x, y);
		}
		return super.containsPoint(x, y);
	}

	private void drawBorder(Graphics g) {
		Rectangle r = displayBox();
		g.setColor(getFrameColor());
		g.drawRect(r.x, r.y, r.width-1, r.height-1);
	}

	public void draw(Graphics g) {
		super.draw(g);
		drawBorder(g);
		drawConnectors(g);
	}

	public Vector handles() {
		ConnectionFigure prototype = new LineConnection();
		Vector handles = new Vector();
		handles.addElement(new ConnectionHandle(this, RelativeLocator.east(), prototype));
		handles.addElement(new ConnectionHandle(this, RelativeLocator.west(), prototype));
		handles.addElement(new ConnectionHandle(this, RelativeLocator.south(), prototype));
		handles.addElement(new ConnectionHandle(this, RelativeLocator.north(), prototype));

		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		return handles;
	}

	private void drawConnectors(Graphics g) {
		if (fConnectorsVisible) {
			Enumeration e = connectors().elements();
			while (e.hasMoreElements())
				((Connector) e.nextElement()).draw(g);
		}
	}

	public void connectorVisibility(boolean isVisible) {
		fConnectorsVisible = isVisible;
		invalidate();
	}

	public Connector connectorAt(int x, int y) {
		return findConnector(x, y);
	}

	private Vector connectors() {
		if (fConnectors == null)
			createConnectors();
		return fConnectors;
	}

	private void createConnectors() {
		fConnectors = new Vector(4);
		fConnectors.addElement(new LocatorConnector(this, RelativeLocator.north()) );
		fConnectors.addElement(new LocatorConnector(this, RelativeLocator.south()) );
		fConnectors.addElement(new LocatorConnector(this, RelativeLocator.west()) );
		fConnectors.addElement(new LocatorConnector(this, RelativeLocator.east()) );
	}

	private Connector findConnector(int x, int y) {
		long min = Long.MAX_VALUE;
		Connector closest = null;
		Enumeration e = connectors().elements();
		while (e.hasMoreElements()) {
			Connector c = (Connector)e.nextElement();
			Point p2 = Geom.center(c.displayBox());
			long d = Geom.length2(x, y, p2.x, p2.y);
			if (d < min) {
				min = d;
				closest = c;
			}
		}
		return closest;
	}

	private void initialize() {
		setText("node");
		Font fb = new Font("Helvetica", Font.BOLD, 12);
		setFont(fb);
		createConnectors();
	}
}
```

File: CH.ifa.draw.samples.nothing.NothingApplet
```java

package CH.ifa.draw.samples.nothing;

import java.awt.Panel;

import CH.ifa.draw.applet.DrawApplet;
import CH.ifa.draw.contrib.PolygonTool;
import CH.ifa.draw.figures.ElbowConnection;
import CH.ifa.draw.figures.EllipseFigure;
import CH.ifa.draw.figures.LineConnection;
import CH.ifa.draw.figures.LineFigure;
import CH.ifa.draw.figures.RectangleFigure;
import CH.ifa.draw.figures.RoundRectangleFigure;
import CH.ifa.draw.figures.TextFigure;
import CH.ifa.draw.figures.TextTool;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.ConnectionTool;
import CH.ifa.draw.standard.CreationTool;

public class NothingApplet extends DrawApplet {


	protected void createTools(Panel palette) {
		super.createTools(palette);

		Tool tool = new TextTool(view(), new TextFigure());
		palette.add(createToolButton(IMAGES+"TEXT", "Text Tool", tool));

		tool = new CreationTool(view(), new RectangleFigure());
		palette.add(createToolButton(IMAGES+"RECT", "Rectangle Tool", tool));

		tool = new CreationTool(view(), new RoundRectangleFigure());
		palette.add(createToolButton(IMAGES+"RRECT", "Round Rectangle Tool", tool));

		tool = new CreationTool(view(), new EllipseFigure());
		palette.add(createToolButton(IMAGES+"ELLIPSE", "Ellipse Tool", tool));

		tool = new CreationTool(view(), new LineFigure());
		palette.add(createToolButton(IMAGES+"LINE", "Line Tool", tool));

		tool = new PolygonTool(view());
		palette.add(createToolButton(IMAGES+"POLYGON", "Polygon Tool", tool));

		tool = new ConnectionTool(view(), new LineConnection());
		palette.add(createToolButton(IMAGES+"CONN", "Connection Tool", tool));

		tool = new ConnectionTool(view(), new ElbowConnection());
		palette.add(createToolButton(IMAGES+"OCONN", "Elbow Connection Tool", tool));
	}

}
```

File: CH.ifa.draw.samples.nothing.NothingApp
```java

package CH.ifa.draw.samples.nothing;

import java.awt.Panel;

import CH.ifa.draw.application.DrawApplication;
import CH.ifa.draw.contrib.PolygonTool;
import CH.ifa.draw.figures.ElbowConnection;
import CH.ifa.draw.figures.EllipseFigure;
import CH.ifa.draw.figures.LineConnection;
import CH.ifa.draw.figures.LineFigure;
import CH.ifa.draw.figures.RectangleFigure;
import CH.ifa.draw.figures.RoundRectangleFigure;
import CH.ifa.draw.figures.TextFigure;
import CH.ifa.draw.figures.TextTool;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.ConnectionTool;
import CH.ifa.draw.standard.CreationTool;

public  class NothingApp extends DrawApplication {

	NothingApp() {
		super("Nothing");
	}

	protected void createTools(Panel palette) {
		super.createTools(palette);

		Tool tool = new TextTool(view(), new TextFigure());
		palette.add(createToolButton(IMAGES+"TEXT", "Text Tool", tool));

		tool = new CreationTool(view(), new RectangleFigure());
		palette.add(createToolButton(IMAGES+"RECT", "Rectangle Tool", tool));

		tool = new CreationTool(view(), new RoundRectangleFigure());
		palette.add(createToolButton(IMAGES+"RRECT", "Round Rectangle Tool", tool));

		tool = new CreationTool(view(), new EllipseFigure());
		palette.add(createToolButton(IMAGES+"ELLIPSE", "Ellipse Tool", tool));

		tool = new CreationTool(view(), new LineFigure());
		palette.add(createToolButton(IMAGES+"LINE", "Line Tool", tool));

		tool = new PolygonTool(view());
		palette.add(createToolButton(IMAGES+"POLYGON", "Polygon Tool", tool));

		tool = new ConnectionTool(view(), new LineConnection());
		palette.add(createToolButton(IMAGES+"CONN", "Connection Tool", tool));

		tool = new ConnectionTool(view(), new ElbowConnection());
		palette.add(createToolButton(IMAGES+"OCONN", "Elbow Connection Tool", tool));
	}


	public static void main(String[] args) {
		DrawApplication window = new NothingApp();
		window.open();
	}
}
```

File: CH.ifa.draw.samples.pert.PertApplet
```java

package CH.ifa.draw.samples.pert;

import java.awt.Panel;

import CH.ifa.draw.applet.DrawApplet;
import CH.ifa.draw.figures.LineFigure;
import CH.ifa.draw.figures.TextFigure;
import CH.ifa.draw.figures.TextTool;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.ConnectionTool;
import CH.ifa.draw.standard.CreationTool;

public  class PertApplet extends DrawApplet {

	private final static String PERTIMAGES = "/CH/ifa/draw/samples/pert/images/";

	protected void createTools(Panel palette) {
		super.createTools(palette);

		Tool tool;
		tool = new TextTool(view(), new TextFigure());
		palette.add(createToolButton(IMAGES+"TEXT", "Text Tool", tool));

		tool = new PertFigureCreationTool(view());
		palette.add(createToolButton(PERTIMAGES+"PERT", "Task Tool", tool));

		tool = new ConnectionTool(view(), new PertDependency());
		palette.add(createToolButton(IMAGES+"CONN", "Dependency Tool", tool));

		tool = new CreationTool(view(), new LineFigure());
		palette.add(createToolButton(IMAGES+"Line", "Line Tool", tool));
	}
}

```

File: CH.ifa.draw.samples.pert.PertFigure
```java

package CH.ifa.draw.samples.pert;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.figures.NumberTextFigure;
import CH.ifa.draw.figures.TextFigure;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.standard.CompositeFigure;
import CH.ifa.draw.standard.ConnectionHandle;
import CH.ifa.draw.standard.NullHandle;
import CH.ifa.draw.standard.RelativeLocator;
import CH.ifa.draw.util.Storable;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public class PertFigure extends CompositeFigure {
	private static final int BORDER = 3;
	private Rectangle fDisplayBox;
	private Vector fPreTasks;
	private Vector fPostTasks;

	private static final long serialVersionUID = -7877776240236946511L;
	private int pertFigureSerializedDataVersion = 1;

	public PertFigure() {
		initialize();
	}

	public int start() {
		int start = 0;
		Enumeration i = fPreTasks.elements();
		while (i.hasMoreElements()) {
			PertFigure f = (PertFigure) i.nextElement();
			start = Math.max(start, f.end());
		}
		return start;
	}

	public int end() {
		return asInt(2);
	}

	public int duration() {
		return asInt(1);
	}

	public void setEnd(int value) {
		setInt(2, value);
	}

	public void addPreTask(PertFigure figure) {
		if (!fPreTasks.contains(figure)) {
			fPreTasks.addElement(figure);
		}
	}

	public void addPostTask(PertFigure figure) {
		if (!fPostTasks.contains(figure)) {
			fPostTasks.addElement(figure);
		}
	}

	public void removePreTask(PertFigure figure) {
		fPreTasks.removeElement(figure);
	}

	public void removePostTask(PertFigure figure) {
		fPostTasks.removeElement(figure);
	}

	private int asInt(int figureIndex) {
		NumberTextFigure t = (NumberTextFigure)figureAt(figureIndex);
		return t.getValue();
	}

	private String taskName() {
		TextFigure t = (TextFigure)figureAt(0);
		return t.getText();
	}

	private void setInt(int figureIndex, int value) {
		NumberTextFigure t = (NumberTextFigure)figureAt(figureIndex);
		t.setValue(value);
	}

	protected void basicMoveBy(int x, int y) {
	    fDisplayBox.translate(x, y);
	    super.basicMoveBy(x, y);
	}

	public Rectangle displayBox() {
		return new Rectangle(
			fDisplayBox.x,
			fDisplayBox.y,
			fDisplayBox.width,
			fDisplayBox.height);
	}

	public void basicDisplayBox(Point origin, Point corner) {
		fDisplayBox = new Rectangle(origin);
		fDisplayBox.add(corner);
		layout();
	}

	private void drawBorder(Graphics g) {
		super.draw(g);

		Rectangle r = displayBox();

		Figure f = figureAt(0);
		Rectangle rf = f.displayBox();
		g.setColor(Color.gray);
		g.drawLine(r.x, r.y+rf.height+2, r.x+r.width, r.y + rf.height+2);
		g.setColor(Color.white);
		g.drawLine(r.x, r.y+rf.height+3, r.x+r.width, r.y + rf.height+3);

		g.setColor(Color.white);
		g.drawLine(r.x, r.y, r.x, r.y + r.height);
		g.drawLine(r.x, r.y, r.x + r.width, r.y);
		g.setColor(Color.gray);
		g.drawLine(r.x + r.width, r.y, r.x + r.width, r.y + r.height);
		g.drawLine(r.x , r.y + r.height, r.x + r.width, r.y + r.height);
	}

	public void draw(Graphics g) {
		drawBorder(g);
		super.draw(g);
	}

	public Vector handles() {
		Vector handles = new Vector();
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		handles.addElement(new ConnectionHandle(this, RelativeLocator.east(),
								new PertDependency())
						   );
		return handles;
	}

	private void initialize() {
		fPostTasks = new Vector();
		fPreTasks = new Vector();
		fDisplayBox = new Rectangle(0, 0, 0, 0);

		Font f = new Font("Helvetica", Font.PLAIN, 12);
		Font fb = new Font("Helvetica", Font.BOLD, 12);

		TextFigure name = new TextFigure();
		name.setFont(fb);
		name.setText("Task");
		add(name);

		NumberTextFigure duration = new NumberTextFigure();
		duration.setValue(0);
		duration.setFont(fb);
		add(duration);

		NumberTextFigure end = new NumberTextFigure();
		end.setValue(0);
		end.setFont(f);
		end.setReadOnly(true);
		add(end);
	}

	private void layout() {
	    Point partOrigin = new Point(fDisplayBox.x, fDisplayBox.y);
	    partOrigin.translate(BORDER, BORDER);
	    Dimension extent = new Dimension(0, 0);

		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();

		    Dimension partExtent = f.size();
		    Point corner = new Point(
		                        partOrigin.x+partExtent.width,
		                        partOrigin.y+partExtent.height);
			f.basicDisplayBox(partOrigin, corner);

		    extent.width = Math.max(extent.width, partExtent.width);
		    extent.height += partExtent.height;
		    partOrigin.y += partExtent.height;
		}
	    fDisplayBox.width = extent.width + 2*BORDER;
	    fDisplayBox.height = extent.height + 2*BORDER;
	}

	private boolean needsLayout() {
	    Dimension extent = new Dimension(0, 0);

		FigureEnumeration k = figures();
		while (k.hasMoreElements()) {
			Figure f = k.nextFigure();
		    extent.width = Math.max(extent.width, f.size().width);
		}
		int newExtent = extent.width + 2*BORDER;
		return newExtent != fDisplayBox.width;
	}

	public void update(FigureChangeEvent e) {
		if (e.getFigure() == figureAt(1))  // duration has changed
			updateDurations();
		if (needsLayout()) {
			layout();
			changed();
		}
	}

	public void figureChanged(FigureChangeEvent e) {
		update(e);
	}


	public void figureRemoved(FigureChangeEvent e) {
		update(e);
	}

	public void notifyPostTasks() {
		Enumeration i = fPostTasks.elements();
		while (i.hasMoreElements())
			((PertFigure) i.nextElement()).updateDurations();
	}

	public void updateDurations() {
		int newEnd = start()+duration();
		if (newEnd != end()) {
			setEnd(newEnd);
			notifyPostTasks();
		}
	}

	public boolean hasCycle(Figure start) {
		if (start == this)
			return true;
		Enumeration i = fPreTasks.elements();
		while (i.hasMoreElements()) {
			if (((PertFigure) i.nextElement()).hasCycle(start))
				return true;
		}
		return false;
	}


	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fDisplayBox.x);
		dw.writeInt(fDisplayBox.y);
		dw.writeInt(fDisplayBox.width);
		dw.writeInt(fDisplayBox.height);

		writeTasks(dw, fPreTasks);
		writeTasks(dw, fPostTasks);
	}

	public void writeTasks(StorableOutput dw, Vector v) {
		dw.writeInt(v.size());
		Enumeration i = v.elements();
		while (i.hasMoreElements())
			dw.writeStorable((Storable) i.nextElement());
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fDisplayBox = new Rectangle(
			dr.readInt(),
			dr.readInt(),
			dr.readInt(),
			dr.readInt());
		layout();
		fPreTasks = readTasks(dr);
		fPostTasks = readTasks(dr);
	}

	public Insets connectionInsets() {
		Rectangle r = fDisplayBox;
		int cx = r.width/2;
		int cy = r.height/2;
		return new Insets(cy, cx, cy, cx);
	}

	public Vector readTasks(StorableInput dr) throws IOException {
		int size = dr.readInt();
		Vector v = new Vector(size);
		for (int i=0; i<size; i++)
			v.addElement((Figure)dr.readStorable());
		return v;
	}
}
```

File: CH.ifa.draw.samples.pert.PertApplication
```java

package CH.ifa.draw.samples.pert;

import java.awt.Panel;

import CH.ifa.draw.application.DrawApplication;
import CH.ifa.draw.figures.LineFigure;
import CH.ifa.draw.figures.TextFigure;
import CH.ifa.draw.figures.TextTool;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.ConnectionTool;
import CH.ifa.draw.standard.CreationTool;

public  class PertApplication extends DrawApplication {

	static private final String PERTIMAGES = "/CH/ifa/draw/samples/pert/images/";

	PertApplication() {
		super("PERT Editor");
	}

	protected void createTools(Panel palette) {
		super.createTools(palette);

		Tool tool;
		tool = new TextTool(view(), new TextFigure());
		palette.add(createToolButton(IMAGES+"TEXT", "Text Tool", tool));


		tool = new PertFigureCreationTool(view());
		palette.add(createToolButton(PERTIMAGES+"PERT", "Task Tool", tool));

		tool = new ConnectionTool(view(), new PertDependency());
		palette.add(createToolButton(IMAGES+"CONN", "Dependency Tool", tool));

		tool = new CreationTool(view(), new LineFigure());
		palette.add(createToolButton(IMAGES+"Line", "Line Tool", tool));
	}


	public static void main(String[] args) {
		PertApplication pert = new PertApplication();
		pert.open();
	}
}

```

File: CH.ifa.draw.samples.pert.PertFigureCreationTool
```java

package CH.ifa.draw.samples.pert;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.CreationTool;


public  class PertFigureCreationTool extends CreationTool {

	public PertFigureCreationTool(DrawingView view) {
		super(view);
	}

	protected Figure createFigure() {
		return new PertFigure();
	}
}
```

File: CH.ifa.draw.samples.pert.PertDependency
```java

package CH.ifa.draw.samples.pert;

import java.awt.Color;
import java.util.Vector;

import CH.ifa.draw.figures.ArrowTip;
import CH.ifa.draw.figures.LineConnection;
import CH.ifa.draw.figures.PolyLineFigure;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.NullHandle;


public class PertDependency extends LineConnection {
	private static final long serialVersionUID = -7959500008698525009L;
	private int pertDependencySerializedDataVersion = 1;

	public PertDependency() {
		setEndDecoration(new ArrowTip());
		setStartDecoration(null);
	}

	public void handleConnect(Figure start, Figure end) {
		PertFigure source = (PertFigure)start;
		PertFigure target = (PertFigure)end;
		if (source.hasCycle(target)) {
			setAttribute("FrameColor", Color.red);
		} else {
			target.addPreTask(source);
			source.addPostTask(target);
			source.notifyPostTasks();
		}
	}

	public void handleDisconnect(Figure start, Figure end) {
		PertFigure source = (PertFigure)start;
		PertFigure target = (PertFigure)end;
		if (target != null) {
			target.removePreTask(source);
			target.updateDurations();
		}
		if (source != null)
			source.removePostTask(target);
   }   

	public boolean canConnect(Figure start, Figure end) {
		return (start instanceof PertFigure && end instanceof PertFigure);
	}

	public Vector handles() {
		Vector handles = super.handles();
		handles.setElementAt(
			new NullHandle(this, PolyLineFigure.locator(0)), 0);
		return handles;
	}
}
```

File: CH.ifa.draw.samples.javadraw.JavaDrawApp
```java

package CH.ifa.draw.samples.javadraw;

import java.awt.Dimension;
import java.awt.Menu;
import java.awt.MenuBar;
import java.awt.MenuItem;
import java.awt.Panel;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;

import CH.ifa.draw.application.DrawApplication;
import CH.ifa.draw.contrib.PolygonTool;
import CH.ifa.draw.figures.BorderTool;
import CH.ifa.draw.figures.ConnectedTextTool;
import CH.ifa.draw.figures.ElbowConnection;
import CH.ifa.draw.figures.EllipseFigure;
import CH.ifa.draw.figures.InsertImageCommand;
import CH.ifa.draw.figures.LineConnection;
import CH.ifa.draw.figures.LineFigure;
import CH.ifa.draw.figures.RectangleFigure;
import CH.ifa.draw.figures.RoundRectangleFigure;
import CH.ifa.draw.figures.ScribbleTool;
import CH.ifa.draw.figures.TextFigure;
import CH.ifa.draw.figures.TextTool;
import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.ConnectionTool;
import CH.ifa.draw.standard.CreationTool;
import CH.ifa.draw.util.Animatable;
import CH.ifa.draw.util.CommandMenu;

public  class JavaDrawApp extends DrawApplication {

	private Animator            fAnimator;
	private static String       fgSampleImagesPath = "CH/ifa/draw/samples/javadraw/sampleimages/";
	private static String       fgSampleImagesResourcePath = "/"+fgSampleImagesPath;

	public JavaDrawApp() {
		this("JHotDraw");
	}
	public JavaDrawApp(String name) {
		super(name);
	}

	public void open() {
		super.open();
	}


	public void destroy() {
		super.destroy();
		endAnimation();
	}


	protected void createTools(Panel palette) {
		super.createTools(palette);

		Tool tool = new TextTool(view(), new TextFigure());
		palette.add(createToolButton(IMAGES+"TEXT", "Text Tool", tool));

		tool = new ConnectedTextTool(view(), new TextFigure());
		palette.add(createToolButton(IMAGES+"ATEXT", "Connected Text Tool", tool));

		tool = new URLTool(view());
		palette.add(createToolButton(IMAGES+"URL", "URL Tool", tool));

		tool = new CreationTool(view(), new RectangleFigure());
		palette.add(createToolButton(IMAGES+"RECT", "Rectangle Tool", tool));

		tool = new CreationTool(view(), new RoundRectangleFigure());
		palette.add(createToolButton(IMAGES+"RRECT", "Round Rectangle Tool", tool));

		tool = new CreationTool(view(), new EllipseFigure());
		palette.add(createToolButton(IMAGES+"ELLIPSE", "Ellipse Tool", tool));

		tool = new CreationTool(view(), new LineFigure());
		palette.add(createToolButton(IMAGES+"LINE", "Line Tool", tool));

		tool = new ConnectionTool(view(), new LineConnection());
		palette.add(createToolButton(IMAGES+"CONN", "Connection Tool", tool));

		tool = new ConnectionTool(view(), new ElbowConnection());
		palette.add(createToolButton(IMAGES+"OCONN", "Elbow Connection Tool", tool));

		tool = new ScribbleTool(view());
		palette.add(createToolButton(IMAGES+"SCRIBBL", "Scribble Tool", tool));

		tool = new PolygonTool(view());
		palette.add(createToolButton(IMAGES+"POLYGON", "Polygon Tool", tool));

		tool = new BorderTool(view());
		palette.add(createToolButton(IMAGES+"BORDDEC", "Border Tool", tool));
	}

	protected Tool createSelectionTool() {
		return new MySelectionTool(view());
	}

	protected void createMenus(MenuBar mb) {
		super.createMenus(mb);
		mb.add(createAnimationMenu());
		mb.add(createImagesMenu());
		mb.add(createWindowMenu());
	}

	protected Menu createAnimationMenu() {
		Menu menu = new Menu("Animation");
		MenuItem mi = new MenuItem("Start Animation");
		mi.addActionListener(
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            startAnimation();
		        }
		    }
		);
		menu.add(mi);

		mi = new MenuItem("Stop Animation");
		mi.addActionListener(
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            endAnimation();
		        }
		    }
		);
		menu.add(mi);
		return menu;
	}

	protected Menu createWindowMenu() {
		Menu menu = new Menu("Window");
		MenuItem mi = new MenuItem("New Window");
		mi.addActionListener(
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            openView();
		        }
		    }
		);
		menu.add(mi);
		return menu;
	}

	protected Menu createImagesMenu() {
		CommandMenu menu = new CommandMenu("Images");
		File imagesDirectory = new File(fgSampleImagesPath);
		try {
		    String[] list = imagesDirectory.list();
		    for (int i = 0; i < list.length; i++) {
		        String name = list[i];
		        String path = fgSampleImagesResourcePath+name;
		        menu.add(new InsertImageCommand(name, path, view()));
		    }
		} catch (Exception e) {}
		return menu;
	}

	protected Drawing createDrawing() {
		return new BouncingDrawing();
	}

	protected Dimension defaultSize() {
		return new Dimension(430,436);
	}


	public void startAnimation() {
		if (drawing() instanceof Animatable && fAnimator == null) {
			fAnimator = new Animator((Animatable)drawing(), view());
			fAnimator.start();
		}
	}

	public void endAnimation() {
		if (fAnimator != null) {
			fAnimator.end();
			fAnimator = null;
		}
	}

	public void openView() {
		JavaDrawApp window = new JavaDrawApp();
		window.open();
		window.setDrawing(drawing());
		window.setTitle("JHotDraw (View)");

	}


	public static void main(String[] args) {
		JavaDrawApp window = new JavaDrawApp();
		window.open();
	}
}
```

File: CH.ifa.draw.samples.javadraw.AnimationDecorator
```java

package CH.ifa.draw.samples.javadraw;

import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.DecoratorFigure;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public class AnimationDecorator extends DecoratorFigure {

	private int fXVelocity;
	private int fYVelocity;

	private static final long serialVersionUID = 7894632974364110685L;
	private int animationDecoratorSerializedDataVersion = 1;

	public AnimationDecorator() { }

	public AnimationDecorator(Figure figure) {
		super(figure);
		fXVelocity = 4;
		fYVelocity = 4;
	}

	public void velocity(int xVelocity, int yVelocity) {
		fXVelocity = xVelocity;
		fYVelocity = yVelocity;
	}

	public Point velocity() {
		return new Point(fXVelocity, fYVelocity);
	}

	public void animationStep() {
	    int xSpeed = fXVelocity;
	    int ySpeed = fYVelocity;
	    Rectangle box = displayBox();

	    if ((box.x + box.width > 300) && (xSpeed > 0))
			xSpeed = -xSpeed;

	    if ((box.y + box.height > 300) && (ySpeed > 0))
			ySpeed = -ySpeed;

		if ((box.x < 0) && (xSpeed < 0))
			xSpeed = -xSpeed;

		if ((box.y < 0) && (ySpeed < 0))
			ySpeed = -ySpeed;

	    velocity(xSpeed, ySpeed);
	    moveBy(xSpeed, ySpeed);
	}


	public synchronized void basicMoveBy(int x, int y) {
	    super.basicMoveBy(x, y);
	}

	public synchronized void basicDisplayBox(Point origin, Point corner) {
		super.basicDisplayBox(origin, corner);
	}

	public synchronized Rectangle displayBox() {
		return super.displayBox();
	}


	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fXVelocity);
		dw.writeInt(fYVelocity);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fXVelocity = dr.readInt();
		fYVelocity = dr.readInt();
	}

}
```

File: CH.ifa.draw.samples.javadraw.MySelectionTool
```java

package CH.ifa.draw.samples.javadraw;

import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.SelectionTool;


public  class MySelectionTool extends SelectionTool {

	public MySelectionTool(DrawingView view) {
		super(view);
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		if (e.getClickCount() == 2) {
			Figure figure = drawing().findFigure(e.getX(), e.getY());
			if (figure != null) {
				inspectFigure(figure);
				return;
			}
		}
		super.mouseDown(e, x, y);
	}

	protected void inspectFigure(Figure f) {
		System.out.println("inspect figure"+f);
	}

}
```

File: CH.ifa.draw.samples.javadraw.PatternPainter
```java

package CH.ifa.draw.samples.javadraw;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Painter;


public  class PatternPainter
		implements Painter {

	private Image   fImage;

	public PatternPainter(Image image) {
		fImage = image;
	}

	public void draw(Graphics g, DrawingView view) {
		drawPattern(g, fImage, view);
	}

	private void drawPattern(Graphics g, Image image, DrawingView view) {
		int iwidth = image.getWidth(view);
		int iheight = image.getHeight(view);
		Dimension d = view.getSize();
		int x = 0; int y = 0;

		while (y < d.height) {
			while (x < d.width) {
				g.drawImage(image, x, y, view);
				x += iwidth;
			}
			y += iheight;
			x = 0;
		}
	}
}
```

File: CH.ifa.draw.samples.javadraw.BouncingDrawing
```java

package CH.ifa.draw.samples.javadraw;

import java.util.Enumeration;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.StandardDrawing;
import CH.ifa.draw.util.Animatable;


public class BouncingDrawing extends StandardDrawing implements Animatable {
	private static final long serialVersionUID = -8566272817418441758L;
	private int bouncingDrawingSerializedDataVersion = 1;

	public synchronized Figure add(Figure figure) {
		if (!(figure instanceof AnimationDecorator))
			figure = new AnimationDecorator(figure);
		return super.add(figure);
	}

	public synchronized Figure remove(Figure figure) {
		Figure f = super.remove(figure);
		if (f instanceof AnimationDecorator)
			return ((AnimationDecorator) f).peelDecoration();
		return f;
	}

	public synchronized void replace(Figure figure, Figure replacement) {
		if (!(replacement instanceof AnimationDecorator))
			replacement = new AnimationDecorator(replacement);
		super.replace(figure, replacement);
	}

	public void animationStep() {
		Enumeration k = figures();
		while (k.hasMoreElements())
			((AnimationDecorator) k.nextElement()).animationStep();
	}
}
```

File: CH.ifa.draw.samples.javadraw.URLTool
```java

package CH.ifa.draw.samples.javadraw;

import java.awt.Container;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.AbstractTool;
import CH.ifa.draw.util.FloatingTextField;


public  class URLTool extends AbstractTool {

	private FloatingTextField   fTextField;
	private Figure              fURLTarget;

	public URLTool(DrawingView view) {
		super(view);
	}

	public void mouseDown(MouseEvent e, int x, int y)
	{
	    Figure pressedFigure;

	    pressedFigure =  drawing().findFigureInside(x, y);
	    if (pressedFigure != null) {
	        beginEdit(pressedFigure);
	        return;
	    }
	    endEdit();
	}

	public void mouseUp(MouseEvent e, int x, int y) {
	}

	public void deactivate(DrawingView view) {
		super.deactivate();
		endEdit();
	}

	public void endAction(ActionEvent e) {
		endEdit();
	}

	private void beginEdit(Figure figure) {
		if (fTextField == null) {
			fTextField = new FloatingTextField();
		    fTextField.addActionListener(
		        new ActionListener() {
		            public void actionPerformed(ActionEvent event) {
		                endAction(event);
		            }
		        }
		    );
		}

	    if (figure != fURLTarget && fURLTarget != null)
	        endEdit();
		if (figure != fURLTarget) {
			fTextField.createOverlay((Container)view());
	        fTextField.setBounds(fieldBounds(figure), getURL(figure));
	        fURLTarget = figure;
	    }
	}

	private void endEdit() {
	    if (fURLTarget != null) {
		    setURL(fURLTarget, fTextField.getText());
	        fURLTarget = null;
	        fTextField.endOverlay();
	    }
	}

	private Rectangle fieldBounds(Figure figure) {
		Rectangle box = figure.displayBox();
		int nChars = Math.max(20, getURL(figure).length());
		Dimension d = fTextField.getPreferredSize(nChars);
		box.x = Math.max(0, box.x + (box.width - d.width)/2);
		box.y = Math.max(0, box.y + (box.height - d.height)/2);
		return new Rectangle(box.x, box.y, d.width, d.height);
	}

	private String getURL(Figure figure) {
		String url = (String) figure.getAttribute("URL");
		if (url == null)
			url = "";
		return url;
	}

	private void setURL(Figure figure, String url) {
		figure.setAttribute("URL", url);
	}
}

```

File: CH.ifa.draw.samples.javadraw.FollowURLTool
```java

package CH.ifa.draw.samples.javadraw;

import java.applet.Applet;
import java.awt.event.MouseEvent;
import java.net.MalformedURLException;
import java.net.URL;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.AbstractTool;

class FollowURLTool extends AbstractTool {
	 private Applet         fApplet;

	 FollowURLTool(DrawingView view, Applet applet) {
		super(view);
		fApplet = applet;
	 } 

	public void mouseMove(MouseEvent e, int x, int y) {
		String urlstring = null;
	    Figure figure = drawing().findFigureInside(x,y);
	    if (figure != null)
		    urlstring = (String) figure.getAttribute("URL");
	    if (urlstring != null)
	        fApplet.showStatus(urlstring);
	    else
	        fApplet.showStatus("");
	}

	public void mouseUp(MouseEvent e, int x, int y) {
	    Figure figure = drawing().findFigureInside(x, y);
	    if (figure == null)
	        return;
	    String urlstring = (String) figure.getAttribute("URL");
	    if (urlstring == null)
	        return;

	    try {
		    URL url = new URL(fApplet.getDocumentBase(), urlstring);
			fApplet.getAppletContext().showDocument(url);
		} catch (MalformedURLException exception) {
			fApplet.showStatus(exception.toString());
		}
	}
}
```

File: CH.ifa.draw.samples.javadraw.JavaDrawViewer
```java

package CH.ifa.draw.samples.javadraw;

import java.applet.Applet;
import java.awt.BorderLayout;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.StandardDrawing;
import CH.ifa.draw.standard.StandardDrawingView;
import CH.ifa.draw.util.Iconkit;
import CH.ifa.draw.util.StorableInput;


public  class JavaDrawViewer extends Applet implements DrawingEditor {

	private Drawing         fDrawing;
	private Tool            fTool;
	private StandardDrawingView fView;
	private Iconkit         fIconkit;

	public void init() {
		setLayout(new BorderLayout());
	    fView = new StandardDrawingView(this, 400, 370);
		add("Center", fView);
		fTool = new FollowURLTool(view(), this);

		fIconkit = new Iconkit(this);

		String filename = getParameter("Drawing");
		if (filename != null) {
		    loadDrawing(filename);
			fView.setDrawing(fDrawing);
		} else
		    showStatus("Unable to load drawing");
	}

	private void loadDrawing(String filename) {
		try {
			URL url = new URL(getCodeBase(), filename);
			InputStream stream = url.openStream();
			StorableInput reader = new StorableInput(stream);
			fDrawing = (Drawing)reader.readStorable();
		} catch (IOException e) {
			fDrawing = new StandardDrawing();
			System.out.println("Error when Loading: " + e);
			showStatus("Error when Loading: " + e);
		}
	}

	public DrawingView view() {
		return fView;
	}

	public Drawing drawing() {
		return fDrawing;
	}

	public Tool tool() {
		return fTool;
	}

	public void toolDone() {}

	public void selectionChanged(DrawingView view) {}
}

```

File: CH.ifa.draw.samples.javadraw.Animator
```java

package CH.ifa.draw.samples.javadraw;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.util.Animatable;


public  class Animator extends Thread {

	private DrawingView     fView;
	private Animatable      fAnimatable;

	private boolean             fIsRunning;
	private static final int    DELAY = 1000 / 16;

	public Animator(Animatable animatable, DrawingView view) {
		super("Animator");
		fView = view;
		fAnimatable = animatable;
	}

	public void start() {
		super.start();
		fIsRunning = true;
	}

	public void end() {
		fIsRunning = false;
	}

	public void run() {
		while (fIsRunning) {
			long tm = System.currentTimeMillis();
			fView.freezeView();
			fAnimatable.animationStep();
			fView.checkDamage();
			fView.unfreezeView();

			try {
				tm += DELAY;
				Thread.sleep(Math.max(0, tm - System.currentTimeMillis()));
			} catch (InterruptedException e) {
				break;
			}
		}
	}
}

```

File: CH.ifa.draw.samples.javadraw.JavaDrawApplet
```java

package CH.ifa.draw.samples.javadraw;

import java.awt.Button;
import java.awt.Panel;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import CH.ifa.draw.applet.DrawApplet;
import CH.ifa.draw.contrib.PolygonTool;
import CH.ifa.draw.figures.BorderTool;
import CH.ifa.draw.figures.ConnectedTextTool;
import CH.ifa.draw.figures.ElbowConnection;
import CH.ifa.draw.figures.EllipseFigure;
import CH.ifa.draw.figures.LineConnection;
import CH.ifa.draw.figures.LineFigure;
import CH.ifa.draw.figures.RectangleFigure;
import CH.ifa.draw.figures.RoundRectangleFigure;
import CH.ifa.draw.figures.ScribbleTool;
import CH.ifa.draw.figures.TextFigure;
import CH.ifa.draw.figures.TextTool;
import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.ConnectionTool;
import CH.ifa.draw.standard.CreationTool;
import CH.ifa.draw.util.Animatable;


public  class JavaDrawApplet extends DrawApplet {

	transient private Button          fAnimationButton;
	transient private Animator        fAnimator;


	public void destroy() {
		super.destroy();
		endAnimation();
	}


	protected void createTools(Panel palette) {
		super.createTools(palette);

		Tool tool = new TextTool(view(), new TextFigure());
		palette.add(createToolButton(IMAGES+"TEXT", "Text Tool", tool));

		tool = new ConnectedTextTool(view(), new TextFigure());
		palette.add(createToolButton(IMAGES+"ATEXT", "Connected Text Tool", tool));

		tool = new URLTool(view());
		palette.add(createToolButton(IMAGES+"URL", "URL Tool", tool));

		tool = new CreationTool(view(), new RectangleFigure());
		palette.add(createToolButton(IMAGES+"RECT", "Rectangle Tool", tool));

		tool = new CreationTool(view(), new RoundRectangleFigure());
		palette.add(createToolButton(IMAGES+"RRECT", "Round Rectangle Tool", tool));

		tool = new CreationTool(view(), new EllipseFigure());
		palette.add(createToolButton(IMAGES+"ELLIPSE", "Ellipse Tool", tool));

		tool = new CreationTool(view(), new LineFigure());
		palette.add(createToolButton(IMAGES+"LINE", "Line Tool", tool));

		tool = new ConnectionTool(view(), new LineConnection());
		palette.add(createToolButton(IMAGES+"CONN", "Connection Tool", tool));

		tool = new ConnectionTool(view(), new ElbowConnection());
		palette.add(createToolButton(IMAGES+"OCONN", "Elbow Connection Tool", tool));

		tool = new ScribbleTool(view());
		palette.add(createToolButton(IMAGES+"SCRIBBL", "Scribble Tool", tool));

		tool = new PolygonTool(view());
		palette.add(createToolButton(IMAGES+"POLYGON", "Polygon Tool", tool));

		tool = new BorderTool(view());
		palette.add(createToolButton(IMAGES+"BORDDEC", "Border Tool", tool));
	}

	protected void createButtons(Panel panel) {
		super.createButtons(panel);
		fAnimationButton = new Button("Start Animation");
		fAnimationButton.addActionListener(
		    new ActionListener() {
		        public void actionPerformed(ActionEvent event) {
		            toggleAnimation();
		        }
		    }
		);
		panel.add(fAnimationButton);
	}

	protected Drawing createDrawing() {
		return new BouncingDrawing();
	}


	public void startAnimation() {
		if (drawing() instanceof Animatable && fAnimator == null) {
			fAnimator = new Animator((Animatable)drawing(), view());
			fAnimator.start();
			fAnimationButton.setLabel("End Animation");
		}
	}

	public void endAnimation() {
		if (fAnimator != null) {
			fAnimator.end();
			fAnimator = null;
			fAnimationButton.setLabel("Start Animation");
		}
	}

	public void toggleAnimation() {
		if (fAnimator != null)
			endAnimation();
		else
			startAnimation();
	}

}
```

File: CH.ifa.draw.figures.FontSizeHandle
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.LocatorHandle;

public class FontSizeHandle extends LocatorHandle {

	private Font    fFont;
	private int     fSize;

	public FontSizeHandle(Figure owner, Locator l) {
		super(owner, l);
	}

	public void invokeStart(int  x, int  y, DrawingView view) {
		TextFigure textOwner = (TextFigure) owner();
		fFont = textOwner.getFont();
		fSize = fFont.getSize();
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		TextFigure textOwner = (TextFigure) owner();
		int newSize = fSize + y-anchorY;
		textOwner.setFont(new Font(fFont.getName(), fFont.getStyle(), newSize) );
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();

		g.setColor(Color.yellow);
		g.fillOval(r.x, r.y, r.width, r.height);

		g.setColor(Color.black);
		g.drawOval(r.x, r.y, r.width, r.height);
	}
}
```

File: CH.ifa.draw.figures.ConnectedTextTool
```java

package CH.ifa.draw.figures;

import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.TextHolder;

public  class ConnectedTextTool extends TextTool {

	boolean     fConnected = false;

	public ConnectedTextTool(DrawingView view, Figure prototype) {
		super(view, prototype);
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		super.mouseDown(e, x, y);

	    Figure pressedFigure =  drawing().findFigureInside(x, y);

	    TextHolder textHolder = (TextHolder)createdFigure();
		if (!fConnected && pressedFigure != null &&
					 textHolder != null && pressedFigure != textHolder) {
			textHolder.connect(pressedFigure);
			fConnected = true;
		}
	}

	public void activate() {
		fConnected = false;
	}
}

```

File: CH.ifa.draw.figures.ElbowHandle
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.AbstractHandle;
import CH.ifa.draw.util.Geom;

public class ElbowHandle extends AbstractHandle {

	private int fSegment;
	private int fLastX, fLastY;      // previous mouse position

	public ElbowHandle(LineConnection owner, int segment) {
		super(owner);
		fSegment = segment;
	}

	public void invokeStart(int  x, int  y, DrawingView view) {
		fLastX = x;
		fLastY = y;
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		LineConnection line = ownerConnection();
		Point p1 = line.pointAt(fSegment);
		Point p2 = line.pointAt(fSegment+1);
		int ddx = x - fLastX;
		int ddy = y - fLastY;

		Point np1;
		Point np2;
		if (isVertical(p1, p2)) {
			int cx = constrainX(p1.x + ddx);
			np1 = new Point(cx, p1.y);
			np2 = new Point(cx, p2.y);
		} else {
			int cy = constrainY(p1.y + ddy);
			np1 = new Point(p1.x, cy);
			np2 = new Point(p2.x, cy);
		}
		line.setPointAt(np1, fSegment);
		line.setPointAt(np2, fSegment+1);
		fLastX = x;
		fLastY = y;
	}

	private boolean isVertical(Point p1, Point p2) {
		return p1.x == p2.x;
	}

	public Point locate() {
		LineConnection line = ownerConnection();
		int segment = Math.min(fSegment, line.pointCount()-2);
		Point p1 = line.pointAt(segment);
		Point p2 = line.pointAt(segment+1);
		return new Point((p1.x + p2.x)/2, (p1.y + p2.y)/2);
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();

		g.setColor(Color.yellow);
		g.fillOval(r.x, r.y, r.width, r.height);

		g.setColor(Color.black);
		g.drawOval(r.x, r.y, r.width, r.height);
	}

	private int constrainX(int x) {
		LineConnection line = ownerConnection();
		Figure startFigure = line.start().owner();
		Figure endFigure = line.end().owner();
		Rectangle start = startFigure.displayBox();
		Rectangle end = endFigure.displayBox();
		Insets i1 = startFigure.connectionInsets();
		Insets i2 = endFigure.connectionInsets();

		int r1x, r1width, r2x, r2width;
		r1x = start.x + i1.left;
		r1width = start.width - i1.left - i1.right-1;

		r2x = end.x + i2.left;
		r2width = end.width - i2.left - i2.right-1;

		if (fSegment == 0)
			x = Geom.range(r1x, r1x + r1width, x);
		if (fSegment == line.pointCount()-2)
			x = Geom.range(r2x, r2x + r2width, x);
		return x;
	}

	private int constrainY(int y) {
		LineConnection line = ownerConnection();
		Figure startFigure = line.start().owner();
		Figure endFigure = line.end().owner();
		Rectangle start = startFigure.displayBox();
		Rectangle end = endFigure.displayBox();
		Insets i1 = startFigure.connectionInsets();
		Insets i2 = endFigure.connectionInsets();

		int r1y, r1height, r2y, r2height;
		r1y = start.y + i1.top;
		r1height = start.height - i1.top - i1.bottom-1;
		r2y = end.y + i2.top;
		r2height = end.height - i2.top - i2.bottom-1;

		if (fSegment == 0)
			y = Geom.range(r1y, r1y + r1height, y);
		if (fSegment == line.pointCount()-2)
			y = Geom.range(r2y, r2y + r2height, y);
		return y;
	}

	private LineConnection ownerConnection() {
		return (LineConnection)owner();
	}

}
```

File: CH.ifa.draw.figures.InsertImageCommand
```java

package CH.ifa.draw.figures;

import java.awt.Component;
import java.awt.Image;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.util.Command;
import CH.ifa.draw.util.Iconkit;

public class InsertImageCommand extends Command {

	private DrawingView  fView;
	private String       fImage;

	public InsertImageCommand(String name, String image, DrawingView view) {
		super(name);
		fImage = image;
		fView = view;
	}

	public void execute() {
		Image image = Iconkit.instance().registerAndLoadImage((Component)fView, fImage);
		ImageFigure figure = new ImageFigure(image, fImage, fView.lastClick());
		fView.add(figure);
		fView.clearSelection();
		fView.addToSelection(figure);
		fView.checkDamage();
	}
}



```

File: CH.ifa.draw.figures.BorderTool
```java

package CH.ifa.draw.figures;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.ActionTool;

public  class BorderTool extends ActionTool {

	public BorderTool(DrawingView view) {
		super(view);
	}

	public void action(Figure figure) {
		drawing().replace(figure, new BorderDecorator(figure));
	}
}
```

File: CH.ifa.draw.figures.GroupFigure
```java

package CH.ifa.draw.figures;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Vector;

import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.standard.CompositeFigure;
import CH.ifa.draw.standard.FigureEnumerator;
import CH.ifa.draw.standard.RelativeLocator;

public  class GroupFigure extends CompositeFigure {

	private static final long serialVersionUID = 8311226373023297933L;
	private int groupFigureSerializedDataVersion = 1;

	public boolean canConnect() {
		return false;
	}

	public Rectangle displayBox() {
		FigureEnumeration k = figures();
		Rectangle r = k.nextFigure().displayBox();

		while (k.hasMoreElements())
			r.add(k.nextFigure().displayBox());
		return r;
	}

	public void basicDisplayBox(Point origin, Point corner) {
	}

	public FigureEnumeration decompose() {
		return new FigureEnumerator(fFigures);
	}

	public Vector handles() {
		Vector handles = new Vector();
		handles.addElement(new GroupHandle(this, RelativeLocator.northWest()));
		handles.addElement(new GroupHandle(this, RelativeLocator.northEast()));
		handles.addElement(new GroupHandle(this, RelativeLocator.southWest()));
		handles.addElement(new GroupHandle(this, RelativeLocator.southEast()));
		return handles;
	}

	public void setAttribute(String name, Object value) {
		super.setAttribute(name, value);
		FigureEnumeration k = figures();
		while (k.hasMoreElements())
			k.nextFigure().setAttribute(name, value);
	}
}
```

File: CH.ifa.draw.figures.PolyLineFigure
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;

import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.AbstractFigure;
import CH.ifa.draw.util.Geom;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public  class PolyLineFigure extends AbstractFigure {

	public final static int ARROW_TIP_NONE  = 0;
	public final static int ARROW_TIP_START = 1;
	public final static int ARROW_TIP_END   = 2;
	public final static int ARROW_TIP_BOTH  = 3;

	protected Vector              fPoints;
	protected LineDecoration      fStartDecoration = null;
	protected LineDecoration      fEndDecoration = null;
	protected Color               fFrameColor = Color.black;

	private static final long serialVersionUID = -7951352179906577773L;
	private int polyLineFigureSerializedDataVersion = 1;

	public PolyLineFigure() {
		fPoints = new Vector(4);
	}

	public PolyLineFigure(int size) {
		fPoints = new Vector(size);
	}

	public PolyLineFigure(int x, int y) {
	    fPoints = new Vector();
	    fPoints.addElement(new Point(x, y));
	}

	public Rectangle displayBox() {
		Enumeration k = points();
		Rectangle r = new Rectangle((Point) k.nextElement());

		while (k.hasMoreElements())
			r.add((Point) k.nextElement());

		return r;
	}

	public boolean isEmpty() {
		return (size().width < 3) && (size().height < 3);
	}

	public Vector handles() {
		Vector handles = new Vector(fPoints.size());
		for (int i = 0; i < fPoints.size(); i++)
			handles.addElement(new PolyLineHandle(this, locator(i), i));
		return handles;
	}

	public void basicDisplayBox(Point origin, Point corner) {
	}

	public void addPoint(int x, int y) {
		fPoints.addElement(new Point(x, y));
		changed();
	}

	public Enumeration points() {
		return fPoints.elements();
	}

	public int pointCount() {
		return fPoints.size();
	}

	protected void basicMoveBy(int dx, int dy) {
		Enumeration k = fPoints.elements();
		while (k.hasMoreElements())
			((Point) k.nextElement()).translate(dx, dy);
	}

	public void setPointAt(Point p, int i) {
		willChange();
		fPoints.setElementAt(p, i);
		changed();
	}

	public void insertPointAt(Point p, int i) {
		fPoints.insertElementAt(p, i);
		changed();
	}

	public void removePointAt(int i) {
		willChange();
		fPoints.removeElementAt(i);
		changed();
	}

	public int splitSegment(int x, int y) {
		int i = findSegment(x, y);
		if (i != -1)
			insertPointAt(new Point(x, y), i+1);
		return i+1;
	}

	public Point pointAt(int i) {
		return (Point)fPoints.elementAt(i);
	}

	public boolean joinSegments(int x, int y) {
		for (int i= 1; i < fPoints.size()-1; i++) {
			Point p = pointAt(i);
			if (Geom.length(x, y, p.x, p.y) < 3) {
				removePointAt(i);
				return true;
			}
		}
		return false;
	}

	public Connector connectorAt(int x, int y) {
		return new PolyLineConnector(this);
	}

	public void setStartDecoration(LineDecoration l) {
		fStartDecoration = l;
	}

	public void setEndDecoration(LineDecoration l) {
		fEndDecoration = l;
	}

	public void draw(Graphics g) {
		g.setColor(getFrameColor());
		Point p1, p2;
		for (int i = 0; i < fPoints.size()-1; i++) {
			p1 = (Point) fPoints.elementAt(i);
			p2 = (Point) fPoints.elementAt(i+1);
			g.drawLine(p1.x, p1.y, p2.x, p2.y);
		}
		decorate(g);
	}

	public boolean containsPoint(int x, int y) {
		Rectangle bounds = displayBox();
		bounds.grow(4,4);
		if (!bounds.contains(x, y))
			return false;

		Point p1, p2;
		for (int i = 0; i < fPoints.size()-1; i++) {
			p1 = (Point) fPoints.elementAt(i);
			p2 = (Point) fPoints.elementAt(i+1);
			if (Geom.lineContainsPoint(p1.x, p1.y, p2.x, p2.y, x, y))
				return true;
		}
		return false;
	}

	public int findSegment(int x, int y) {
		Point p1, p2;
		for (int i = 0; i < fPoints.size()-1; i++) {
			p1 = (Point) fPoints.elementAt(i);
			p2 = (Point) fPoints.elementAt(i+1);
			if (Geom.lineContainsPoint(p1.x, p1.y, p2.x, p2.y, x, y))
				return i;
		}
		return -1;
	}

	private void decorate(Graphics g) {
		if (fStartDecoration != null) {
			Point p1 = (Point)fPoints.elementAt(0);
			Point p2 = (Point)fPoints.elementAt(1);
			fStartDecoration.draw(g, p1.x, p1.y, p2.x, p2.y);
		}
		if (fEndDecoration != null) {
			Point p3 = (Point)fPoints.elementAt(fPoints.size()-2);
			Point p4 = (Point)fPoints.elementAt(fPoints.size()-1);
			fEndDecoration.draw(g, p4.x, p4.y, p3.x, p3.y);
		}
	}

	public Object getAttribute(String name) {
		if (name.equals("FrameColor")) {
			return getFrameColor();
		}
		else if (name.equals("ArrowMode")) {
			int value = 0;
			if (fStartDecoration != null)
				value |= ARROW_TIP_START;
			if (fEndDecoration != null)
				value |= ARROW_TIP_END;
			return new Integer(value);
		}
		return super.getAttribute(name);
	}

	public void setAttribute(String name, Object value) {
		if (name.equals("FrameColor")) {
			setFrameColor((Color)value);
			changed();
		}
		else if (name.equals("ArrowMode")) {
			Integer intObj = (Integer) value;
			if (intObj != null) {
				int decoration = intObj.intValue();
				if ((decoration & ARROW_TIP_START) != 0)
					fStartDecoration = new ArrowTip();
				else
					fStartDecoration = null;
				if ((decoration & ARROW_TIP_END) != 0)
					fEndDecoration = new ArrowTip();
				else
					fEndDecoration = null;
			}
			changed();
		}
		else
			super.setAttribute(name, value);
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fPoints.size());
		Enumeration k = fPoints.elements();
		while (k.hasMoreElements()) {
			Point p = (Point) k.nextElement();
			dw.writeInt(p.x);
			dw.writeInt(p.y);
		}
		dw.writeStorable(fStartDecoration);
		dw.writeStorable(fEndDecoration);
		dw.writeColor(fFrameColor);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		int size = dr.readInt();
		fPoints = new Vector(size);
		for (int i=0; i<size; i++) {
			int x = dr.readInt();
			int y = dr.readInt();
			fPoints.addElement(new Point(x,y));
		}
		fStartDecoration = (LineDecoration)dr.readStorable();
		fEndDecoration = (LineDecoration)dr.readStorable();
		fFrameColor = dr.readColor();
	}

	public static Locator locator(int pointIndex) {
		return new PolyLineLocator(pointIndex);
	}

	protected Color getFrameColor() {
		return fFrameColor;
	}

	protected void setFrameColor(Color c) {
		fFrameColor = c;
	}
}
```

File: CH.ifa.draw.figures.RadiusHandle
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.standard.AbstractHandle;
import CH.ifa.draw.util.Geom;

class RadiusHandle extends AbstractHandle {

	private Point fRadius;
	private RoundRectangleFigure fOwner;
	private static final int OFFSET = 4;

	public RadiusHandle(RoundRectangleFigure owner) {
		super(owner);
		fOwner = owner;
	}

	public void invokeStart(int  x, int  y, DrawingView view) {
		fRadius = fOwner.getArc();
		fRadius.x = fRadius.x/2;
		fRadius.y = fRadius.y/2;
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		int dx = x-anchorX;
		int dy = y-anchorY;
		Rectangle r = fOwner.displayBox();
		int rx = Geom.range(0, r.width, 2*(fRadius.x + dx));
		int ry = Geom.range(0, r.height, 2*(fRadius.y + dy));
		fOwner.setArc(rx, ry);
	}

	public Point locate() {
		Point radius = fOwner.getArc();
		Rectangle r = fOwner.displayBox();
		return new Point(r.x+radius.x/2+OFFSET, r.y+radius.y/2+OFFSET);
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();

		g.setColor(Color.yellow);
		g.fillOval(r.x, r.y, r.width, r.height);

		g.setColor(Color.black);
		g.drawOval(r.x, r.y, r.width, r.height);
	}
}

```

File: CH.ifa.draw.figures.TextTool
```java

package CH.ifa.draw.figures;

import java.awt.Container;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.CreationTool;
import CH.ifa.draw.standard.TextHolder;
import CH.ifa.draw.util.FloatingTextField;

public class TextTool extends CreationTool {

	private FloatingTextField   fTextField;
	private TextHolder  fTypingTarget;

	public TextTool(DrawingView view, Figure prototype) {
		super(view, prototype);
	}

	public void mouseDown(MouseEvent e, int x, int y)
	{
	    Figure pressedFigure;
	    TextHolder textHolder = null;

	    pressedFigure = drawing().findFigureInside(x, y);
	    if (pressedFigure instanceof TextHolder) {
	        textHolder = (TextHolder) pressedFigure;
	        if (!textHolder.acceptsTyping())
	            textHolder = null;
		}
	    if (textHolder != null) {
	        beginEdit(textHolder);
	        return;
	    }
	    if (fTypingTarget != null) {
	        editor().toolDone();
	        endEdit();
	    } else {
		    super.mouseDown(e, x, y);
		    textHolder = (TextHolder)createdFigure();
		    beginEdit(textHolder);
		}
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
	}

	public void mouseUp(MouseEvent e, int x, int y) {
	}

	public void deactivate() {
		super.deactivate();
		endEdit();
	}

	public void activate() {
		super.activate();
		view().clearSelection();
	}

	protected void beginEdit(TextHolder figure) {
		if (fTextField == null)
			fTextField = new FloatingTextField();

	    if (figure != fTypingTarget && fTypingTarget != null)
	        endEdit();

		fTextField.createOverlay((Container)view(), figure.getFont());
	    fTextField.setBounds(fieldBounds(figure), figure.getText());
	    fTypingTarget = figure;
	}

	protected void endEdit() {
	    if (fTypingTarget != null) {
	        if (fTextField.getText().length() > 0)
	            fTypingTarget.setText(fTextField.getText());
	        else
	            drawing().remove((Figure)fTypingTarget);
	        fTypingTarget = null;
	        fTextField.endOverlay();
	        view().checkDamage();
	    }
	}

	private Rectangle fieldBounds(TextHolder figure) {
		Rectangle box = figure.textDisplayBox();
		int nChars = figure.overlayColumns();
		Dimension d = fTextField.getPreferredSize(nChars);
		return new Rectangle(box.x, box.y, d.width, d.height);
	}
}

```

File: CH.ifa.draw.figures.UngroupCommand
```java

package CH.ifa.draw.figures;

import java.util.Vector;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureEnumeration;
import CH.ifa.draw.util.Command;

public  class UngroupCommand extends Command {

	private DrawingView fView;

	public UngroupCommand(String name, DrawingView view) {
		super(name);
		fView = view;
	}

	public void execute() {
		FigureEnumeration selection = fView.selectionElements();
		fView.clearSelection();

		Vector parts = new Vector();
		while (selection.hasMoreElements()) {
			Figure selected = selection.nextFigure();
			Figure group = fView.drawing().orphan(selected);
			FigureEnumeration k = group.decompose();
			while (k.hasMoreElements())
				fView.addToSelection(fView.add(k.nextFigure()));
		}
		fView.checkDamage();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}

}
```

File: CH.ifa.draw.figures.ElbowTextLocator
```java

package CH.ifa.draw.figures;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.AbstractLocator;

class ElbowTextLocator extends AbstractLocator {
	public Point locate(Figure owner) {
		Point p = owner.center();
		Rectangle r = owner.displayBox();
		return new Point(p.x, p.y-10); // hack
	}
}

```

File: CH.ifa.draw.figures.ArrowTip
```java

package CH.ifa.draw.figures;

import java.awt.Graphics;
import java.awt.Polygon;
import java.io.IOException;

import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public  class ArrowTip implements LineDecoration {

	private double  fAngle;         // pointiness of arrow
	private double  fOuterRadius;
	private double  fInnerRadius;

	private static final long serialVersionUID = -3459171428373823638L;
	private int arrowTipSerializedDataVersion = 1;

	public ArrowTip() {
	    fAngle = 0.40;//0.35;
	    fOuterRadius = 8;//15;
	    fInnerRadius = 8;//12;
	}

	public ArrowTip(double angle, double outerRadius, double innerRadius) {
	    fAngle = angle;
	    fOuterRadius = outerRadius;
	    fInnerRadius = innerRadius;
	}

	public void draw(Graphics g, int x1, int y1, int x2, int y2) {
		Polygon p = outline(x1, y1, x2, y2);
		g.fillPolygon(p.xpoints, p.ypoints, p.npoints);
	}

	public Polygon outline(int x1, int y1, int x2, int y2) {
		double dir = Math.PI/2 - Math.atan2(x2-x1, y1-y2);
		return outline(x1, y1, dir);
	}

	private Polygon outline(int x, int y, double direction) {
		Polygon shape = new Polygon();

		shape.addPoint(x, y);
		addPointRelative(shape, x, y, fOuterRadius, direction - fAngle);
		addPointRelative(shape, x, y, fInnerRadius, direction);
		addPointRelative(shape, x, y, fOuterRadius, direction + fAngle);
		shape.addPoint(x,y); // Closing the polygon (TEG 97-04-23)
		return shape;
	}

	private void addPointRelative(Polygon shape, int x, int y, double radius, double angle) {
		shape.addPoint(
			x + (int) (radius * Math.cos(angle)),
			y - (int) (radius * Math.sin(angle)));
	}

	public void write(StorableOutput dw) {
	}

	public void read(StorableInput dr) throws IOException {
	}

}
```

File: CH.ifa.draw.figures.NumberTextFigure
```java

package CH.ifa.draw.figures;



public  class NumberTextFigure extends TextFigure {

	private static final long serialVersionUID = -4056859232918336475L;
	private int numberTextFigureSerializedDataVersion = 1;

	public int overlayColumns() {
		return Math.max(4, getText().length());
	}

	public int getValue() {
		int value = 0;
		try {
			value = Integer.parseInt(getText());
		} catch (NumberFormatException e) {
			value = 0;
		}
		return value;
	}

	public void setValue(int value) {
		setText(Integer.toString(value));
	}

}
```

File: CH.ifa.draw.figures.BorderDecorator
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.standard.DecoratorFigure;

public  class BorderDecorator extends DecoratorFigure {

	private static final long serialVersionUID = 1205601808259084917L;
	private int borderDecoratorSerializedDataVersion = 1;

	public BorderDecorator() { }
	public BorderDecorator(Figure figure) {
		super(figure);
	}

	private Point border() {
		return new Point(3,3);
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();
		super.draw(g);
		g.setColor(Color.white);
		g.drawLine(r.x, r.y, r.x, r.y + r.height);
		g.drawLine(r.x, r.y, r.x + r.width, r.y);
		g.setColor(Color.gray);
		g.drawLine(r.x + r.width, r.y, r.x + r.width, r.y + r.height);
		g.drawLine(r.x , r.y + r.height, r.x + r.width, r.y + r.height);
	}

	public Rectangle displayBox() {
		Rectangle r = fComponent.displayBox();
		r.grow(border().x, border().y);
		return r;
	}

	public void figureInvalidated(FigureChangeEvent e) {
		Rectangle rect = e.getInvalidatedRectangle();
		rect.grow(border().x, border().y);
		super.figureInvalidated(new FigureChangeEvent(e.getFigure(), rect));
	}

	public Insets connectionInsets() {
		Insets i = super.connectionInsets();
		i.top -= 3;
		i.bottom -= 3;
		i.left -= 3;
		i.right -= 3;
		return i;
	}
}
```

File: CH.ifa.draw.figures.RectangleFigure
```java

package CH.ifa.draw.figures;

import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Vector;

import CH.ifa.draw.standard.BoxHandleKit;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public class RectangleFigure extends AttributeFigure {

	private Rectangle   fDisplayBox;

	private static final long serialVersionUID = 184722075881789163L;
	private int rectangleFigureSerializedDataVersion = 1;

	public RectangleFigure() {
		this(new Point(0,0), new Point(0,0));
	}

	public RectangleFigure(Point origin, Point corner) {
		basicDisplayBox(origin,corner);
	}

	public void basicDisplayBox(Point origin, Point corner) {
		fDisplayBox = new Rectangle(origin);
		fDisplayBox.add(corner);
	}

	public Vector handles() {
		Vector handles = new Vector();
		BoxHandleKit.addHandles(this, handles);
		return handles;
	}

	public Rectangle displayBox() {
		return new Rectangle(
			fDisplayBox.x,
			fDisplayBox.y,
			fDisplayBox.width,
			fDisplayBox.height);
	}

	protected void basicMoveBy(int x, int y) {
		fDisplayBox.translate(x,y);
	}

	public void drawBackground(Graphics g) {
		Rectangle r = displayBox();
		g.fillRect(r.x, r.y, r.width, r.height);
	}

	public void drawFrame(Graphics g) {
		Rectangle r = displayBox();
		g.drawRect(r.x, r.y, r.width-1, r.height-1);
	}


	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fDisplayBox.x);
		dw.writeInt(fDisplayBox.y);
		dw.writeInt(fDisplayBox.width);
		dw.writeInt(fDisplayBox.height);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fDisplayBox = new Rectangle(
			dr.readInt(),
			dr.readInt(),
			dr.readInt(),
			dr.readInt());
	}

}
```

File: CH.ifa.draw.figures.ScribbleTool
```java

package CH.ifa.draw.figures;

import java.awt.event.MouseEvent;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.standard.AbstractTool;

public class ScribbleTool extends AbstractTool {

	private PolyLineFigure  fScribble;
	private int             fLastX, fLastY;

	public ScribbleTool(DrawingView view) {
		super(view);
	}

	public void activate() {
		super.activate();
		fScribble = null;
	}

	public void deactivate() {
		super.deactivate();
		if (fScribble != null) {
			if (fScribble.size().width < 4 || fScribble.size().height < 4)
				drawing().remove(fScribble);
		}
	}

	private void point(int x, int y) {
		if (fScribble == null) {
			fScribble = new PolyLineFigure(x, y);
			view().add(fScribble);
		} else if (fLastX != x || fLastY != y)
			fScribble.addPoint(x, y);

		fLastX = x;
		fLastY = y;
	}

	public void mouseDown(MouseEvent e, int x, int y) {
		if (e.getClickCount() >= 2) {
			fScribble = null;
			editor().toolDone();
		}
		else {
			point(e.getX(), e.getY());
		}
	}

	public void mouseDrag(MouseEvent e, int x, int y) {
		if (fScribble != null)
			point(e.getX(), e.getY());
	}
}
```

File: CH.ifa.draw.figures.LineFigure
```java

package CH.ifa.draw.figures;

import java.awt.Point;

public  class LineFigure extends PolyLineFigure {

	private static final long serialVersionUID = 511503575249212371L;
	private int lineFigureSerializedDataVersion = 1;

	public LineFigure() {
		addPoint(0, 0);
		addPoint(0, 0);
	}

	public Point startPoint() {
		return pointAt(0);
	}

	public Point endPoint() {
		return pointAt(1);
	}

	public void  startPoint(int x, int y) {
		setPointAt(new Point(x,y), 0);
	}

	public void  endPoint(int x, int y) {
		setPointAt(new Point(x,y), 1);
	}

	public void setPoints(Point start, Point end) {
		setPointAt(start, 0);
		setPointAt(end, 1);
	}

	public void basicDisplayBox(Point origin, Point corner) {
		setPoints(origin, corner);
	}

}
```

File: CH.ifa.draw.figures.ImageFigure
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.ImageObserver;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Vector;

import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.standard.BoxHandleKit;
import CH.ifa.draw.util.Iconkit;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public  class ImageFigure
		extends AttributeFigure implements ImageObserver {

	private String   fFileName;
	private transient Image fImage;
	private Rectangle fDisplayBox;
	private static final long serialVersionUID = 148012030121282439L;
	private int imageFigureSerializedDataVersion = 1;

	public ImageFigure() {
		fFileName = null;
		fImage = null;
		fDisplayBox = null;
	}

	public ImageFigure(Image image, String fileName, Point origin) {
		fFileName = fileName;
		fImage = image;
		fDisplayBox = new Rectangle(origin.x, origin.y, 0, 0);
		fDisplayBox.width = fImage.getWidth(this);
		fDisplayBox.height = fImage.getHeight(this);
	}

	public void basicDisplayBox(Point origin, Point corner) {
		fDisplayBox = new Rectangle(origin);
		fDisplayBox.add(corner);
	}

	public Vector handles() {
		Vector handles = new Vector();
		BoxHandleKit.addHandles(this, handles);
		return handles;
	}

	public Rectangle displayBox() {
		return new Rectangle(
			fDisplayBox.x,
			fDisplayBox.y,
			fDisplayBox.width,
			fDisplayBox.height);
	}

	protected void basicMoveBy(int x, int y) {
		fDisplayBox.translate(x,y);
	}

	public void draw(Graphics g) {
		if (fImage == null)
			fImage = Iconkit.instance().getImage(fFileName);
		if (fImage != null)
			g.drawImage(fImage, fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height, this);
		else
			drawGhost(g);
	}

	private void drawGhost(Graphics g) {
		g.setColor(Color.gray);
		g.fillRect(fDisplayBox.x, fDisplayBox.y, fDisplayBox.width, fDisplayBox.height);
	}

	public boolean imageUpdate(Image img, int flags, int x, int y, int w, int h) {
	    if ((flags & (FRAMEBITS|ALLBITS)) != 0) {
	        invalidate();
	        if (listener() != null)
	            listener().figureRequestUpdate(new FigureChangeEvent(this));
	    }
	    return (flags & (ALLBITS|ABORT)) == 0;
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fDisplayBox.x);
		dw.writeInt(fDisplayBox.y);
		dw.writeInt(fDisplayBox.width);
		dw.writeInt(fDisplayBox.height);
		dw.writeString(fFileName);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fDisplayBox = new Rectangle(
			dr.readInt(),
			dr.readInt(),
			dr.readInt(),
			dr.readInt());
		fFileName = dr.readString();
		Iconkit.instance().registerImage(fFileName);
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();
		Iconkit.instance().registerImage(fFileName);
		fImage = null;
	}
}
```

File: CH.ifa.draw.figures.LineDecoration
```java

package CH.ifa.draw.figures;

import java.awt.Graphics;
import java.io.Serializable;

import CH.ifa.draw.util.Storable;

public interface LineDecoration
				extends Storable, Cloneable, Serializable {

	public abstract void draw(Graphics g, int x1, int y1, int x2, int y2);
}
```

File: CH.ifa.draw.figures.ElbowConnection
```java

package CH.ifa.draw.figures;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.Vector;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.ChangeConnectionEndHandle;
import CH.ifa.draw.standard.ChangeConnectionStartHandle;
import CH.ifa.draw.standard.NullHandle;
import CH.ifa.draw.util.Geom;

public  class ElbowConnection extends LineConnection {

	private static final long serialVersionUID = 2193968743082078559L;
	private int elbowConnectionSerializedDataVersion = 1;

	public ElbowConnection() {
		super();
	}

	public void updateConnection() {
		super.updateConnection();
		updatePoints();
	}

	public void layoutConnection() {
	}

	public Vector handles() {
		Vector handles = new Vector(fPoints.size()*2);
		handles.addElement(new ChangeConnectionStartHandle(this));
		for (int i = 1; i < fPoints.size()-1; i++)
			handles.addElement(new NullHandle(this, locator(i)));
		handles.addElement(new ChangeConnectionEndHandle(this));
		for (int i = 0; i < fPoints.size()-1; i++)
			handles.addElement(new ElbowHandle(this, i));
		return handles;
	}

	public Locator connectedTextLocator(Figure f) {
		return new ElbowTextLocator();
	}

	protected void updatePoints() {
		willChange();
		Point start = startPoint();
		Point end = endPoint();
		fPoints.removeAllElements();
		fPoints.addElement(start);

		if (start.x == end.x || start.y == end.y) {
			fPoints.addElement(end);
		}
		else {
			Rectangle r1 = start().owner().displayBox();
			Rectangle r2 = end().owner().displayBox();

			int x1, y1, x2, y2;
			int dir = Geom.direction(r1.x + r1.width/2, r1.y + r1.height/2,
						r2.x + r2.width/2, r2.y + r2.height/2);
			if (dir == Geom.NORTH || dir == Geom.SOUTH) {
				fPoints.addElement(new Point(start.x, (start.y + end.y)/2));
				fPoints.addElement(new Point(end.x, (start.y + end.y)/2));
			}
			else {
				fPoints.addElement(new Point((start.x + end.x)/2, start.y));
				fPoints.addElement(new Point((start.x + end.x)/2, end.y));
			}
			fPoints.addElement(end);
		}
		changed();
	}
}

```

File: CH.ifa.draw.figures.FigureAttributes
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.io.IOException;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.Hashtable;

import CH.ifa.draw.util.Storable;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public  class   FigureAttributes
		extends Object
		implements Cloneable, Serializable {

	private Hashtable fMap;

	private static final long serialVersionUID = -6886355144423666716L;
	private int figureAttributesSerializedDataVersion = 1;

	public FigureAttributes() {
		fMap = new Hashtable();
	}

	public Object get(String name) {
		return fMap.get(name);
	}

	public void set(String name, Object value) {
		fMap.put(name, value);
	}

	public boolean hasDefined(String name) {
		return fMap.containsKey(name);
	}

   public Object clone() {
		try {
			FigureAttributes a = (FigureAttributes) super.clone();
			a.fMap = (Hashtable) fMap.clone();
			return a;
		} catch (CloneNotSupportedException e) {
	        throw new InternalError();
		}
	}

	public void read(StorableInput dr) throws IOException {
		String s = dr.readString();
		if (!s.toLowerCase().equals("attributes"))
			throw new IOException("Attributes expected");

		fMap = new Hashtable();
		int size = dr.readInt();
		for (int i=0; i<size; i++) {
			String key = dr.readString();
			String valtype = dr.readString();
			Object val = null;
			if (valtype.equals("Color"))
				val = new Color(dr.readInt(), dr.readInt(), dr.readInt());
			else if (valtype.equals("Boolean"))
				val = new Boolean(dr.readString());
			else if (valtype.equals("String"))
				val = dr.readString();
			else if (valtype.equals("Int"))
				val = new Integer(dr.readInt());
			else if (valtype.equals("Storable"))
				val = dr.readStorable();
			else if (valtype.equals("UNKNOWN"))
				continue;

			fMap.put(key,val);
		}
	}

	public void write(StorableOutput dw) {
		dw.writeString("attributes");

		dw.writeInt(fMap.size());   // number of attributes
		Enumeration k = fMap.keys();
		while (k.hasMoreElements()) {
			String s = (String) k.nextElement();
			dw.writeString(s);
			Object v = fMap.get(s);
			if (v instanceof String) {
				dw.writeString("String");
				dw.writeString((String) v);
			} else if (v instanceof Color) {
				dw.writeString("Color");
				dw.writeInt(((Color)v).getRed());
				dw.writeInt(((Color)v).getGreen());
				dw.writeInt(((Color)v).getBlue());
			} else if (v instanceof Boolean) {
				dw.writeString("Boolean");
				if (((Boolean)v).booleanValue())
					dw.writeString("TRUE");
				else
					dw.writeString("FALSE");
			} else if (v instanceof Integer) {
				dw.writeString("Int");
				dw.writeInt(((Integer)v).intValue());
			} else if (v instanceof Storable) {
				dw.writeString("Storable");
				dw.writeStorable((Storable)v);
			} else {
				System.out.println(v);
				dw.writeString("UNKNOWN");
			}
		}
	}
}

```

File: CH.ifa.draw.figures.GroupCommand
```java

package CH.ifa.draw.figures;

import java.util.Vector;

import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.util.Command;

public  class GroupCommand extends Command {

	private DrawingView fView;

	public GroupCommand(String name, DrawingView view) {
		super(name);
		fView = view;
	}

	public void execute() {
		Vector selected = fView.selectionZOrdered();
		Drawing drawing = fView.drawing();
		if (selected.size() > 0) {
			fView.clearSelection();
			drawing.orphanAll(selected);

			GroupFigure group = new GroupFigure();
			group.addAll(selected);
			fView.addToSelection(drawing.add(group));
		}
		fView.checkDamage();
	}

	public boolean isExecutable() {
		return fView.selectionCount() > 0;
	}

}


```

File: CH.ifa.draw.figures.TextFigure
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Vector;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.framework.FigureChangeListener;
import CH.ifa.draw.standard.NullHandle;
import CH.ifa.draw.standard.OffsetLocator;
import CH.ifa.draw.standard.RelativeLocator;
import CH.ifa.draw.standard.TextHolder;
import CH.ifa.draw.util.ColorMap;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public  class TextFigure
		extends AttributeFigure
		implements FigureChangeListener, TextHolder {

	private int               fOriginX;
	private int               fOriginY;

	transient private boolean fSizeIsDirty = true;
	transient private int     fWidth;
	transient private int     fHeight;

	private String  fText;
	private Font    fFont;
	private boolean fIsReadOnly;

	private Figure  fObservedFigure = null;
	private OffsetLocator fLocator = null;

	private static String fgCurrentFontName  = "Helvetica";
	private static int    fgCurrentFontSize  = 12;
	private static int    fgCurrentFontStyle = Font.PLAIN;

	private static final long serialVersionUID = 4599820785949456124L;
	private int textFigureSerializedDataVersion = 1;

	public TextFigure() {
		fOriginX = 0;
		fOriginY = 0;
		fFont = createCurrentFont();
		setAttribute("FillColor", ColorMap.color("None"));
		fText = new String("");
		fSizeIsDirty = true;
	}

	public void moveBy(int x, int y) {
		willChange();
		basicMoveBy(x, y);
		if (fLocator != null)
			fLocator.moveBy(x, y);
		changed();
	}

	protected void basicMoveBy(int x, int y) {
		fOriginX += x;
		fOriginY += y;
	}

	public void basicDisplayBox(Point newOrigin, Point newCorner) {
		fOriginX = newOrigin.x;
		fOriginY = newOrigin.y;
	}

	public Rectangle displayBox() {
		Dimension extent = textExtent();
		return new Rectangle(fOriginX, fOriginY, extent.width, extent.height);
	}

	public Rectangle textDisplayBox() {
		return displayBox();
	}

	public boolean readOnly() {
		return fIsReadOnly;
	}

	public void setReadOnly(boolean isReadOnly) {
		fIsReadOnly = isReadOnly;
	}

	public Font getFont() {
		return fFont;
	}

	public void setFont(Font newFont) {
		willChange();
		fFont = newFont;
		markDirty();
		changed();
	}

	public void changed() {
		super.changed();
		updateLocation();
	}

	public Object getAttribute(String name) {
		Font font = getFont();
		if (name.equals("FontSize"))
			return new Integer(font.getSize());
		if (name.equals("FontStyle"))
			return new Integer(font.getStyle());
		if (name.equals("FontName"))
			return font.getName();
		return super.getAttribute(name);
	}

	public void setAttribute(String name, Object value) {
		Font font = getFont();
		if (name.equals("FontSize")) {
			Integer s = (Integer)value;
			setFont(new Font(font.getName(), font.getStyle(), s.intValue()) );
		}
		else if (name.equals("FontStyle")) {
			Integer s = (Integer)value;
			int style = font.getStyle();
			if (s.intValue() == Font.PLAIN)
				style = Font.PLAIN;
			else
				style = style ^ s.intValue();
			setFont(new Font(font.getName(), style, font.getSize()) );
		}
		else if (name.equals("FontName")) {
			String n = (String)value;
			setFont(new Font(n, font.getStyle(), font.getSize()) );
		}
		else
			super.setAttribute(name, value);
	}

	public String getText() {
		return fText;
	}

	public void setText(String newText) {
		if (!newText.equals(fText)) {
			willChange();
			fText = new String(newText);
			markDirty();
			changed();
		}
	}

	public boolean acceptsTyping() {
		return !fIsReadOnly;
	}

	public void drawBackground(Graphics g) {
		Rectangle r = displayBox();
		g.fillRect(r.x, r.y, r.width, r.height);
	}

	public void drawFrame(Graphics g) {
		g.setFont(fFont);
		g.setColor((Color) getAttribute("TextColor"));
		FontMetrics metrics = g.getFontMetrics(fFont);
		g.drawString(fText, fOriginX, fOriginY + metrics.getAscent());
	}

	private Dimension textExtent() {
		if (!fSizeIsDirty)
			return new Dimension(fWidth, fHeight);
		FontMetrics metrics = Toolkit.getDefaultToolkit().getFontMetrics(fFont);
		fWidth = metrics.stringWidth(fText);
		fHeight = metrics.getHeight();
		fSizeIsDirty = false;
		return new Dimension(metrics.stringWidth(fText), metrics.getHeight());
	}

	private void markDirty() {
		fSizeIsDirty = true;
	}

	public int overlayColumns() {
		int length = getText().length();
		int columns = 20;
		if (length != 0)
			columns = getText().length()+ 3;
		return columns;
	}

	public Vector handles() {
		Vector handles = new Vector();
		handles.addElement(new NullHandle(this, RelativeLocator.northWest()));
		handles.addElement(new NullHandle(this, RelativeLocator.northEast()));
		handles.addElement(new NullHandle(this, RelativeLocator.southEast()));
		handles.addElement(new FontSizeHandle(this, RelativeLocator.southWest()));
		return handles;
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fOriginX);
		dw.writeInt(fOriginY);
		dw.writeString(fText);
		dw.writeString(fFont.getName());
		dw.writeInt(fFont.getStyle());
		dw.writeInt(fFont.getSize());
		dw.writeBoolean(fIsReadOnly);
		dw.writeStorable(fObservedFigure);
		dw.writeStorable(fLocator);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		markDirty();
		fOriginX = dr.readInt();
		fOriginY = dr.readInt();
		fText = dr.readString();
		fFont = new Font(dr.readString(), dr.readInt(), dr.readInt());
		fIsReadOnly = dr.readBoolean();

		fObservedFigure = (Figure)dr.readStorable();
		if (fObservedFigure != null)
			fObservedFigure.addFigureChangeListener(this);
		fLocator = (OffsetLocator)dr.readStorable();
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		if (fObservedFigure != null)
			fObservedFigure.addFigureChangeListener(this);
		markDirty();
	}

	public void connect(Figure figure) {
		if (fObservedFigure != null)
			fObservedFigure.removeFigureChangeListener(this);

		fObservedFigure = figure;
		fLocator = new OffsetLocator(figure.connectedTextLocator(this));
		fObservedFigure.addFigureChangeListener(this);
		updateLocation();
	}

	public void figureChanged(FigureChangeEvent e) {
		updateLocation();
	}

	public void figureRemoved(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestRemove(new FigureChangeEvent(this));
	}

	public void figureRequestRemove(FigureChangeEvent e) {}
	public void figureInvalidated(FigureChangeEvent e) {}
	public void figureRequestUpdate(FigureChangeEvent e) {}

	protected void updateLocation() {
		if (fLocator != null) {
			Point p = fLocator.locate(fObservedFigure);
			p.x -= size().width/2 + fOriginX;
			p.y -= size().height/2 + fOriginY;

			if (p.x != 0 || p.y != 0) {
				willChange();
				basicMoveBy(p.x, p.y);
				changed();
			}
		}
	}

	public void release() {
		super.release();
		if (fObservedFigure != null)
			fObservedFigure.removeFigureChangeListener(this);
	}

	public void disconnect() {
		fObservedFigure.removeFigureChangeListener(this);
		fObservedFigure = null;
		fLocator = null;
	}


	static public Font createCurrentFont() {
		return new Font(fgCurrentFontName, fgCurrentFontStyle, fgCurrentFontSize);
	}

	static public void setCurrentFontName(String name) {
		fgCurrentFontName = name;
	}

	static public void setCurrentFontSize(int size) {
		fgCurrentFontSize = size;
	}

	static public void setCurrentFontStyle(int style) {
		fgCurrentFontStyle = style;
	}
}
```

File: CH.ifa.draw.figures.PolyLineConnector
```java

package CH.ifa.draw.figures;

import java.awt.Point;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.ChopBoxConnector;
import CH.ifa.draw.util.Geom;

public class PolyLineConnector extends ChopBoxConnector {

	private static final long serialVersionUID = 6018435940519102865L;

	public PolyLineConnector() {
		super();
	}

	public PolyLineConnector(Figure owner) {
		super(owner);
	}

	protected Point chop(Figure target, Point from) {
		PolyLineFigure p = (PolyLineFigure)owner();
		Point ctr = p.center();
		int cx = -1;
		int cy = -1;
		long len = Long.MAX_VALUE;


		for (int i = 0; i < p.pointCount()-1; i++) {
			Point p1 = p.pointAt(i);
			Point p2 = p.pointAt(i+1);
			Point chop = Geom.intersect(p1.x,
								 p1.y,
								 p2.x,
								 p2.y,
								 from.x,
								 from.y,
								 ctr.x,
								 ctr.y);
			if (chop != null) {
				long cl = Geom.length2(chop.x, chop.y, from.x, from.y);
				if (cl < len) {
					len = cl;
					cx = chop.x;
					cy = chop.y;
				}
			}
		}
		{ // try anyway
			for (int i = 0; i < p.pointCount(); i++) {
				Point pp = p.pointAt(i);
				long l = Geom.length2(pp.x, pp.y, from.x, from.y);
				if (l < len) {
					len = l;
					cx = pp.x;
					cy = pp.y;
				}
			}
		}
		return new Point(cx, cy);
	}
}

```

File: CH.ifa.draw.figures.PolyLineHandle
```java

package CH.ifa.draw.figures;

import java.awt.Point;

import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.LocatorHandle;

public class PolyLineHandle extends LocatorHandle {

	private int fIndex;
	private Point fAnchor;

	public PolyLineHandle(PolyLineFigure owner, Locator l, int index) {
		super(owner, l);
		fIndex = index;
	}

	public void invokeStart(int  x, int  y, DrawingView view) {
		fAnchor = new Point(x, y);
	}

	public void invokeStep (int x, int y, int anchorX, int anchorY, DrawingView view) {
		myOwner().setPointAt(new Point(x, y), fIndex);
	}

	private PolyLineFigure myOwner() {
		return (PolyLineFigure)owner();
	}
}


```

File: CH.ifa.draw.figures.PolyLineLocator
```java

package CH.ifa.draw.figures;

import java.awt.Point;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.AbstractLocator;

class PolyLineLocator extends AbstractLocator {
	int fIndex;

	public PolyLineLocator(int index) {
		fIndex = index;
	}

	public Point locate(Figure owner) {
		PolyLineFigure plf = (PolyLineFigure)owner;
		if (fIndex < plf.pointCount())
			return ((PolyLineFigure)owner).pointAt(fIndex);
		return new Point(0, 0);
	}
}
```

File: CH.ifa.draw.figures.EllipseFigure
```java

package CH.ifa.draw.figures;

import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Vector;

import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.standard.BoxHandleKit;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public class EllipseFigure extends AttributeFigure {

	private Rectangle   fDisplayBox;

	private static final long serialVersionUID = -6856203289355118951L;
	private int ellipseFigureSerializedDataVersion = 1;

	public EllipseFigure() {
		this(new Point(0,0), new Point(0,0));
	}

	public EllipseFigure(Point origin, Point corner) {
		basicDisplayBox(origin,corner);
	}

	public Vector handles() {
		Vector handles = new Vector();
		BoxHandleKit.addHandles(this, handles);
		return handles;
	}

	public void basicDisplayBox(Point origin, Point corner) {
		fDisplayBox = new Rectangle(origin);
		fDisplayBox.add(corner);
	}

	public Rectangle displayBox() {
		return new Rectangle(
			fDisplayBox.x,
			fDisplayBox.y,
			fDisplayBox.width,
			fDisplayBox.height);
	}

	protected void basicMoveBy(int x, int y) {
		fDisplayBox.translate(x,y);
	}

	public void drawBackground(Graphics g) {
		Rectangle r = displayBox();
		g.fillOval(r.x, r.y, r.width, r.height);
	}

	public void drawFrame(Graphics g) {
		Rectangle r = displayBox();
		g.drawOval(r.x, r.y, r.width-1, r.height-1);
	}

	public Insets connectionInsets() {
		Rectangle r = fDisplayBox;
		int cx = r.width/2;
		int cy = r.height/2;
		return new Insets(cy, cx, cy, cx);
	}

	public Connector connectorAt(int x, int y) {
		return new ChopEllipseConnector(this);
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fDisplayBox.x);
		dw.writeInt(fDisplayBox.y);
		dw.writeInt(fDisplayBox.width);
		dw.writeInt(fDisplayBox.height);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fDisplayBox = new Rectangle(
			dr.readInt(),
			dr.readInt(),
			dr.readInt(),
			dr.readInt());
	}
}
```

File: CH.ifa.draw.figures.GroupHandle
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.Locator;
import CH.ifa.draw.standard.NullHandle;

final class GroupHandle extends NullHandle {

	public GroupHandle(Figure owner, Locator locator) {
		super(owner, locator);
	}

	public void draw(Graphics g) {
		Rectangle r = displayBox();

		g.setColor(Color.black);
		g.drawRect(r.x, r.y, r.width, r.height);
		r.grow(-1,-1);
		g.setColor(Color.white);
		g.drawRect(r.x, r.y, r.width, r.height);
	}
}
```

File: CH.ifa.draw.figures.LineConnection
```java

package CH.ifa.draw.figures;

import java.awt.Point;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Vector;

import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.framework.FigureChangeEvent;
import CH.ifa.draw.standard.ChangeConnectionEndHandle;
import CH.ifa.draw.standard.ChangeConnectionStartHandle;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public  class LineConnection extends PolyLineFigure implements ConnectionFigure {

	protected Connector    fStart = null;
	protected Connector    fEnd = null;

	private static final long serialVersionUID = 6883731614578414801L;
	private int lineConnectionSerializedDataVersion = 1;

	public LineConnection() {
		super(4);
		setStartDecoration(new ArrowTip());
		setEndDecoration(new ArrowTip());
	}

	public boolean canConnect() {
		return false;
	}

	protected void basicMoveBy(int dx, int dy) {
		for (int i = 1; i < fPoints.size()-1; i++)
			((Point) fPoints.elementAt(i)).translate(dx, dy);

		updateConnection(); // make sure that we are still connected
	}

	public void connectStart(Connector start) {
		fStart = start;
		startFigure().addFigureChangeListener(this);
	}

	public void connectEnd(Connector end) {
		fEnd = end;
		endFigure().addFigureChangeListener(this);
		handleConnect(startFigure(), endFigure());
	}

	public void disconnectStart() {
		startFigure().removeFigureChangeListener(this);
		fStart = null;
	}

	public void disconnectEnd() {
		handleDisconnect(startFigure(), endFigure());
		endFigure().removeFigureChangeListener(this);
		fEnd = null;
	}

	public boolean connectsSame(ConnectionFigure other) {
		return other.start() == start() && other.end() == end();
	}

	protected void handleDisconnect(Figure start, Figure end) {}

	protected void handleConnect(Figure start, Figure end) {}

	public Figure startFigure() {
		if (start() != null)
			return start().owner();
		return null;
	}

	public Figure endFigure() {
		if (end() != null)
			return end().owner();
		return null;
	}

	public Connector start() {
		return fStart;
	}

	public Connector end() {
		return fEnd;
	}

	public boolean canConnect(Figure start, Figure end) {
		return true;
	}

	public void startPoint(int x, int y) {
		willChange();
		if (fPoints.size() == 0)
			fPoints.addElement(new Point(x, y));
		else
			fPoints.setElementAt(new Point(x, y), 0);
		changed();
	}

	public void endPoint(int x, int y) {
		willChange();
		if (fPoints.size() < 2)
			fPoints.addElement(new Point(x, y));
		else
			fPoints.setElementAt(new Point(x, y), fPoints.size()-1);
		changed();
	}

	public Point startPoint(){
		Point p = (Point)fPoints.firstElement();
		return new Point(p.x, p.y);
	}

	public Point endPoint() {
		Point p = (Point)fPoints.lastElement();
		return new Point(p.x, p.y);
	}

	public Vector handles() {
		Vector handles = new Vector(fPoints.size());
		handles.addElement(new ChangeConnectionStartHandle(this));
		for (int i = 1; i < fPoints.size()-1; i++)
			handles.addElement(new PolyLineHandle(this, locator(i), i));
		handles.addElement(new ChangeConnectionEndHandle(this));
		return handles;
	}

	public void setPointAt(Point p, int i) {
		super.setPointAt(p, i);
		layoutConnection();
	}

	public void insertPointAt(Point p, int i) {
		super.insertPointAt(p, i);
		layoutConnection();
	}

	public void removePointAt(int i) {
		super.removePointAt(i);
		layoutConnection();
	}

	public void updateConnection() {
		if (fStart != null) {
			Point start = fStart.findStart(this);
			startPoint(start.x, start.y);
		}
		if (fEnd != null) {
			Point end = fEnd.findEnd(this);
			endPoint(end.x, end.y);
		}
	}

	public void layoutConnection() {
		updateConnection();
	}

	public void figureChanged(FigureChangeEvent e) {
		updateConnection();
	}

	public void figureRemoved(FigureChangeEvent e) {
		if (listener() != null)
			listener().figureRequestRemove(new FigureChangeEvent(this));
	}

	public void figureRequestRemove(FigureChangeEvent e) {}
	public void figureInvalidated(FigureChangeEvent e) {}
	public void figureRequestUpdate(FigureChangeEvent e) {}

	public void release() {
		super.release();
		handleDisconnect(startFigure(), endFigure());
		if (fStart != null) startFigure().removeFigureChangeListener(this);
		if (fEnd   != null) endFigure().removeFigureChangeListener(this);
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeStorable(fStart);
		dw.writeStorable(fEnd);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		Connector start = (Connector)dr.readStorable();
		if (start != null)
			connectStart(start);
		Connector end = (Connector)dr.readStorable();
		if (end != null)
			connectEnd(end);
		if (start != null && end != null)
			updateConnection();
	}

	private void readObject(ObjectInputStream s)
		throws ClassNotFoundException, IOException {

		s.defaultReadObject();

		if (fStart != null)
			connectStart(fStart);
		if (fEnd != null)
			connectEnd(fEnd);
	}
}
```

File: CH.ifa.draw.figures.RoundRectangleFigure
```java

package CH.ifa.draw.figures;

import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.IOException;
import java.util.Vector;

import CH.ifa.draw.framework.Connector;
import CH.ifa.draw.standard.BoxHandleKit;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public  class RoundRectangleFigure extends AttributeFigure {

	private Rectangle   fDisplayBox;
	private int         fArcWidth;
	private int         fArcHeight;
	private static final int DEFAULT_ARC = 8;

	private static final long serialVersionUID = 7907900248924036885L;
	private int roundRectangleSerializedDataVersion = 1;

	public RoundRectangleFigure() {
		this(new Point(0,0), new Point(0,0));
		fArcWidth = fArcHeight = DEFAULT_ARC;
	}

	public RoundRectangleFigure(Point origin, Point corner) {
		basicDisplayBox(origin,corner);
		fArcWidth = fArcHeight = DEFAULT_ARC;
	}

	public void basicDisplayBox(Point origin, Point corner) {
		fDisplayBox = new Rectangle(origin);
		fDisplayBox.add(corner);
	}

	public void setArc(int width, int height) {
		willChange();
		fArcWidth = width;
		fArcHeight = height;
		changed();
	}

	public Point getArc() {
		return new Point(fArcWidth, fArcHeight);
	}

	public Vector handles() {
		Vector handles = new Vector();
		BoxHandleKit.addHandles(this, handles);

		handles.addElement(new RadiusHandle(this));

		return handles;
	}

	public Rectangle displayBox() {
		return new Rectangle(
			fDisplayBox.x,
			fDisplayBox.y,
			fDisplayBox.width,
			fDisplayBox.height);
	}

	protected void basicMoveBy(int x, int y) {
		fDisplayBox.translate(x,y);
	}

	public void drawBackground(Graphics g) {
		Rectangle r = displayBox();
		g.fillRoundRect(r.x, r.y, r.width, r.height, fArcWidth, fArcHeight);
	}

	public void drawFrame(Graphics g) {
		Rectangle r = displayBox();
		g.drawRoundRect(r.x, r.y, r.width-1, r.height-1, fArcWidth, fArcHeight);
	}

	public Insets connectionInsets() {
		return new Insets(fArcHeight/2, fArcWidth/2, fArcHeight/2, fArcWidth/2);
	}

	public Connector connectorAt(int x, int y) {
		return new ShortestDistanceConnector(this); // just for demo purposes
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		dw.writeInt(fDisplayBox.x);
		dw.writeInt(fDisplayBox.y);
		dw.writeInt(fDisplayBox.width);
		dw.writeInt(fDisplayBox.height);
		dw.writeInt(fArcWidth);
		dw.writeInt(fArcHeight);
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		fDisplayBox = new Rectangle(
			dr.readInt(),
			dr.readInt(),
			dr.readInt(),
			dr.readInt());
		fArcWidth = dr.readInt();
		fArcHeight = dr.readInt();
	}

}
```

File: CH.ifa.draw.figures.ChopEllipseConnector
```java

package CH.ifa.draw.figures;

import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.ChopBoxConnector;
import CH.ifa.draw.util.Geom;

public class ChopEllipseConnector extends ChopBoxConnector {

	private static final long serialVersionUID = -3165091511154766610L;

	public ChopEllipseConnector() {
	}

	public ChopEllipseConnector(Figure owner) {
		super(owner);
	}

	protected Point chop(Figure target, Point from) {
		Rectangle r = target.displayBox();
		double angle = Geom.pointToAngle(r, from);
	    return Geom.ovalAngleToPoint(r, angle);
	}
}

```

File: CH.ifa.draw.figures.AttributeFigure
```java

package CH.ifa.draw.figures;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.io.IOException;

import CH.ifa.draw.standard.AbstractFigure;
import CH.ifa.draw.util.ColorMap;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;

public abstract class AttributeFigure extends AbstractFigure {

	private FigureAttributes        fAttributes;

	private static FigureAttributes fgDefaultAttributes = null;

	private static final long serialVersionUID = -10857585979273442L;
	private int attributeFigureSerializedDataVersion = 1;

	protected AttributeFigure() { }

	public void draw(Graphics g) {
		Color fill = getFillColor();
		if (!ColorMap.isTransparent(fill)) {
			g.setColor(fill);
			drawBackground(g);
		}
		Color frame = getFrameColor();
		if (!ColorMap.isTransparent(frame)) {
			g.setColor(frame);
			drawFrame(g);
		}
	}

	protected void drawBackground(Graphics g) {
	}

	protected void drawFrame(Graphics g) {
	}

	public Color getFillColor() {
		return (Color) getAttribute("FillColor");
	}

	public Color getFrameColor() {
		return (Color) getAttribute("FrameColor");
	}


	private static void initializeAttributes() {
		fgDefaultAttributes = new FigureAttributes();
		fgDefaultAttributes.set("FrameColor", Color.black);
		fgDefaultAttributes.set("FillColor",  new Color(0x70DB93));
		fgDefaultAttributes.set("TextColor",  Color.black);
		fgDefaultAttributes.set("ArrowMode",  new Integer(0));
		fgDefaultAttributes.set("FontName",  "Helvetica");
		fgDefaultAttributes.set("FontSize",   new Integer(12));
		fgDefaultAttributes.set("FontStyle",  new Integer(Font.PLAIN));
	}

	public static Object getDefaultAttribute(String name) {
		if (fgDefaultAttributes == null)
			initializeAttributes();
		return fgDefaultAttributes.get(name);
	}

	public Object getAttribute(String name) {
		if (fAttributes != null) {
			if (fAttributes.hasDefined(name))
				return fAttributes.get(name);
		}
		return getDefaultAttribute(name);
	}

	public void setAttribute(String name, Object value) {
		if (fAttributes == null)
			fAttributes = new FigureAttributes();
		fAttributes.set(name, value);
		changed();
	}

	public void write(StorableOutput dw) {
		super.write(dw);
		if (fAttributes == null)
			dw.writeString("no_attributes");
		else {
			dw.writeString("attributes");
			fAttributes.write(dw);
		}
	}

	public void read(StorableInput dr) throws IOException {
		super.read(dr);
		String s = dr.readString();
		if (s.toLowerCase().equals("attributes")) {
			fAttributes = new FigureAttributes();
			fAttributes.read(dr);
		}
	}
}
```

File: CH.ifa.draw.figures.ShortestDistanceConnector
```java

package CH.ifa.draw.figures;

import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;

import CH.ifa.draw.framework.ConnectionFigure;
import CH.ifa.draw.framework.Figure;
import CH.ifa.draw.standard.AbstractConnector;
import CH.ifa.draw.util.Geom;

public class ShortestDistanceConnector extends AbstractConnector {

	private static final long serialVersionUID = -2273446020593433887L;

	public ShortestDistanceConnector() { // only used for Storable implementation
		super();
	}

	public ShortestDistanceConnector(Figure owner) {
		super(owner);
	}

	public Point findStart(ConnectionFigure connection) {
		return findPoint(connection, true);
	}

	public Point findEnd(ConnectionFigure connection) {
		return findPoint(connection, false);
	}

	protected Point findPoint(ConnectionFigure connection, boolean getStart) {
		Figure startFigure = connection.start().owner();
		Figure endFigure = connection.end().owner();

		Rectangle r1 = startFigure.displayBox();
		Rectangle r2 = endFigure.displayBox();

		Insets i1 = startFigure.connectionInsets();
		Insets i2 = endFigure.connectionInsets();

		Point p1, p2;
		Point start = null, end = null, s = null, e = null;
		long len2 = Long.MAX_VALUE, l2;
		int x1, x2, y1, y2; // connection points
		int xmin, xmax, ymin, ymax;

		int r1x, r1width, r2x, r2width, r1y, r1height, r2y, r2height;
		r1x = r1.x + i1.left;
		r1width = r1.width - i1.left - i1.right-1;
		r2x = r2.x + i2.left;
		r2width = r2.width - i2.left - i2.right-1;

		if (r1x + r1width < r2x) {
			x1 = r1x + r1width;
			x2 = r2x;
		} else if (r1x > r2x + r2width) {
			x1 = r1x;
			x2 = r2x + r2width;
		} else {
			xmax = Math.max(r1x, r2x);
			xmin = Math.min(r1x+r1width, r2x+r2width);
			x1 = x2 = (xmax + xmin) /2;
		}

		r1y = r1.y + i1.top;
		r1height = r1.height - i1.top - i1.bottom-1;
		r2y = r2.y + i2.top;
		r2height = r2.height - i2.top - i2.bottom-1;

		if (r1y + r1height < r2y) {
			y1 = r1y + r1height;
			y2 = r2y;
		} else if (r1y > r2y + r2height) {
			y1 = r1y;
			y2 = r2y + r2height;
		} else {
			ymax = Math.max(r1y, r2y);
			ymin = Math.min(r1y+r1height, r2y+r2height);
			y1 = y2 = (ymax + ymin) /2;
		}
		for (int i = 0; i < 4; i++) {
			switch(i) {
			case 0:
				p1 = Geom.east(r1);
				p2 = Geom.west(r2);
				s = new Point(p1.x, y1);
				e = new Point(p2.x, y2);
				break;
			case 1:
				p1 = Geom.west(r1);
				p2 = Geom.east(r2);
				s = new Point(p1.x, y1);
				e = new Point(p2.x, y2);
				break;
			case 2:
				p1 = Geom.north(r1);
				p2 = Geom.south(r2);
				s = new Point(x1, p1.y);
				e = new Point(x2, p2.y);
				break;
			case 3:
				p1 = Geom.south(r1);
				p2 = Geom.north(r2);
				s = new Point(x1, p1.y);
				e = new Point(x2, p2.y);
				break;
			}
			l2 = Geom.length2(s.x, s.y, e.x, e.y);
			if (l2 < len2) {
				start = s;
				end = e;
				len2 = l2;
			}
		}
		if (getStart)
			return start;
		return end;
	}

}

```

File: CH.ifa.draw.application.DrawApplication
```java

package CH.ifa.draw.application;

import java.awt.Adjustable;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FileDialog;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Menu;
import java.awt.MenuBar;
import java.awt.MenuItem;
import java.awt.MenuShortcut;
import java.awt.Panel;
import java.awt.Point;
import java.awt.PrintJob;
import java.awt.ScrollPane;
import java.awt.TextField;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;

import CH.ifa.draw.figures.GroupCommand;
import CH.ifa.draw.figures.PolyLineFigure;
import CH.ifa.draw.figures.UngroupCommand;
import CH.ifa.draw.framework.Drawing;
import CH.ifa.draw.framework.DrawingEditor;
import CH.ifa.draw.framework.DrawingView;
import CH.ifa.draw.framework.Tool;
import CH.ifa.draw.standard.AlignCommand;
import CH.ifa.draw.standard.BringToFrontCommand;
import CH.ifa.draw.standard.BufferedUpdateStrategy;
import CH.ifa.draw.standard.ChangeAttributeCommand;
import CH.ifa.draw.standard.CopyCommand;
import CH.ifa.draw.standard.CutCommand;
import CH.ifa.draw.standard.DeleteCommand;
import CH.ifa.draw.standard.DuplicateCommand;
import CH.ifa.draw.standard.PasteCommand;
import CH.ifa.draw.standard.SelectionTool;
import CH.ifa.draw.standard.SendToBackCommand;
import CH.ifa.draw.standard.SimpleUpdateStrategy;
import CH.ifa.draw.standard.StandardDrawing;
import CH.ifa.draw.standard.StandardDrawingView;
import CH.ifa.draw.standard.ToggleGridCommand;
import CH.ifa.draw.standard.ToolButton;
import CH.ifa.draw.util.ColorMap;
import CH.ifa.draw.util.CommandMenu;
import CH.ifa.draw.util.Iconkit;
import CH.ifa.draw.util.PaletteButton;
import CH.ifa.draw.util.PaletteLayout;
import CH.ifa.draw.util.PaletteListener;
import CH.ifa.draw.util.StorableInput;
import CH.ifa.draw.util.StorableOutput;


public class DrawApplication extends Frame implements DrawingEditor,
		PaletteListener {

	private Drawing fDrawing;
	private Tool fTool;
	private Iconkit fIconkit;

	private TextField fStatusLine;
	private StandardDrawingView fView;
	private ToolButton fDefaultToolButton;
	private ToolButton fSelectedToolButton;

	private String fDrawingFilename;
	static String fgUntitled = "untitled";

	private static final String fgDrawPath = "/CH/ifa/draw/";
	public static final String IMAGES = fgDrawPath + "images/";

	public static final int FILE_MENU = 0;
	public static final int EDIT_MENU = 1;
	public static final int ALIGNMENT_MENU = 2;
	public static final int ATTRIBUTES_MENU = 3;

	public DrawApplication() {
		super("JHotDraw");
	}

	public DrawApplication(String title) {
		super(title);
	}


	public void open() {
		fIconkit = new Iconkit(this);
		setLayout(new BorderLayout());

		fView = createDrawingView();
		Component contents = createContents(fView);
		add("Center", contents);

		Panel tools = createToolPalette();
		createTools(tools);
		add("West", tools);

		fStatusLine = createStatusLine();
		add("South", fStatusLine);

		MenuBar mb = new MenuBar();
		createMenus(mb);
		setMenuBar(mb);

		initDrawing();
		Dimension d = defaultSize();
		setSize(d.width, d.height);

		addListeners();

		show();
	}

	protected void addListeners() {
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent event) {
				exit();
			}
		});
	}

	private void initDrawing() {
		fDrawing = createDrawing();
		fDrawingFilename = fgUntitled;
		fView.setDrawing(fDrawing);
		toolDone();
	}

	protected void createMenus(MenuBar mb) {
		mb.add(createFileMenu());
		mb.add(createEditMenu());
		mb.add(createAlignmentMenu());
		mb.add(createAttributesMenu());
		mb.add(createDebugMenu());
	}

	protected Menu createFileMenu() {
		Menu menu = new Menu("File");
		MenuItem mi = new MenuItem("New", new MenuShortcut('n'));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				promptNew();
			}
		});
		menu.add(mi);

		mi = new MenuItem("Open...", new MenuShortcut('o'));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				promptOpen();
			}
		});
		menu.add(mi);

		mi = new MenuItem("Save As...", new MenuShortcut('s'));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				promptSaveAs();
			}
		});
		menu.add(mi);

		mi = new MenuItem("Save As Serialized...");
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				promptSaveAsSerialized();
			}
		});
		menu.add(mi);
		menu.addSeparator();
		mi = new MenuItem("Print...", new MenuShortcut('p'));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				print();
			}
		});
		menu.add(mi);
		menu.addSeparator();
		mi = new MenuItem("Exit");
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				exit();
			}
		});
		menu.add(mi);
		return menu;
	}

	protected Menu createEditMenu() {
		CommandMenu menu = new CommandMenu("Edit");
		menu.add(new CutCommand("Cut", fView), new MenuShortcut('x'));
		menu.add(new CopyCommand("Copy", fView), new MenuShortcut('c'));
		menu.add(new PasteCommand("Paste", fView), new MenuShortcut('v'));
		menu.addSeparator();
		menu.add(new DuplicateCommand("Duplicate", fView),
				new MenuShortcut('d'));
		menu.add(new DeleteCommand("Delete", fView));
		menu.addSeparator();
		menu.add(new GroupCommand("Group", fView));
		menu.add(new UngroupCommand("Ungroup", fView));
		menu.addSeparator();
		menu.add(new SendToBackCommand("Send to Back", fView));
		menu.add(new BringToFrontCommand("Bring to Front", fView));
		return menu;
	}

	protected Menu createAlignmentMenu() {
		CommandMenu menu = new CommandMenu("Align");
		menu.add(new ToggleGridCommand("Toggle Snap to Grid", fView, new Point(
				4, 4)));
		menu.addSeparator();
		menu.add(new AlignCommand("Lefts", fView, AlignCommand.LEFTS));
		menu.add(new AlignCommand("Centers", fView, AlignCommand.CENTERS));
		menu.add(new AlignCommand("Rights", fView, AlignCommand.RIGHTS));
		menu.addSeparator();
		menu.add(new AlignCommand("Tops", fView, AlignCommand.TOPS));
		menu.add(new AlignCommand("Middles", fView, AlignCommand.MIDDLES));
		menu.add(new AlignCommand("Bottoms", fView, AlignCommand.BOTTOMS));
		return menu;
	}

	protected Menu createDebugMenu() {
		Menu menu = new Menu("Debug");

		MenuItem mi = new MenuItem("Simple Update");
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				fView.setDisplayUpdate(new SimpleUpdateStrategy());
			}
		});
		menu.add(mi);

		mi = new MenuItem("Buffered Update");
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				fView.setDisplayUpdate(new BufferedUpdateStrategy());
			}
		});
		menu.add(mi);
		return menu;
	}

	protected Menu createAttributesMenu() {
		Menu menu = new Menu("Attributes");
		menu.add(createColorMenu("Fill Color", "FillColor"));
		menu.add(createColorMenu("Pen Color", "FrameColor"));
		menu.add(createArrowMenu());
		menu.addSeparator();
		menu.add(createFontMenu());
		menu.add(createFontSizeMenu());
		menu.add(createFontStyleMenu());
		menu.add(createColorMenu("Text Color", "TextColor"));
		return menu;
	}

	protected Menu createColorMenu(String title, String attribute) {
		CommandMenu menu = new CommandMenu(title);
		for (int i = 0; i < ColorMap.size(); i++)
			menu.add(new ChangeAttributeCommand(ColorMap.name(i), attribute,
					ColorMap.color(i), fView));
		return menu;
	}

	protected Menu createArrowMenu() {
		CommandMenu menu = new CommandMenu("Arrow");
		menu.add(new ChangeAttributeCommand("none", "ArrowMode", new Integer(
				PolyLineFigure.ARROW_TIP_NONE), fView));
		menu.add(new ChangeAttributeCommand("at Start", "ArrowMode",
				new Integer(PolyLineFigure.ARROW_TIP_START), fView));
		menu.add(new ChangeAttributeCommand("at End", "ArrowMode", new Integer(
				PolyLineFigure.ARROW_TIP_END), fView));
		menu.add(new ChangeAttributeCommand("at Both", "ArrowMode",
				new Integer(PolyLineFigure.ARROW_TIP_BOTH), fView));
		return menu;
	}

	protected Menu createFontMenu() {
		CommandMenu menu = new CommandMenu("Font");
		String fonts[] = Toolkit.getDefaultToolkit().getFontList();
		for (int i = 0; i < fonts.length; i++)
			menu.add(new ChangeAttributeCommand(fonts[i], "FontName", fonts[i],
					fView));
		return menu;
	}

	protected Menu createFontStyleMenu() {
		CommandMenu menu = new CommandMenu("Font Style");
		menu.add(new ChangeAttributeCommand("Plain", "FontStyle", new Integer(
				Font.PLAIN), fView));
		menu.add(new ChangeAttributeCommand("Italic", "FontStyle", new Integer(
				Font.ITALIC), fView));
		menu.add(new ChangeAttributeCommand("Bold", "FontStyle", new Integer(
				Font.BOLD), fView));
		return menu;
	}

	protected Menu createFontSizeMenu() {
		CommandMenu menu = new CommandMenu("Font Size");
		int sizes[] = { 9, 10, 12, 14, 18, 24, 36, 48, 72 };
		for (int i = 0; i < sizes.length; i++) {
			menu.add(new ChangeAttributeCommand(Integer.toString(sizes[i]),
					"FontSize", new Integer(sizes[i]), fView));
		}
		return menu;
	}

	protected Panel createToolPalette() {
		Panel palette = new Panel();
		palette.setBackground(Color.lightGray);
		palette.setLayout(new PaletteLayout(2, new Point(2, 2)));
		return palette;
	}

	protected void createTools(Panel palette) {
		Tool tool = createSelectionTool();

		fDefaultToolButton = createToolButton(IMAGES + "SEL", "Selection Tool",
				tool);
		palette.add(fDefaultToolButton);
	}

	protected Tool createSelectionTool() {
		return new SelectionTool(view());
	}

	protected ToolButton createToolButton(String iconName, String toolName,
			Tool tool) {
		return new ToolButton(this, iconName, toolName, tool);
	}

	protected StandardDrawingView createDrawingView() {
		Dimension d = getDrawingViewSize();
		return new StandardDrawingView(this, d.width, d.height);
	}

	protected Dimension getDrawingViewSize() {
		return new Dimension(400, 600);
	}

	protected Drawing createDrawing() {
		return new StandardDrawing();
	}

	protected Component createContents(StandardDrawingView view) {
		ScrollPane sp = new ScrollPane();
		Adjustable vadjust = sp.getVAdjustable();
		Adjustable hadjust = sp.getHAdjustable();
		hadjust.setUnitIncrement(16);
		vadjust.setUnitIncrement(16);

		sp.add(view);
		return sp;
	}

	public void setDrawing(Drawing drawing) {
		fView.setDrawing(drawing);
		fDrawing = drawing;
	}

	protected Dimension defaultSize() {
		return new Dimension(430, 406);
	}

	protected TextField createStatusLine() {
		TextField field = new TextField("No Tool", 40);
		field.setEditable(false);
		return field;
	}

	public void paletteUserSelected(PaletteButton button) {
		ToolButton toolButton = (ToolButton) button;
		setTool(toolButton.tool(), toolButton.name());
		setSelected(toolButton);
	}

	public void paletteUserOver(PaletteButton button, boolean inside) {
		ToolButton toolButton = (ToolButton) button;
		if (inside)
			showStatus(toolButton.name());
		else
			showStatus(fSelectedToolButton.name());
	}

	public Drawing drawing() {
		return fDrawing;
	}

	public Tool tool() {
		return fTool;
	}

	public DrawingView view() {
		return fView;
	}

	public void toolDone() {
		if (fDefaultToolButton != null) {
			setTool(fDefaultToolButton.tool(), fDefaultToolButton.name());
			setSelected(fDefaultToolButton);
		}
	}

	public void selectionChanged(DrawingView view) {
		MenuBar mb = getMenuBar();
		CommandMenu editMenu = (CommandMenu) mb.getMenu(EDIT_MENU);
		editMenu.checkEnabled();
		CommandMenu alignmentMenu = (CommandMenu) mb.getMenu(ALIGNMENT_MENU);
		alignmentMenu.checkEnabled();
	}

	public void showStatus(String string) {
		fStatusLine.setText(string);
	}

	private void setTool(Tool t, String name) {
		if (fTool != null)
			fTool.deactivate();
		fTool = t;
		if (fTool != null) {
			fStatusLine.setText(name);
			fTool.activate();
		}
	}

	private void setSelected(ToolButton button) {
		if (fSelectedToolButton != null)
			fSelectedToolButton.reset();
		fSelectedToolButton = button;
		if (fSelectedToolButton != null)
			fSelectedToolButton.select();
	}

	public void exit() {
		destroy();
		setVisible(false); // hide the Frame
		dispose(); // tell windowing system to free resources
		System.exit(0);
	}

	protected void destroy() {
	}

	public void promptNew() {
		initDrawing();
	}

	public void promptOpen() {
		FileDialog dialog = new FileDialog(this, "Open File...",
				FileDialog.LOAD);
		dialog.show();
		String filename = dialog.getFile();
		if (filename != null) {
			filename = stripTrailingAsterisks(filename);
			String dirname = dialog.getDirectory();
			loadDrawing(dirname + filename);
		}
		dialog.dispose();
	}

	public void promptSaveAs() {
		toolDone();
		String path = getSavePath("Save File...");
		if (path != null) {
			if (!path.endsWith(".draw"))
				path += ".draw";
			saveAsStorableOutput(path);
		}
	}

	public void promptSaveAsSerialized() {
		toolDone();
		String path = getSavePath("Save File...");
		if (path != null) {
			if (!path.endsWith(".ser"))
				path += ".ser";
			saveAsObjectOutput(path);
		}
	}

	public void print() {
		fTool.deactivate();
		PrintJob printJob = getToolkit().getPrintJob(this, "Print Drawing",
				null);

		if (printJob != null) {
			Graphics pg = printJob.getGraphics();

			if (pg != null) {
				fView.printAll(pg);
				pg.dispose(); // flush page
			}
			printJob.end();
		}
		fTool.activate();
	}

	private String getSavePath(String title) {
		String path = null;
		FileDialog dialog = new FileDialog(this, title, FileDialog.SAVE);
		dialog.show();
		String filename = dialog.getFile();
		if (filename != null) {
			filename = stripTrailingAsterisks(filename);
			String dirname = dialog.getDirectory();
			path = dirname + filename;
		}
		dialog.dispose();
		return path;
	}

	private String stripTrailingAsterisks(String filename) {
		if (filename.endsWith("*.*"))
			return filename.substring(0, filename.length() - 4);
		else
			return filename;
	}

	private void saveAsStorableOutput(String file) {
		try {
			FileOutputStream stream = new FileOutputStream(file);
			StorableOutput output = new StorableOutput(stream);
			output.writeStorable(fDrawing);
			output.close();
		} catch (IOException e) {
			showStatus(e.toString());
		}
	}

	private void saveAsObjectOutput(String file) {
		try {
			FileOutputStream stream = new FileOutputStream(file);
			ObjectOutput output = new ObjectOutputStream(stream);
			output.writeObject(fDrawing);
			output.close();
		} catch (IOException e) {
			showStatus(e.toString());
		}
	}

	private void loadDrawing(String file) {
		toolDone();
		String type = guessType(file);
		if (type.equals("storable"))
			readFromStorableInput(file);
		else if (type.equals("serialized"))
			readFromObjectInput(file);
		else
			showStatus("Unknown file type");
	}

	private void readFromStorableInput(String file) {
		try {
			FileInputStream stream = new FileInputStream(file);
			StorableInput input = new StorableInput(stream);
			fDrawing.release();
			fDrawing = (Drawing) input.readStorable();
			fView.setDrawing(fDrawing);
		} catch (IOException e) {
			initDrawing();
			showStatus("Error: " + e);
		}
	}

	private void readFromObjectInput(String file) {
		try {
			FileInputStream stream = new FileInputStream(file);
			ObjectInput input = new ObjectInputStream(stream);
			fDrawing.release();
			fDrawing = (Drawing) input.readObject();
			fView.setDrawing(fDrawing);
		} catch (IOException e) {
			initDrawing();
			showStatus("Error: " + e);
		} catch (ClassNotFoundException e) {
			initDrawing();
			showStatus("Class not found: " + e);
		}
	}

	private String guessType(String file) {
		if (file.endsWith(".draw"))
			return "storable";
		if (file.endsWith(".ser"))
			return "serialized";
		return "unknown";
	}
}
```

