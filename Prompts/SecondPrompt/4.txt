File: uml.QuickUML
```java

package uml;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;

import javax.swing.AbstractAction;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JSeparator;

import uml.ui.DiagramContainer;
import uml.ui.FlatMenuBar;
import uml.ui.ToolPalette;

public class QuickUML extends JFrame {

  protected QuickUML() {

    super("UML Application");

    DiagramContainer container = new DiagramContainer();
    ToolPalette palette = new ToolPalette(container);

    FlatMenuBar menuBar = new FlatMenuBar(); 
    container.updateMenus(menuBar);
    palette.updateMenus(menuBar);
    updateMenus(menuBar);

    Container content = getContentPane();
    content.setLayout(new BorderLayout());

    content.add(menuBar, BorderLayout.NORTH);
    content.add(container);
    content.add(palette, BorderLayout.WEST);

  }

  public void updateMenus(FlatMenuBar menuBar) {

    JMenu menu = menuBar.getMenu("File");

    menu.add(new JSeparator(), -1);    
    menu.add(new JMenuItem(new QuitAction()), -1);

    menu = menuBar.getHelpMenu();    
    menu.add(new JMenuItem(new AboutAction()), -1);

  }

  class QuitAction extends AbstractAction {

    QuitAction() {
      super("Quit");
    }

    public void actionPerformed(ActionEvent e) {
      System.exit(0);
    }

  }


  class AboutAction extends AbstractAction {

    JComponent about = new JLabel("<HTML>Created By: <B>Eric Crahen</B><CENTER>Copyright <B>(c)</B> 2001<CENTER><HTML>", JLabel.CENTER);

    AboutAction() {
      super("About");
    }

    public void actionPerformed(ActionEvent e) {
      JOptionPane.showOptionDialog(null, about, "About", JOptionPane.OK_OPTION ,JOptionPane.PLAIN_MESSAGE, null, new Object[] {"OK"}, null );
    }

  }

  public static void main(String[] args) {

    try {

      QuickUML app = new QuickUML();

      Dimension dim = Toolkit.getDefaultToolkit().getScreenSize(); 
      app.setBounds(dim.width/8, dim.height/8, dim.width*3/4, dim.height*3/4);

      app.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      app.setVisible(true);

    } catch(Throwable t) {
      t.printStackTrace();
      System.exit(0);
    }

  }

}
```

File: uml.ui.ColorTile
```java

package uml.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.ActionEvent;

import javax.swing.JButton;
import javax.swing.JColorChooser;
import javax.swing.UIManager;

public class ColorTile extends JButton {

  private String title;
  private String colorProperty;

  public ColorTile(String colorProperty) {
    this(colorProperty, "Choose a Color");
  }

  public ColorTile(String colorProperty, String title) {

    this.colorProperty = colorProperty;
    this.title = title;

    Dimension sz = new Dimension(32,32);

    setMinimumSize(sz);
    setMaximumSize(sz);

    setBackground(UIManager.getColor(colorProperty));

  }

  protected void fireActionPerformed(ActionEvent event) {

    Color c = JColorChooser.showDialog(this, title, UIManager.getColor(colorProperty));
    if(c != null)
      UIManager.put(colorProperty, c);

  }

}
```

File: uml.ui.FlatScrollPane
```java

package uml.ui;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;

import javax.swing.JComponent;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JViewport;
import javax.swing.plaf.basic.BasicScrollPaneUI;

public class FlatScrollPane extends JScrollPane {

  public FlatScrollPane() {
    this(null, VERTICAL_SCROLLBAR_AS_NEEDED, HORIZONTAL_SCROLLBAR_AS_NEEDED);
  }

  public FlatScrollPane(Component view) {
    this(view, VERTICAL_SCROLLBAR_AS_NEEDED, HORIZONTAL_SCROLLBAR_AS_NEEDED);
  }

  public FlatScrollPane(int vsbPolicy, int hsbPolicy) {
    this(null, vsbPolicy, hsbPolicy);
  }

  public FlatScrollPane(Component view, int vsbPolicy, int hsbPolicy) {
    super(view, vsbPolicy, hsbPolicy);
  }

  public void updateUI() {
    setUI(new FlatScrollPaneUI());
  }

  public static Color getViewBackground(JScrollPane pane) {

    JViewport viewport = pane.getViewport();
    Component view = null;
    if(viewport != null && (view = viewport.getView()) != null)
      return view.getBackground();

    return null;

  }

  public JScrollBar createHorizontalScrollBar() {
    return new FlatScrollBar(JScrollBar.HORIZONTAL);
  }

  public JScrollBar createVerticalScrollBar() {
    return new FlatScrollBar(JScrollBar.VERTICAL);
  }

  protected static class FlatScrollPaneUI extends BasicScrollPaneUI {

    public void installUI(JComponent x) {

      super.installUI(x);

      final JScrollPane thisPane = scrollpane;
      scrollpane.setCorner(getScrollBarCorner(), new Component() {

        public void paint(Graphics g) {

          int w = getSize().width;
          int h = getSize().height;

          Color c = getViewBackground(thisPane);
          if(c != null)
            g.setColor(c);

          g.fillRect(0, 0, w, h);

        }

      });

    }

    public void uninstallUI(JComponent c) {
      scrollpane.setCorner(getScrollBarCorner(), null);
      super.uninstallUI(c);
    }

    protected String getScrollBarCorner() {
      return LOWER_RIGHT_CORNER;
    }

  }

}
```

File: uml.ui.ToolPalette
```java


package uml.ui;

import java.awt.event.ActionEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import javax.swing.AbstractAction;
import javax.swing.ButtonGroup;
import javax.swing.Icon;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JMenu;
import javax.swing.JSeparator;
import javax.swing.JToggleButton;
import javax.swing.JToolBar;

import uml.diagram.ClassFigure;
import uml.diagram.InterfaceFigure;
import uml.diagram.NoteFigure;
import diagram.Diagram;
import diagram.tool.ClipboardTool;
import diagram.tool.CompositeTool;
import diagram.tool.EditingTool;
import diagram.tool.FigureDraggingTool;
import diagram.tool.FigureShappingTool;
import diagram.tool.FigureTool;
import diagram.tool.LinkShappingTool;
import diagram.tool.SelectionTool;
import diagram.tool.Tool;
import diagram.tool.ToolListener;


public class ToolPalette extends JToolBar 
  implements PropertyChangeListener, ToolListener {

  private ToolButton pointerButton;
  private ButtonGroup buttonGroup = new ButtonGroup();
  private DiagramContainer container;

  private Tool currentTool;
  private boolean revertPointer = true;

  public ToolPalette(DiagramContainer container) {

    super("Drawing Palette", VERTICAL);

    setFloatable(false);
    addSeparator();

    CompositeTool arrowTool = new CompositeTool();
    arrowTool.add(new SelectionTool());
    arrowTool.add(new FigureDraggingTool());
    arrowTool.add(new EditingTool());
    arrowTool.add(new FigureShappingTool());
    arrowTool.add(new LinkShappingTool());
    arrowTool.add(new ClipboardTool());
    arrowTool.add(new CardinalityTool());

    pointerButton = createButton(arrowTool, "images/Arrow.gif", "Pointer");
    add(pointerButton);

    addSeparator();

    Tool tool = new FigureTool(new ClassFigure());
    add( createButton(tool, "images/Class.gif", "Class") );

    tool = new FigureTool(new InterfaceFigure());
    add( createButton(tool, "images/Interface.gif", "Interface") );

    tool = new FigureTool(new NoteFigure());
    add( createButton(tool, "images/Note.gif", "Note") );
    
    addSeparator();

    tool = new GeneralizationTool();
    add( createButton(tool, "images/Generalization.gif", "Generalization") );

    tool = new RealizationTool();
    add( createButton(tool, "images/Realization.gif", "Realization") );

    addSeparator();

    tool = new CompositionTool();
    add( createButton(tool, "images/Composition.gif", "Composition") );

    tool = new AssociationTool();
    add( createButton(tool, "images/Association.gif", "Association"));

    tool = new DependencyTool();
    add( createButton(tool, "images/Dependency.gif", "Dependency"));

    container.addPropertyChangeListener(this);
    this.container = container;

    pointerButton.doClick();

  }

  protected ToolButton createButton(Tool tool, String iconResource, String toolTip) {
    return createButton(tool, 
                        IconManager.getInstance().getIconResource(this, iconResource), toolTip); 
  }

  protected ToolButton createButton(Tool tool, Icon icon, String toolTip) {
    
    ToolButton button = new ToolButton(tool, icon, toolTip);
    tool.addToolListener(this);

    return button;

  }

  public void updateMenus(FlatMenuBar menuBar) {

    JMenu menu = menuBar.getMenu("Options");
    menu.add(new JSeparator(), -1);    
    
    JCheckBoxMenuItem item = new JCheckBoxMenuItem(new ToggleRevertAction());
    item.setState(revertPointer);
    menu.add(item, -1);
    
  }

  public void propertyChange(PropertyChangeEvent e) {

    if(e.getPropertyName().equals("diagram.container")) {

      Diagram diagram = (Diagram)e.getNewValue();
      Diagram oldDiagram = (Diagram)e.getOldValue();

      if(currentTool != null) {

        if(oldDiagram != null)
          currentTool.uninstall(oldDiagram);
        if(diagram != null)
          currentTool.install(diagram);

      }
      
    }

  }

  public void toolStarted(Tool tool) {

  }

  public void toolFinished(Tool tool) {

    if(revertPointer && pointerButton.getTool() != tool)
      pointerButton.doClick();

  }

  protected class ToolButton extends JToggleButton {

    protected Tool tool;

    public ToolButton(Tool tool, Icon icon, String toolTip) {

      super(icon);

      this.setToolTipText(toolTip);
      this.tool = tool;

      buttonGroup.add(this);

    }

    public Tool getTool() {
      return tool;
    }

    protected void fireActionPerformed(ActionEvent e) {

      Diagram diagram = container.getView();
      if(diagram != null) {
          
        if(currentTool != null)
          currentTool.uninstall(diagram);

        tool.install(diagram);
        currentTool = tool;
        
      }
 
      super.fireActionPerformed(e);

    }
    

  
  protected class ToggleRevertAction extends AbstractAction {

    public ToggleRevertAction() {
      super("Revert to pointer");
    }

    public void actionPerformed(ActionEvent e) {
      revertPointer = !revertPointer;
    }

  }

}
```

File: uml.ui.JFontChooser
```java

package uml.ui;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Vector;

import javax.swing.AbstractAction;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

public class JFontChooser extends JComponent {

  protected static final String[] STYLES = { "plain", "bold", "italic", "boldItalic" };
  protected static final String[] SIZES = { "9", "10", "12", "14", "16", "18", "24" };
  protected static final String[] FONTS = getAvailableFontFamilyNames();


  private JList familyList, sizesList, stylesList;
  private JTextField familyField, sizesField, stylesField;
  private SampleLabel previewLabel;

  public JFontChooser(Font font) {
    this(font, null);
  }


  public JFontChooser(Font font, String sample) {

    GridBagLayout layout = new GridBagLayout();
    GridBagConstraints gc = new GridBagConstraints();

    setLayout(layout);

    gc.anchor = GridBagConstraints.NORTHWEST;
    gc.gridwidth = gc.gridheight = 1;   
    gc.insets = new Insets(4,4,4,4);
    gc.weightx = 1.0;
    gc.weighty = 0.0;

    JLabel lbl = new JLabel("Family", JLabel.CENTER);
    gc.fill = GridBagConstraints.HORIZONTAL;
    layout.setConstraints(lbl, gc); 
    add(lbl);

    lbl = new JLabel("Size", JLabel.CENTER);
    layout.setConstraints(lbl, gc); 
    add(lbl);
    
    lbl = new JLabel("Style", JLabel.CENTER);
    gc.gridwidth = GridBagConstraints.REMAINDER;
    layout.setConstraints(lbl, gc); 
    add(lbl);
  
    familyField = new JTextField(10);
    familyField.setEnabled(false);

    gc.gridwidth = 1;
    gc.weighty = 1.0;
    layout.setConstraints(familyField, gc); 
    add(familyField);

    sizesField = new JTextField(10);
    sizesField.setEnabled(false);    

    layout.setConstraints(sizesField, gc); 
    add(sizesField);

    stylesField = new JTextField(10);
    stylesField.setEnabled(false);

    gc.gridwidth = GridBagConstraints.REMAINDER;
    layout.setConstraints(stylesField, gc); 
    add(stylesField);

    familyList = new JList(FONTS);
    JScrollPane scrolPane = new JScrollPane(familyList);

    gc.ipadx = gc.ipady = 10;
    gc.gridwidth = 1;
    gc.gridheight = 4;
    gc.fill = GridBagConstraints.BOTH;
    layout.setConstraints(scrolPane, gc); 
    add(scrolPane);

    sizesList = new JList(SIZES);
    scrolPane = new JScrollPane(sizesList);
    layout.setConstraints(scrolPane, gc); 
    add(scrolPane);

    stylesList = new JList(STYLES);
    scrolPane = new JScrollPane(stylesList);
    gc.fill = GridBagConstraints.BOTH;
    gc.gridwidth = GridBagConstraints.REMAINDER;
    layout.setConstraints(scrolPane, gc); 
    add(scrolPane);

    previewLabel = new SampleLabel(sample);
    this.addPropertyChangeListener(previewLabel);

    gc.weighty = 0.0;
    gc.gridwidth = GridBagConstraints.REMAINDER;
    gc.gridheight = GridBagConstraints.REMAINDER;
    gc.fill = GridBagConstraints.BOTH;
    layout.setConstraints(previewLabel, gc); 
    add(previewLabel);
  
    
    SelectionHandler handler = new SelectionHandler();
    familyList.addListSelectionListener(handler);
    sizesList.addListSelectionListener(handler);
    stylesList.addListSelectionListener(handler);
   
 
    if(font != null)
      setFont(font);

  }

  public void setFont(Font font) {

    if(font == null)
      font = previewLabel.getFont();

    super.setFont(font);   

    if(font != null) {

      familyList.setSelectedValue(font.getName(), true);
      familyField.setText(String.valueOf(font.getName()));

      stylesList.setSelectedIndex(font.getStyle());
      stylesField.setText((String)stylesList.getSelectedValue());
   
      sizesField.setText(String.valueOf(font.getSize()));
      sizesList.setSelectedValue(String.valueOf(font.getSize()), true);

    }   

  }


  public static String[] getAvailableFontFamilyNames() {

    Vector v = new Vector();
    String names[] = 
      GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();

    for(int i = 0; i < names.length; i++) {

      if(!names[i].equals(".bold") && !names[i].equals(".italic"))
        v.addElement(names[i]);

    }

    return (String[])v.toArray(new String[v.size()]);

  }

  public Font getSelectedFont() {
    return super.getFont();
  }

  public String getSelectedFamily() {
    return getFont().getFamily();
  }

  public float getSelectedSize() {
    return getFont().getSize();
  }

  public int getSelectedStyle() {
    return getFont().getStyle();
  }

  protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {

    super.firePropertyChange(propertyName, oldValue, newValue);

  }

  protected class SelectionHandler implements ListSelectionListener {

    public void valueChanged(ListSelectionEvent e) {
      
      Object source = e.getSource();
      Font font = JFontChooser.this.getFont();
      Font oldFont = font;

      if(source == familyList) {
    
        font = new Font((String)familyList.getSelectedValue(), font.getStyle(), font.getSize());  
        firePropertyChange("font.family", oldFont, font);

      } else if (source == sizesList) {

        int fontSize;
        try {
          fontSize = Integer.parseInt((String)sizesList.getSelectedValue());
        } catch (Exception ex) { fontSize = 12; }
      
        font = font.deriveFont((float)fontSize);
        firePropertyChange("font.size", oldFont, font);

      } else if(source == stylesList) {
         
        font = font.deriveFont(stylesList.getSelectedIndex());
        firePropertyChange("font.style", oldFont, font);

      }
     
      if(!oldFont.equals(font))
        JFontChooser.super.setFont(font);

    }

  

  protected class SampleLabel extends JLabel implements PropertyChangeListener {

    public SampleLabel() {
      this(null);
    }

    public SampleLabel(String text) {
      super(text == null ? "Sample Text" : text);
      setHorizontalAlignment(JLabel.CENTER);
    }

    public void propertyChange(PropertyChangeEvent e) {

      String name = e.getPropertyName();
      if(name.equals("font.style") || name.equals("font.size") || name.equals("font.family"))
        this.setFont((Font)e.getNewValue());

    }

    public Dimension getMinimumSize() {
      return getPreferredSize();
    }

    public Dimension getPreferredSize() {
      Dimension dim = super.getPreferredSize();
      dim.height = 35;
      return dim;
    }



  public static Font showDialog(Component component) {
    return showDialog(component, null);
  } 

  public static Font showDialog(Component component, Font font) {
    return showDialog(component, "Select font", font);
  } 

  public static Font showDialog(Component component, String title, Font font) {
    
    if(font == null)
      font = component.getFont();

    FontDialog dlg = new FontDialog(component, title, font);
    return dlg.getSelectedFont();

  } 

  protected static class FontDialog extends JDialog {

    private static JFontChooser chooser = new JFontChooser(null);

    public FontDialog(Component component, String title, Font font) {

      super(JOptionPane.getFrameForComponent(component), title, true);

      Container content = this.getContentPane();
      
      content.setLayout(new BorderLayout());
      
      JPanel buttonsPanel = new JPanel();  
      buttonsPanel.add(new JButton(new AcceptAction()));
      buttonsPanel.add(new JButton(new CancelAction()));   
      
      content.add(buttonsPanel, BorderLayout.SOUTH);

      chooser.setFont(font);
      content.add(chooser);

      pack();

      this.setResizable(true);
      this.setVisible(true);

    }

    public Font getSelectedFont() {
      return chooser.getSelectedFont();
    }

    protected class AcceptAction extends AbstractAction {
      
      public AcceptAction() { super("OK"); }
      
      public void actionPerformed(ActionEvent e) {
        FontDialog.this.setVisible(false);
      }
      
    }
    
    protected class CancelAction extends AbstractAction {
      
      public CancelAction() { super("Cancel"); }
      
      public void actionPerformed(ActionEvent e) {
        FontDialog.this.setVisible(false);
      }
      
    }


}
```

File: uml.ui.PrintableAction
```java

package uml.ui;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.print.PageFormat;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;

import javax.swing.AbstractAction;
import javax.swing.Icon;
import javax.swing.JOptionPane;
import javax.swing.RepaintManager;

public abstract class PrintableAction extends AbstractAction 
  implements Printable {

  public PrintableAction(String name, Icon icon) {
    super(name, icon);
  }

  public PrintableAction(String name) {
    super(name);
  }

  abstract public Component getComponent();

  public int print(Graphics g, PageFormat pf, int pageIndex) {

    Component component = getComponent();

    Graphics2D g2 = (Graphics2D)g;
    double x;

    if(pf.getOrientation() != PageFormat.LANDSCAPE)
      x = pageIndex*pf.getImageableWidth();
    else 
      x = pageIndex*pf.getImageableHeight();

    if(x > component.getWidth())
      return Printable.NO_SUCH_PAGE;
    
    x += pf.getImageableX();
    g2.translate(x, pf.getImageableY()); 

    RepaintManager mgr = RepaintManager.currentManager(component);
    boolean isBuffered = mgr.isDoubleBufferingEnabled();
    mgr.setDoubleBufferingEnabled(false);  
    
    component.paint(g2);

    mgr.setDoubleBufferingEnabled(isBuffered);  
    return Printable.PAGE_EXISTS;		
					
  }

  public void print()
    throws PrinterException {

    PrinterJob job = PrinterJob.getPrinterJob();
    job.setPrintable(this);
    if(job.printDialog()) 
      job.print();
      
  }

  public void actionPerformed(ActionEvent e) {

    try {
      print();
    } catch(Throwable t) { 
      JOptionPane.showMessageDialog(getComponent(), t.getMessage(), "Print Error", JOptionPane.ERROR_MESSAGE);
    }

  }

}
```

File: uml.ui.ExportAction
```java

package uml.ui;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;

import javax.swing.Icon;
import javax.swing.RepaintManager;

import acme.GifEncoder;

public abstract class ExportAction extends FileAction {
  
  public ExportAction(String name, Icon icon) {
    super(name, icon);
  } 
  
  abstract protected Component getComponent();
  
  protected void writeGIF(File file)
    throws Exception {

    String name = file.getName().toLowerCase();
    if(!name.endsWith(".gif")) 
      file = new File(file.getName() + ".gif");

    Component component =  getComponent();

    int width = component.getWidth();
    int height = component.getHeight();

    BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);

    Graphics g = bi.createGraphics();
    g.setClip(0, 0, width, height);

    RepaintManager mgr = RepaintManager.currentManager(component);
    boolean isBuffered = mgr.isDoubleBufferingEnabled();
    mgr.setDoubleBufferingEnabled(false);  
    
    component.paint(g);

    mgr.setDoubleBufferingEnabled(isBuffered);  

    GifEncoder codec = new GifEncoder(bi, new FileOutputStream(file));
    codec.encode();
    
  }

}
```

File: uml.ui.RealizationTool
```java

package uml.ui;

import uml.diagram.RealizationLink;
import diagram.Figure;
import diagram.Link;
import diagram.tool.LinkTool;

public class RealizationTool extends LinkTool {

  protected Link createLink(Figure source, Figure sink) {
    return new RealizationLink(source, sink);
  }
  
}
```

File: uml.ui.FontAction
```java

package uml.ui;

import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.HashMap;

import javax.swing.AbstractAction;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.UIManager;

public class FontAction extends AbstractAction {
  
  private JComponent comp;
  private FontPanel panel;
  
  public FontAction(JComponent comp, String[] properties) {
    
    super("Fonts ...");
    this.comp = comp;
    this.panel = new FontPanel(properties);
    
  }

  public void actionPerformed(ActionEvent e) {
    
    JOptionPane.showMessageDialog(comp, panel, "Change fonts",
                                  JOptionPane.PLAIN_MESSAGE);
    
    comp.paintImmediately(0, 0, comp.getWidth(), comp.getHeight());
    
  }

  
  public class FontPanel extends JPanel 
    implements PropertyChangeListener {
    
    protected HashMap tiles = new HashMap();
    
    protected FontPanel(String[] fontProperties) {

      UIManager.getDefaults().addPropertyChangeListener(this);
      
      GridBagLayout gridbag = new GridBagLayout();
      GridBagConstraints gc = new GridBagConstraints();
      
      setLayout(gridbag);
      
      Font font = getFont().deriveFont(Font.PLAIN);
      gc.insets = new Insets(1,1,1,1);
      
      for(int i=0; i<fontProperties.length; i++) {
        
        String fontName = fontProperties[i];
        JLabel lbl = new JLabel(fontName);
        lbl.setHorizontalTextPosition(JLabel.LEFT);
        lbl.setFont(font);
        
        gc.fill = GridBagConstraints.HORIZONTAL;
        gc.weightx = 1;
        gc.gridwidth = 1;
        
        gridbag.setConstraints(lbl, gc);
        add(lbl);

        
        FontTile c = new FontTile(fontName);
        gc.gridwidth = GridBagConstraints.REMAINDER;
        
        gridbag.setConstraints(c, gc);
        add(c);
        
        tiles.put(fontName, c);
        
      }
      
      
    }
    
    public void propertyChange(PropertyChangeEvent e) {
      
      FontTile c = (FontTile)tiles.get(e.getPropertyName());
      if(c != null) 
        c.setFont((Font)e.getNewValue());


    }

    
  }
 

}
```

File: uml.ui.FlatScrollBar
```java

package uml.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;

import javax.swing.BoundedRangeModel;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.event.ChangeEvent;
import javax.swing.plaf.basic.BasicScrollBarUI;

public class FlatScrollBar extends JScrollBar {

  public FlatScrollBar() {
    this(VERTICAL);
  }

  public FlatScrollBar(int orientation) {
    super(orientation);
  }

  public void updateUI() {
    setUI(new FlatScrollBarUI());
  }

  public static class FlatScrollBarUI extends BasicScrollBarUI {

    protected void installDefaults() {
      super.installDefaults();
      scrollbar.setBorder(null);
    }

    protected ModelListener createModelListener() {
    	return new ModelListener() {

       	public void stateChanged(ChangeEvent e) {

          super.stateChanged(e);

          BoundedRangeModel mdl = (BoundedRangeModel)e.getSource();

          showDecrementButton(mdl.getValue() != 0);
          showIncrementButton((mdl.getValue() + mdl.getExtent()) != mdl.getMaximum());

        }
     };
    }

    public void paint(Graphics g, JComponent comp) {

      int w = scrollbar.getSize().width;
      int h = scrollbar.getSize().height;

      Color c = FlatScrollPane.getViewBackground((JScrollPane)comp.getParent());
      if(c != null)
        g.setColor(c);

      g.fillRect(0, 0, w, h);

    }

    public Dimension getPreferredSize(JComponent c) {
    	return (scrollbar.getOrientation() == JScrollBar.VERTICAL) ? new Dimension(10, 48) : new Dimension(48, 10);
    }


    protected void paintDecreaseHighlight(Graphics g) {
    }

    protected void paintIncreaseHighlight(Graphics g) {
    }

    protected JButton createDecreaseButton(int orientation)  {
      return new FlatArrowButton(orientation);
    }

    protected JButton createIncreaseButton(int orientation)  {
      return new FlatArrowButton(orientation);
    }

    private final void showIncrementButton(boolean flag) {
      incrButton.setVisible(flag);
    }

    private final void showDecrementButton(boolean flag) {
      decrButton.setVisible(flag);
    }

  }

}
```

File: uml.ui.FlatArrowButton
```java

package uml.ui;

import java.awt.Dimension;
import java.awt.Graphics;

import javax.swing.plaf.basic.BasicArrowButton;

public class FlatArrowButton extends BasicArrowButton {

  public FlatArrowButton(int orientation) {
    super(orientation);
  }
  
  public Dimension getPreferredSize() {
    return new Dimension(8, 8);
  }
  
  public void paint(Graphics g) {
    
    int w, h, size;

    w = getSize().width;
    h = getSize().height;

    if(h >= 5 && w >= 5) {

      size = Math.min((h - 4) / 3, (w - 4) / 3);
      size = Math.max(size, 4);
	    paintTriangle(g, (w - size) / 2, (h - size) / 2, size, direction, isEnabled());

    }


  }

}
```

File: uml.ui.FlatTextArea
```java

package uml.ui;

import java.awt.Color;
import java.awt.Insets;
import java.awt.Point;

import javax.swing.JTextArea;

public class FlatTextArea extends FlatScrollPane {

  private static final Point origin = new Point(0, 0);

  private JTextArea textArea = new JTextArea();
  private boolean snapBack;

  public FlatTextArea(boolean snapBack) {

    
    textArea.setBorder(null);

    setOpaque(false);
    setSnappedBack(snapBack);
    setViewportView(textArea);

  }

  public void setForeground(Color c) {
    super.setForeground(c);
    if(textArea != null)
      textArea.setForeground(c);
  }

  public void setBackground(Color c) {
    super.setBackground(c);
    if(textArea != null)
      textArea.setBackground(c);
  }


  public String getText() {
    return textArea.getText();
  }

  public void setText(String text) {

    textArea.setText(text);

    if(snapBack) {
      getViewport().setViewPosition(origin);
      textArea.moveCaretPosition(0);
    }

  }

  public boolean isSnappedBack() {
    return snapBack;
  }

  public void setSnappedBack(boolean snapBack) {
    this.snapBack = snapBack;
  }

  public void setMargin(Insets margin) {
    textArea.setMargin(margin);
  }

  public Insets getMargin() {
    return textArea.getMargin();
  }

}
```

File: uml.ui.BuildAction
```java

package uml.ui;

import java.awt.Font;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Iterator;

import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;

import uml.builder.BuilderException;
import uml.builder.CPlusPlusBuilder;
import uml.builder.CodeBuilder;
import uml.builder.Context;
import uml.builder.JavaBuilder;

public class BuildAction extends AbstractAction {

  protected DiagramContainer container;

  public BuildAction(DiagramContainer container) {

    super("Build ...");

    this.container = container;

  }

  public void actionPerformed(ActionEvent e) {

    BuildDialog dlg = new BuildDialog(container.getFrame());
    dlg.show();
  
  }

  protected class BuildDialog extends JDialog implements ActionListener {
    
    protected JTextArea textArea = new JTextArea();
    protected JTextField currentPath = new JTextField();
    protected JCheckBox useArrays;
    protected BrowseAction browseAction = new BrowseAction();
    protected String currentLanguage;

    public BuildDialog(Frame frame) {
      
      super(frame, "Build source code", true);
      
 
      JPanel content = new JPanel();
      content.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));

      GridBagLayout gridbag = new GridBagLayout();
      GridBagConstraints gc = new GridBagConstraints();
      
      content.setLayout(gridbag);
     
      JLabel lbl = new JLabel("Output:");

      gc.gridheight = 1;
      gc.gridwidth = 1;
      gc.weightx = 1.0;
      gc.weighty = 1.0;
      gc.fill = GridBagConstraints.NONE;
      gc.anchor = GridBagConstraints.WEST;

      gridbag.setConstraints(lbl, gc);
      content.add(lbl);

      currentPath = new JTextField();
      currentPath.setText(browseAction.getChooser().getLastDirectory());
      gc.gridwidth = 2;
      gc.anchor = GridBagConstraints.CENTER;
      gc.fill = GridBagConstraints.HORIZONTAL;

      gridbag.setConstraints(currentPath, gc);
      content.add(currentPath);

      JButton btn = new JButton(browseAction);
      btn.setFont(btn.getFont().deriveFont(Font.PLAIN));
      
      gc.anchor = GridBagConstraints.EAST;
      gc.gridwidth = GridBagConstraints.REMAINDER;
      gc.fill = GridBagConstraints.NONE;
      gc.weightx = 1.0;

      gridbag.setConstraints(btn, gc);
      content.add(btn);

      lbl = new JLabel("Language:");
      
      gc.gridheight = 1;
      gc.gridwidth = 1;
      gc.weightx = 1.0;
      gc.weighty = 1.0;
      gc.fill = GridBagConstraints.NONE;
      gc.anchor = GridBagConstraints.WEST;

      gridbag.setConstraints(lbl, gc);
      content.add(lbl);


      JComboBox box = new JComboBox(new Object[] {"Java", "C++"}) {
        protected void fireActionEvent() { currentLanguage = getSelectedItem().toString(); }
      };

      box.setFont(box.getFont().deriveFont(Font.PLAIN));
      currentLanguage = box.getSelectedItem().toString();

      gc.gridwidth = GridBagConstraints.REMAINDER;
      gridbag.setConstraints(box, gc);

      content.add(box);

      lbl = new JLabel("Use arrays:");
      
      gc.gridheight = 1;
      gc.gridwidth = 1;
      gc.weightx = 1.0;
      gc.weighty = 1.0;
      gc.fill = GridBagConstraints.NONE;
      gc.anchor = GridBagConstraints.WEST;

      gridbag.setConstraints(lbl, gc);
      content.add(lbl);

      useArrays = new JCheckBox();

      gc.gridwidth = GridBagConstraints.REMAINDER;
      gridbag.setConstraints(useArrays, gc);

      content.add(useArrays);

      lbl = new JLabel("Messages:");
      gc.gridwidth = GridBagConstraints.REMAINDER;
      gc.anchor = GridBagConstraints.WEST;

      gridbag.setConstraints(lbl, gc);
      content.add(lbl);

      
      JScrollPane pane = new JScrollPane(textArea);
      textArea.setEditable(false);
      browseAction.getChooser().setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

      gc.fill = GridBagConstraints.BOTH;
      gc.gridheight = GridBagConstraints.RELATIVE;
      gc.weighty = 20.0;
 
      gridbag.setConstraints(pane, gc);
      content.add(pane);

      JPanel buttonPanel = new JPanel(new GridLayout(1,2,4,4));   

      btn = new JButton("Build");
      btn.addActionListener(this);
      buttonPanel.add(btn);

      btn = new JButton("Cancel");
      btn.addActionListener(this);
      buttonPanel.add(btn);
      
      gc.gridheight = GridBagConstraints.REMAINDER;
      gc.weighty = 1;
      gridbag.setConstraints(buttonPanel, gc);
 
      buttonPanel.setBorder(BorderFactory.createEmptyBorder(5,0,0,0));
      content.add(buttonPanel);

      setContentPane(content);

      int w = frame.getWidth();
      int h = frame.getHeight();
      int x = (int)(frame.getX() + w*0.25);
      int y = (int)(frame.getY() + h*0.25);

      setBounds(x, y, (int)(w*0.5), (int)(h*0.5));

    }

    protected CodeBuilder getBuilder() {
  
      String path = currentPath.getText();

      if(currentLanguage.equals("C++"))
        return new CPlusPlusBuilder(path);

      else if(currentLanguage.equals("Java"))
        return new JavaBuilder(path);

      else 
        throw new RuntimeException("No builder available");

    }


    public void actionPerformed(ActionEvent e) {
      
      if(e.getActionCommand().equals("Build")) {

        Context ctx = null;
        try {

          ctx = new Context(container.getView().getModel());
          ctx.enableArrays(useArrays.isSelected());
          getBuilder().build(ctx);

          
          String msg = x.getMessage();
          String title = "I/O Error";

          if(msg.startsWith("I/O Error: ")) {
            JOptionPane.showMessageDialog(this, msg, title, JOptionPane.ERROR_MESSAGE);
            return;
          }

        }

        if(ctx != null) {

          for(Iterator i = ctx.getWarnings(); i.hasNext();) {

            String warning = (String)i.next();

            append("warning: ");
            append(warning);
            append("\n");

          }

          append("\n");

          for(Iterator i = ctx.getErrors(); i.hasNext();) {

            String error = (String)i.next();

            append("error: ");
            append(error);
            append("\n");

          }

        }

        append("\nDONE!\n");

      } else 
        dispose();

    }  
    
    private final void append(String msg) {
      
      try {
        Document doc = textArea.getDocument();
        doc.insertString(doc.getLength(), msg, null);
      } catch(BadLocationException e) { e.printStackTrace(); }

    }


    protected class BrowseAction extends FileAction {
      
      public BrowseAction() { 
        super("...");
      }
      
      public void actionPerformed(ActionEvent e) {
        browseAction.getChooser().showDialog(BuildDialog.this, "Select a directory");
        currentPath.setText(browseAction.getChooser().getLastDirectory());
      }
      
    }



}
```

File: uml.ui.ColorAction
```java

package uml.ui;

import java.awt.Color;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.HashMap;

import javax.swing.AbstractAction;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.UIManager;

public class ColorAction extends AbstractAction {
  
  private JComponent comp;
  private ColorPanel panel;
  
  public ColorAction(JComponent comp, String[] properties) {
    
    super("Colors ...");
    this.comp = comp;
    this.panel = new ColorPanel(properties);
    
  }
  
  public void actionPerformed(ActionEvent e) {
    
    JOptionPane.showMessageDialog(comp, panel, "Change colors",
                                  JOptionPane.PLAIN_MESSAGE);
    
    comp.paintImmediately(0, 0, comp.getWidth(), comp.getHeight());
    
  }
  

  public class ColorPanel extends JPanel 
    implements PropertyChangeListener {
    
    protected HashMap tiles = new HashMap();
    
    protected ColorPanel(String[] colorProperties) {
      
      UIManager.getDefaults().addPropertyChangeListener(this);
      
      GridBagLayout gridbag = new GridBagLayout();
      GridBagConstraints gc = new GridBagConstraints();
      
      setLayout(gridbag);
      
      Font font = getFont().deriveFont(Font.PLAIN);
      gc.insets = new Insets(1,1,1,1);
      
      for(int i=0; i<colorProperties.length; i++) {
        
        String color = colorProperties[i];
        JLabel lbl = new JLabel(color);
        lbl.setHorizontalTextPosition(JLabel.LEFT);
        lbl.setFont(font);
        
        gc.fill = GridBagConstraints.HORIZONTAL;
        gc.weightx = 1;
        gc.gridwidth = 1;
        
        gridbag.setConstraints(lbl, gc);
        add(lbl);
        
        ColorTile c = new ColorTile(color);
        gc.gridwidth = GridBagConstraints.REMAINDER;
        
        gridbag.setConstraints(c, gc);
        add(c);
        
        tiles.put(color, c);
        
      }
      
      
    }
    
    public void propertyChange(PropertyChangeEvent e) {
      
      ColorTile c = (ColorTile)tiles.get(e.getPropertyName());
      if(c != null)
        c.setBackground((Color)e.getNewValue());
      
    }
    
    
  }
  

}
```

File: uml.ui.DiagramContainer
```java

package uml.ui;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Event;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.Icon;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JFileChooser;
import javax.swing.JMenu;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.KeyStroke;

import uml.diagram.AssociationLink;
import uml.diagram.AssociationLinkEditor;
import uml.diagram.AssociationLinkRenderer;
import uml.diagram.ClassEditor;
import uml.diagram.ClassFigure;
import uml.diagram.ClassRenderer;
import uml.diagram.CompositionLink;
import uml.diagram.CompositionLinkEditor;
import uml.diagram.CompositionLinkRenderer;
import uml.diagram.DependencyLink;
import uml.diagram.DependencyLinkEditor;
import uml.diagram.DependencyLinkRenderer;
import uml.diagram.GeneralizationLink;
import uml.diagram.GeneralizationLinkEditor;
import uml.diagram.GeneralizationLinkRenderer;
import uml.diagram.InterfaceEditor;
import uml.diagram.InterfaceFigure;
import uml.diagram.InterfaceRenderer;
import uml.diagram.NoteEditor;
import uml.diagram.NoteFigure;
import uml.diagram.NoteRenderer;
import uml.diagram.RealizationLink;
import uml.diagram.RealizationLinkEditor;
import uml.diagram.RealizationLinkRenderer;
import diagram.Diagram;
import diagram.DiagramModel;



public class DiagramContainer extends JScrollPane {

  protected Action saveAction = new SaveAction();
  protected Action closeAction = new CloseAction();
  protected Action printAction =  new PrintAction();
  protected Action scaledPrintAction =  new ScaledPrintAction();
  protected Action exportAction =  new ExportGIFAction();
  protected Action resizeAction = new ResizeAction();

  protected Action copyAction = new CopyAction();
  protected Action cutAction = new CutAction();
  protected Action pasteAction = new PasteAction(); 

  protected Dimension defaultSize;

  private final static String[] colorProperties = {

    "composition.foreground","composition.background",
    "class.foreground","class.background",
    "association.foreground","association.background",
    "dependency.foreground","dependency.background",
    "diagram.foreground","diagram.background",
    "generalization.foreground","generalization.background",
    "interface.foreground","interface.background",
    "note.foreground","note.background",
    "realization.foreground","realization.background"

  };

  private final static String[] fontProperties = {

    "composition.font",
    "class.font",
    "association.font",
    "diagram.font",
    "generalization.font",
    "interface.font",
    "note.font",
    "dependency.font",
    "realization.font"
  };

  public DiagramContainer() {

    super(VERTICAL_SCROLLBAR_ALWAYS, HORIZONTAL_SCROLLBAR_ALWAYS);
    setView( createDiagram() );

  }

  public void updateMenus(FlatMenuBar menuBar) {

    JMenu menu = menuBar.getMenu("File");

    menu.add(new NewAction());
    menu.add(new OpenAction());
    menu.add(closeAction);
    menu.add(saveAction);
    menu.addSeparator();
    menu.add(exportAction);
    menu.addSeparator();
    menu.add(printAction);
    menu.add(scaledPrintAction);
 
    menu = menuBar.getMenu("Edit");
    menu.add(copyAction);
    menu.add(cutAction);
    menu.add(pasteAction);

    menu = menuBar.getMenu("Options");
    menu.add(resizeAction);
    menu.add(new FontAction(this, fontProperties));
    menu.add(new ColorAction(this, colorProperties));
    menu.add(new JSeparator(), -1);    
    
    JCheckBoxMenuItem item = new JCheckBoxMenuItem(new ToggleRefreshAction());
    item.setState(true);
    menu.add(item, -1);

    menu = menuBar.getMenu("Tool");
    menu.add(new BuildAction(this));

  }


  public Diagram createDiagram() {

    Diagram diagram = new Diagram();

    diagram.setFigureRenderer(CompositionLink.class, new CompositionLinkRenderer());
    diagram.setFigureRenderer(AssociationLink.class, new AssociationLinkRenderer());
    diagram.setFigureRenderer(GeneralizationLink.class, new GeneralizationLinkRenderer());
    diagram.setFigureRenderer(RealizationLink.class, new RealizationLinkRenderer());
    diagram.setFigureRenderer(DependencyLink.class, new DependencyLinkRenderer());

    diagram.setFigureRenderer(ClassFigure.class, new ClassRenderer());
    diagram.setFigureRenderer(InterfaceFigure.class, new InterfaceRenderer());
    diagram.setFigureRenderer(NoteFigure.class, new NoteRenderer());

    diagram.setFigureEditor(NoteFigure.class, new NoteEditor());
    diagram.setFigureEditor(ClassFigure.class, new ClassEditor());
    diagram.setFigureEditor(InterfaceFigure.class, new InterfaceEditor());

    diagram.setFigureEditor(CompositionLink.class, new CompositionLinkEditor());
    diagram.setFigureEditor(GeneralizationLink.class, new GeneralizationLinkEditor());
    diagram.setFigureEditor(RealizationLink.class, new RealizationLinkEditor());
    diagram.setFigureEditor(DependencyLink.class, new DependencyLinkEditor());
    diagram.setFigureEditor(AssociationLink.class, new AssociationLinkEditor());

    if(defaultSize != null) 
      resizeDiagram(diagram, defaultSize);

    return diagram;

  }

  public Diagram getView() {
    return (Diagram)getViewport().getView();
  }

  public void setView(Diagram diagram) {

    Diagram oldDiagram = getView();
    setViewportView(diagram);

    if(diagram == null) { // Disable actions that need a diagram

      closeAction.setEnabled(false);
      saveAction.setEnabled(false);
      exportAction.setEnabled(false);
      printAction.setEnabled(false);
      scaledPrintAction.setEnabled(false);
      resizeAction.setEnabled(false);

      copyAction.setEnabled(false);
      cutAction.setEnabled(false);
      pasteAction.setEnabled(false);

    } else if(oldDiagram == null) { // Enable actions that need a diagram

      closeAction.setEnabled(true);
      saveAction.setEnabled(true);
      exportAction.setEnabled(true);
      printAction.setEnabled(true);
      scaledPrintAction.setEnabled(true);
      resizeAction.setEnabled(true);

      copyAction.setEnabled(true);
      cutAction.setEnabled(true);
      pasteAction.setEnabled(true);

    }

    super.firePropertyChange("diagram.container", oldDiagram, diagram);

  }

  protected Component getFrame(ActionEvent e) {  
    return getFrame((Component)e.getSource());
  }

  protected Frame getFrame(Component frame) {

    for(;!(frame instanceof Frame); frame = frame.getParent())
      if(frame instanceof JPopupMenu)
        frame = ((JPopupMenu)frame).getInvoker();

    return (frame instanceof Frame) ? (Frame)frame : null;

  }
  
  public Frame getFrame() {
    return getFrame(this);
  }

  protected Icon getIcon(String name) {
    return IconManager.getInstance().getIconResource(this, name);
  }

  protected void displayError(Throwable t) {
    t.printStackTrace();
    displayError(t.getClass().getName(), t.getMessage());
  }

  protected void displayError(String title, String msg) {
    JOptionPane.showMessageDialog(this, msg, title, JOptionPane.ERROR_MESSAGE);
  }

  protected void resizeDiagram(Diagram diagram, Dimension d) {

    diagram.setMinimumSize(d);
    diagram.setPreferredSize(d);     
    diagram.setBounds(0, 0, d.width, d.height);

    doLayout();

  }


  protected class NewAction extends AbstractAction {
    
    public NewAction() {
      super("New", getIcon("images/New.gif"));
    }

    public void actionPerformed(ActionEvent e) {
      setView( createDiagram() );
    }

  }


  protected class CloseAction extends AbstractAction {
    
    public CloseAction() {
      super("Close", getIcon("images/Close.gif"));
    }

    public void actionPerformed(ActionEvent e) {
      setView( null );
    }

  }

  protected class OpenAction extends FileAction {
    
    private SimpleFilter filter = new SimpleFilter("dia", "Diagrams");

    public OpenAction() {
      super("Open", getIcon("images/Open.gif"));
      putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke('O', Event.CTRL_MASK));
    }

    public void actionPerformed(ActionEvent e) {

      JFileChooser chooser = getChooser();
      chooser.setAcceptAllFileFilterUsed(false);
      chooser.setFileFilter(filter);

      if(JFileChooser.APPROVE_OPTION == chooser.showOpenDialog(getFrame(e)))
        openFile(chooser.getSelectedFile());
      
    }
    
    public void openFile(File file) {

      try {

        String name = file.getName().toLowerCase();
        if(!name.endsWith(".dia")) 
          throw new RuntimeException("Not a valid diagram file extension");
                
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
        
        Diagram diagram = getView();
        if(diagram == null)
          setView(diagram = createDiagram());
        
        diagram.setModel((DiagramModel)ois.readObject());
        diagram.repaint();

      } catch(Throwable t) { 
        t.printStackTrace();
        displayError("File Error", "Invalid diagram file");
      }
      
    }




  protected class SaveAction extends FileAction {
    
    private SimpleFilter filter = new SimpleFilter("dia", "Diagrams");

    public SaveAction() {
      super("Save", getIcon("images/Save.gif"));
      putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke('S', Event.CTRL_MASK));
    }

    public void actionPerformed(ActionEvent e) {

      JFileChooser chooser = getChooser();
      chooser.setAcceptAllFileFilterUsed(false);
      chooser.setFileFilter(filter);

      if(JFileChooser.APPROVE_OPTION == chooser.showSaveDialog(getFrame(e)))
        saveFile(chooser.getSelectedFile());
      
    }
    
    public void saveFile(File file) {

      String name = file.getName().toLowerCase();
      if(!name.endsWith(".dia")) 
        file = new File(file.getName() + ".dia");

      try {

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
        oos.writeObject((DiagramModel)getView().getModel());

      } catch(Throwable t) { 
        t.printStackTrace();
        displayError("File Error", "Error writing to file");
      }

    }



  protected class ExportGIFAction extends ExportAction {

    private SimpleFilter filter = new SimpleFilter("gif", "Images");

    public ExportGIFAction() {
      super("Save Image", getIcon("images/ExportImage.gif"));
    }

    protected Component getComponent() {
      return getView();
    }

    public void actionPerformed(ActionEvent e) {

      JFileChooser chooser = getChooser();
      chooser.setAcceptAllFileFilterUsed(false);
      chooser.setFileFilter(filter);

      if(JFileChooser.APPROVE_OPTION == chooser.showSaveDialog(getFrame(e))) {
        try {
          writeGIF(chooser.getSelectedFile());
        } catch(Throwable t) { displayError(t); }
      }

    }

  }

  protected class PrintAction extends PrintableAction {

    public PrintAction() {
      super("Print ...");
    }

    public Component getComponent() {
      return getView();
    }

  }

  protected class ScaledPrintAction extends ScaledPrintableAction {

    public ScaledPrintAction() {
      super("Scaled Print", getIcon("images/Print.gif"));
    }

    public Component getComponent() {
      return getView();
    }

  }

  protected class CopyAction extends AbstractAction {
    
    public CopyAction() {
      super("Copy", getIcon("images/Copy.gif"));
      putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke('C', Event.CTRL_MASK));
    }

    public void actionPerformed(ActionEvent e) {
      
      Diagram diagram = getView();
      if(diagram != null) {

        Action action = diagram.getActionMap().get("copy");
        if(action != null)
          action.actionPerformed(e);

      }

    }

  }

  protected class CutAction extends AbstractAction {
    
    public CutAction() {
      super("Cut", getIcon("images/Cut.gif"));
      putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke('X', Event.CTRL_MASK));
    }

    public void actionPerformed(ActionEvent e) {

      Diagram diagram = getView();
      if(diagram != null) {

        Action action = diagram.getActionMap().get("cut");
        if(action != null)
          action.actionPerformed(e);

      }

    }

  }

  protected class PasteAction extends AbstractAction {
    
    public PasteAction() {
      super("Paste", getIcon("images/Paste.gif"));
      putValue(Action.ACCELERATOR_KEY, KeyStroke.getKeyStroke('V', Event.CTRL_MASK));
    }

    public void actionPerformed(ActionEvent e) {

      Diagram diagram = getView();
      if(diagram != null) {

        Action action = diagram.getActionMap().get("paste");
        if(action != null)
          action.actionPerformed(e);

      }

    }

  }


  protected class ResizeAction extends AbstractAction {
    
    public ResizeAction() {
      super("Resize ...");
    }

    public void actionPerformed(ActionEvent e) {
      
      Diagram diagram = getView();
      if(diagram != null) 
        promptResize(diagram);

    }

    protected void promptResize(Diagram diagram) {
      
      SizePanel size = new SizePanel(diagram);
      int n = JOptionPane.showConfirmDialog(DiagramContainer.this, 
                                            size, "Resize Diagram", 
                                            JOptionPane.OK_CANCEL_OPTION);
      if(n == JOptionPane.OK_OPTION) {
        
        defaultSize = size.getDimension(defaultSize);
        resizeDiagram(diagram, defaultSize);     
        
      }
      
    }

  }


  protected class ToggleRefreshAction extends AbstractAction {

    public ToggleRefreshAction() {
      super("Fast refresh");
    }

    public void actionPerformed(ActionEvent e) {

      Diagram diagram = getView();
      if(diagram != null) {

        boolean toggle = !diagram.isFastRefreshEnabled();
        diagram.enableFastRefresh(toggle);

      }

    }

  }

}
```

File: uml.ui.AssociationTool
```java

package uml.ui;

import uml.diagram.AssociationLink;
import diagram.Figure;
import diagram.Link;
import diagram.tool.LinkTool;

public class AssociationTool extends LinkTool {

  protected Link createLink(Figure source, Figure sink) {
    return new AssociationLink(source, sink);
  }
  
}
```

File: uml.ui.CardinalityTool
```java

package uml.ui;

import java.awt.Color;
import java.awt.Font;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPopupMenu;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;

import uml.diagram.CompositionItem;
import uml.diagram.CompositionLink;
import diagram.Diagram;
import diagram.DiagramModel;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.tool.AbstractTool;
import diagram.tool.LinkShappingTool;

public class CardinalityTool extends AbstractTool {

  protected MouseHandler mouseHandler = new MouseHandler();
  protected Popup popup = new Popup();

  protected CompositionItem item;
  protected CompositionLink link;
  protected Diagram diagram;

  public void install(Diagram diagram) {
    diagram.addMouseListener(mouseHandler);
  }

  public void uninstall(Diagram diagram) {
    diagram.removeMouseListener(mouseHandler);
    reset();
  }

  protected class MouseHandler extends MouseAdapter {

    public void mouseClicked(MouseEvent e) {

      if(!e.isConsumed() && SwingUtilities.isRightMouseButton(e)) {
        
        diagram = (Diagram)e.getSource();
        Point pt = e.getPoint();
        Figure figure = diagram.findFigure(pt);
      
        if(!(figure instanceof CompositionLink)) {
          reset();
          return;
        }

        DiagramModel model = diagram.getModel();
        if(model == null) {
          reset();
          return;
        }

        link = (CompositionLink)figure;
        if(link.pointFor(pt.x, pt.y, LinkShappingTool.CLICK_TOLERANCE*2.0) != -1) {
          reset();
          return;
        }

        e.consume();
        fireToolStarted();        

        item = (CompositionItem)model.getValue(link);
        if(item == null) {
          item = new CompositionItem();
          model.setValue(link, item);
        }

        startEditing(pt);

      }

    }

  }

  protected void startEditing(Point pt) {
    popup.show(pt);        

  }

  protected void stopEditing(String n) {

    item.setCardinality(n); 

    DiagramUI ui  = (DiagramUI)diagram.getUI();
    ui.refreshFigure(link);

  }

  protected class Popup extends JPopupMenu {
    
    protected JTextField text = new JTextField();
    protected int n;

    public Popup() {

      super("Cardinality");

      JLabel lbl = new JLabel("Cardinality");
      lbl.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));

      add(lbl);
      add(text);

      lbl.setFont( getFont().deriveFont(Font.PLAIN, getFont().getSize()-1) );
      setDefaultLightWeightPopupEnabled(true);

      Border border = BorderFactory.createCompoundBorder(
                        BorderFactory.createLineBorder(Color.black),
                        BorderFactory.createEmptyBorder(1,1,1,1));

      border = BorderFactory.createCompoundBorder(
                        BorderFactory.createEmptyBorder(1,1,1,1), border);

      text.setBorder(border);

    }

    public void show(Point pt) {

      text.setText(item.getCardinality());
      super.show(diagram, pt.x, pt.y);

    }
    
    protected void firePopupMenuWillBecomeInvisible() {

      try { 
        stopEditing(text.getText());

      } catch(Throwable t) {}

      fireToolFinished();        
      reset();

    }

  }

  protected void reset() {
    diagram = null;
    item = null;
    link = null;
  }

}
```

File: uml.ui.IconManager
```java

package uml.ui;

import java.awt.Component;
import java.awt.Image;
import java.awt.MediaTracker;
import java.awt.Toolkit;
import java.net.URL;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;
import java.util.WeakHashMap;

import javax.swing.Icon;
import javax.swing.ImageIcon;

public class IconManager {

  private static IconManager instance = new IconManager();

  private WeakHashMap resourceMap = new WeakHashMap();
  private HashMap imageMap = new HashMap();

  private IconManager() { }

  static public IconManager getInstance() {
    return instance;
  }

  protected Image loadImageResource(String resourceName) {

    Toolkit kit = Toolkit.getDefaultToolkit();
    URL url = getClass().getResource(resourceName);

    if(url != null) {

      try {

        return kit.createImage((java.awt.image.ImageProducer)url.getContent());
        
      } catch(Throwable t) { 
        t.printStackTrace();
      }

    }

    return null;

  }

  public void registerImageResource(Component comp, String resourceName) {
    
    Vector v = (Vector)resourceMap.get(comp);

    if(v == null) { 
      v = new Vector();
      resourceMap.put(comp, v);
    }

    if(!v.contains(resourceName))
      v.add(resourceName);

  }
 
  public Image getImageResource(Component comp, String resourceName) {
    
    if(resourceName.charAt(0) != '/')
      resourceName = '/' + resourceName;

    Image img = null;
    if((img = (Image)imageMap.get(resourceName)) == null) {

      MediaTracker tracker = new MediaTracker(comp);

      Vector v = (Vector)resourceMap.get(comp);
      if(v != null) {

        resourceMap.remove(comp);
      
        for(Iterator i = v.iterator(); i.hasNext();)
          trackImage(tracker, (String)i.next());

      } 

      if(v == null || !v.contains(resourceName))
        trackImage(tracker, resourceName);

      try {
        tracker.waitForAll();
      } catch(InterruptedException e) { }
      
      if(tracker.checkAll())
        img = (Image)imageMap.get(resourceName);

    }

    if(img == null)
      throw new RuntimeException("Resource not found " + resourceName);

    return img;

  }

  private final Image trackImage(MediaTracker tracker, String resourceName) {

    Image img = loadImageResource(resourceName);
    if(img != null) {
      
      tracker.addImage(img, 1);
      imageMap.put(resourceName, img);
      
    }
    
    return img;

  }


  public Icon getIconResource(Component comp, String resourceName) {

    if(comp == null)
      throw new RuntimeException("Null component!");

    if(resourceName == null)
      throw new RuntimeException("Null resource name!");

    return new ImageIcon(getImageResource(comp, resourceName));
  }

}
```

File: uml.ui.CompositionTool
```java

package uml.ui;

import uml.diagram.CompositionLink;
import diagram.Figure;
import diagram.Link;
import diagram.tool.LinkTool;

public class CompositionTool extends LinkTool {

  protected Link createLink(Figure source, Figure sink) {
    return new CompositionLink(source, sink);
  }
  
}
```

File: uml.ui.FileAction
```java

package uml.ui;

import java.awt.Component;
import java.io.File;

import javax.swing.AbstractAction;
import javax.swing.Icon;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileFilter;

public abstract class FileAction extends AbstractAction {

  private SmartChooser chooser = new SmartChooser();

  public FileAction(String name, Icon icon) {
    super(name, icon);
  }

  public FileAction(String name) {
    super(name);
  }

  
  protected SmartChooser getChooser() {
    chooser.resetChoosableFileFilters();
    return chooser;
  }


  protected static class SmartChooser extends JFileChooser {
    
    protected static File lastDirectory = new File(System.getProperty("user.dir"));
    
    public void approveSelection() {
      
      super.approveSelection();
      
      lastDirectory = getSelectedFile();
      if(!lastDirectory.isDirectory())
        lastDirectory = lastDirectory.getParentFile();
      
    }
    
    public int showDialog(Component parent, String approveButtonText) {
      
      setCurrentDirectory(lastDirectory);
      return super.showDialog(parent, approveButtonText);
      
    }

    public String getLastDirectory() {
      return lastDirectory.getAbsolutePath();
    }



  protected class SimpleFilter extends FileFilter {
    
    private String[] extensions;
    private String description;

    public SimpleFilter(String extension, String description) {
      this(new String[]{extension}, description);
    }

    public SimpleFilter(String[] extensions, String description) {
      this.extensions = extensions;
      this.description = description;
    }

    public boolean accept(File file) {
    
      if(file.isDirectory())
        return true;

      String name = file.getName().toLowerCase();
      for(int i=0; i<extensions.length; i++)
        if(name.endsWith("." + extensions[i]))
          return true;
      
      return false;

    }
  
    public String getDescription() {

      StringBuffer buf = new StringBuffer(description);

      buf.append('(');

      for(int i=0; i<extensions.length; i++) {

        buf.append("*.").append(extensions[i]);
        if(i < (extensions.length-1))
          buf.append(", ");

      }
      
      buf.append(')');

      return buf.toString();
    }


}  
```

File: uml.ui.GeneralizationTool
```java

package uml.ui;

import uml.diagram.GeneralizationLink;
import diagram.Figure;
import diagram.Link;
import diagram.tool.LinkTool;

public class GeneralizationTool extends LinkTool {

  protected Link createLink(Figure source, Figure sink) {
    return new GeneralizationLink(source, sink);
  }
  
}
```

File: uml.ui.ScaledPrintableAction
```java

package uml.ui;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.print.PageFormat;
import java.awt.print.Printable;

import javax.swing.Icon;
import javax.swing.RepaintManager;


public abstract class ScaledPrintableAction extends PrintableAction {

  public ScaledPrintableAction(String name, Icon icon) {
    super(name, icon);
  }


  public int print(Graphics g, PageFormat pf, int pageIndex) {

    if(pageIndex > 0)
      return Printable.NO_SUCH_PAGE;

    Component component = getComponent();

    RepaintManager mgr = RepaintManager.currentManager(component);
    boolean isBuffered = mgr.isDoubleBufferingEnabled();
    mgr.setDoubleBufferingEnabled(false);  

    
    Graphics2D g2 = (Graphics2D)g;
   
    double sx = (double)pf.getImageableWidth() / (double)component.getWidth();
    double sy = (double)pf.getImageableHeight() / (double)component.getHeight();

    double scale = (sx < sy) ? sx : sy;
    g2.scale(scale, scale);

    double x = (double)pf.getImageableX() - (double)component.getX();
    double y = (double)pf.getImageableY() - (double)component.getY();

    g2.translate(x, y);

    component.paint(g2);

    mgr.setDoubleBufferingEnabled(isBuffered);  

    return Printable.PAGE_EXISTS;		
					
  }

}
```

File: uml.ui.SizePanel
```java


package uml.ui;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;

import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;

public class SizePanel extends JPanel {

  protected Dimension size = new Dimension();

  protected JTextField txtWidth = new JTextField();
  protected JTextField txtHeight = new JTextField();

  public SizePanel(Component component) {
    this(component.getWidth(), component.getHeight());
  }

  public SizePanel(int width, int height) {

    size.width = width;
    size.height = height;

    GridBagLayout gridbag = new GridBagLayout();
    GridBagConstraints gc = new GridBagConstraints();

    setLayout(gridbag);
    

    Component comp = new JLabel("Width:");
    
    gc.anchor = GridBagConstraints.WEST;
    gc.weightx = 1;
    gc.gridwidth = 1;
    
    gridbag.setConstraints(comp, gc);
    add(comp);

    comp = txtWidth;
    txtWidth.setText(Integer.toString(size.width));

    gc.gridwidth = GridBagConstraints.REMAINDER;
    gc.fill = GridBagConstraints.HORIZONTAL;
    gridbag.setConstraints(comp, gc);
    add(comp);

    comp = new JLabel("Height:");
    
    gc.weightx = 1;
    gc.gridwidth = 1;
    gc.fill = GridBagConstraints.NONE;
    
    gridbag.setConstraints(comp, gc);
    add(comp);

    comp = txtHeight;
    txtHeight.setText(Integer.toString(size.height));

    gc.gridwidth = GridBagConstraints.REMAINDER;
    gc.fill = GridBagConstraints.HORIZONTAL;

    gridbag.setConstraints(comp, gc);
    add(comp);

  }


  public int getSelectedWidth() {

    try {
      size.width = Integer.parseInt(txtWidth.getText());
    } catch(Throwable t) {}

    return size.width;

  }

  public int getSelectedHeight() {

    try {
      size.height = Integer.parseInt(txtHeight.getText());
    } catch(Throwable t) {}

    return size.height;

  }


  public Dimension getDimension(Dimension d) {

    if(d == null)
      d = new Dimension();

    d.width = getSelectedWidth();
    d.height = getSelectedHeight();
 
    return d;
  }

}
```

File: uml.ui.FontTile
```java

package uml.ui;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;

import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.UIManager;

public class FontTile extends JButton {

  private String title;
  private String fontProperty;

  public FontTile(String fontProperty) {
    this(fontProperty, "Choose a Color");
  }

  public FontTile(String fontProperty, String title) {

    this.fontProperty = fontProperty;
    this.title = title;

    Font font = UIManager.getFont(fontProperty);
    if(font == null)
      font = UIManager.getFont("Label.font");

    if(font != null) {
      setFont(font);    
      setText(font.getName());
    }

    setHorizontalAlignment(JLabel.CENTER);

  }

  public Dimension getMinimumSize() {
    return getPreferredSize();
  }

  public Dimension getPreferredSize() {
    Dimension dim = super.getPreferredSize();
    dim.height = 35;
    return dim;
  }

  protected void fireActionPerformed(ActionEvent event) {

    Font font = JFontChooser.showDialog(this, title, UIManager.getFont(fontProperty));
    if(font != null) {

      UIManager.put(fontProperty, font);
      setText(font.getName());

    }

  }

  
}
```

File: uml.ui.FlatMenuBar
```java
package uml.ui;

import java.awt.Color;
import java.awt.Font;
import java.awt.Insets;

import javax.swing.Action;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JMenu;
import javax.swing.JMenuBar;
import javax.swing.JMenuItem;
import javax.swing.KeyStroke;
import javax.swing.UIManager;

public class FlatMenuBar extends JMenuBar {

  private static Insets noInsets = new Insets(0,0,0,0);
  private int nextInsert = 0;

  static { 
    
    Font menuFont = UIManager.getFont("MenuItem.font");
    UIManager.put("MenuItem.font", menuFont.deriveFont(Font.PLAIN));
    UIManager.put("MenuItem.checkIcon", "No Icon");
    UIManager.put("CheckBoxMenuItem.font", menuFont.deriveFont(Font.PLAIN));

  }

  public JMenu getMenu(String menuTitle) {

    JMenu menu = null;
    int index = 0;

    for(int n=0; n < this.getMenuCount(); n++) {
      
      menu = this.getMenu(n);
      if(menu != null) {

        while(index < menuTitle.length() && menu.getMnemonic() == menuTitle.charAt(index)) 
          index++;
        
        if(menu.getText().compareTo(menuTitle) == 0) 
          return menu;

      }
    }
     
    menu = new Menu(menuTitle);
    if(index < menuTitle.length())
      menu.setMnemonic(menuTitle.charAt(index));
    
    int insertAt = this.getMenuCount() - nextInsert;
    super.add(menu, insertAt);

    if(menuTitle.toLowerCase().equals("help")) {
      super.add(Box.createHorizontalGlue(), insertAt);
      nextInsert -= 2;
    } 

    return menu;
    
  }

  public JMenu getHelpMenu() {
    return getMenu("Help");
  }

  protected class Menu extends JMenu {

    public Menu(String title) {

      super(title);

      this.setBorder(BorderFactory.createEmptyBorder(1,1,2,1));
      getPopupMenu().setBorder(BorderFactory.createLineBorder(Color.black));

    }
    
    public JMenuItem add(Action action) {

      JMenuItem item = new JMenuItem(action);

      item.setMargin(noInsets);
      item.setAccelerator((KeyStroke)action.getValue(Action.ACCELERATOR_KEY));

      return super.add(item);
    }

  }

}
```

File: uml.ui.DependencyTool
```java

package uml.ui;

import uml.diagram.DependencyLink;
import diagram.Figure;
import diagram.Link;
import diagram.tool.LinkTool;

public class DependencyTool extends LinkTool {

  protected Link createLink(Figure source, Figure sink) {
    return new DependencyLink(source, sink);
  }
  
}
```

File: uml.ui.FlatSplitPane
```java

package uml.ui;

import java.awt.Component;
import java.awt.Graphics;

import javax.swing.JComponent;
import javax.swing.JSplitPane;
import javax.swing.plaf.basic.BasicSplitPaneDivider;
import javax.swing.plaf.basic.BasicSplitPaneUI;

public class FlatSplitPane extends JSplitPane {

  public FlatSplitPane() {
  }

  public FlatSplitPane(int newOrientation) {
    super(newOrientation);
  }

  public FlatSplitPane(int newOrientation, boolean newContinuousLayout) {
    super(newOrientation, newContinuousLayout);
  }

  public FlatSplitPane(Component newLeftComponent, Component newRightComponent) {
    this(VERTICAL_SPLIT, newLeftComponent, newRightComponent);
  }

  public FlatSplitPane(int newOrientation, Component newLeftComponent, Component newRightComponent) {
    super(newOrientation, newLeftComponent, newRightComponent);
  }

  public FlatSplitPane(int newOrientation, boolean newContinuousLayout, Component newLeftComponent, Component newRightComponent) {
    super(newOrientation, newContinuousLayout, newLeftComponent, newRightComponent);
  }

  public void updateUI() {
    setUI(new FlatSplitPaneUI());
  }

  static protected class FlatSplitPaneUI extends BasicSplitPaneUI {
      
    public void installUI(JComponent c) { 

      super.installUI(c);
      divider.setBorder(null);

    }

    public BasicSplitPaneDivider createDefaultDivider() {
      return new FlatSplitPaneDivider(this);
    } 
  }

   
  static protected class FlatSplitPaneDivider extends BasicSplitPaneDivider {
      
    public FlatSplitPaneDivider(FlatSplitPaneUI ui) {
      super(ui);
    }

    public void paint(Graphics g) {

      int w = getWidth();
      int h = getHeight();

      g.fillRect(0, 0, w, h);    

    }

  }
    
}
```

File: uml.ui.border.NoteBorder
```java

package uml.ui.border;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Insets;

import javax.swing.border.AbstractBorder;

public class NoteBorder extends AbstractBorder {

  private int[] xPoints = new int[3];
  private int[] yPoints = new int[3];

  protected int thickness;
  protected int foldThickness;
  protected Color lineColor;
  protected boolean fillFold;

  public NoteBorder() {
    this(2, 6, null, true);
  }

  public NoteBorder(int thickness, int foldThickness, Color lineColor, boolean fillFold) {

    this.thickness = thickness;
    this.foldThickness = foldThickness;
    this.lineColor = lineColor;
    this.fillFold = fillFold;

  }

  public Insets getBorderInsets(Component c)       {
    return new Insets(thickness, foldThickness, thickness, thickness);
  }

  public Insets getBorderInsets(Component c, Insets insets) {
    insets.left = insets.right = insets.bottom = thickness;
    insets.top = foldThickness;
    return insets;
  }

  public Color getLineColor() {
    return lineColor;
  }

  public int getThickness() {
    return thickness;
  }

  public int getFoldThickness() {
    return foldThickness;
  }

  public void paintBorder(Component c, Graphics g, int x, int y, int w, int h) {

    g.setColor((lineColor == null) ? c.getBackground().darker() : lineColor);

    xPoints[0] = (x+w) - (foldThickness + thickness);
    xPoints[1] = xPoints[0];
    xPoints[2] = (x+w-1);

    yPoints[0] = y;
    yPoints[1] = y + foldThickness + (thickness - 1);
    yPoints[2] = yPoints[1];

    if(fillFold)
      g.fillPolygon(xPoints, yPoints, 3);

    int topX = (x + w) - (foldThickness + thickness) - 1;
    int topY = (y + foldThickness + thickness);

    for(int i = 0; i < thickness; i++)  {

      g.drawLine(x+i, y+i, x+i, y+h+i); // left
      g.drawLine(x+i, y+i, topX, y+i); // top

      g.drawPolygon(xPoints, yPoints, 3);

      xPoints[0]--; xPoints[1]--;
      yPoints[1]++; yPoints[2]++;

      g.drawLine(x+w-i-1, topY, x+w-i-1, y+h-i-1);
      g.drawLine(x+i, y+h-i-1, w-i-1, h-i-1); // bottom

    }

  }

}
```

File: uml.ui.border.ShadowBorder
```java

package uml.ui.border;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Insets;

import javax.swing.border.AbstractBorder;

public class ShadowBorder extends AbstractBorder {

  public final static int NORTHEAST = 1;
  public final static int NORTHWEST = 2;
  public final static int SOUTHEAST = 3;
  public final static int SOUTHWEST = 4;

  private int size;
  private Color color;
  private int orientation;

  public ShadowBorder()  {
    this(null,0,5);
  }

  public ShadowBorder(Color c,int orientation, int size) {
    this.color = c;
    this.orientation = orientation;
    this.size = size;
  }

  public void paintBorder(Component comp, Graphics g, int x, int y, int width, int height) {

    g.setColor(color == null ? comp.getBackground().darker() : color);
    switch (orientation) {
    case NORTHWEST:
      g.fillRect(x,y,width-size,size); // horiz
      g.fillRect(x,y,size,height-size); // vert
    case NORTHEAST:
      g.fillRect(x+size,y,width-size,size); // horiz
      g.fillRect(x+width-size,y,size,height-size); // vert
    case SOUTHWEST:
      g.fillRect(x,y+height-size,width-size,size); // horiz
      g.fillRect(x,y+size,size,height-size); // vert
    case SOUTHEAST:
    default:
      g.fillRect(x+size,y+height-size,width-size,size); // horiz
      g.fillRect(x+width-size,y+size,size,height-size); // vert
    }

  }

  public Insets getBorderInsets(Component c) {
    return getBorderInsets(c,new Insets(0,0,0,0));
  }

  public Insets getBorderInsets(Component c, Insets i) {

    switch (orientation)  {
    case NORTHWEST:
      i.left=size;
      i.right=0;
      i.top=size;
      i.bottom=0;
      break;
    case NORTHEAST:
      i.left=0;
      i.right=size;
      i.top=size;
      i.bottom=0;
      break;
    case SOUTHWEST:
      i.left=size;
      i.right=0;
      i.top=0;
      i.bottom=size;
      break;
    case SOUTHEAST:
    default:
      i.left=0;
      i.right=size;
      i.top=0;
      i.bottom=size;
    }
    return i;
  }

}
```

File: uml.diagram.NoteEditor
```java

package uml.diagram;

import java.awt.Component;

import diagram.DefaultFigureEditor;
import diagram.Diagram;
import diagram.Figure;

public class NoteEditor extends DefaultFigureEditor {

  private NoteRenderer renderer = new NoteRenderer();
  private NoteComponent noteComponent;

  public Component getFigureEditorComponent(Diagram diagram, Figure figure, boolean isSelected) {

    Component editorComponent = renderer.getRendererComponent(diagram, figure, isSelected);
    noteComponent = (NoteComponent)renderer.getUserComponent();
    
    return editorComponent;

  }

  
  public Object getCellEditorValue() {
    return noteComponent.getText();
  }


}
```

File: uml.diagram.InterfaceEditor
```java

package uml.diagram;

import java.awt.Component;

import diagram.DefaultFigureEditor;
import diagram.Diagram;
import diagram.Figure;


public class InterfaceEditor extends DefaultFigureEditor {

  protected InterfaceRenderer renderer = new InterfaceRenderer();
  protected InterfaceComponent interfaceComponent;

  protected InterfaceItem lastValue;

  public Component getFigureEditorComponent(Diagram diagram, Figure figure, boolean isSelected) {

    lastValue = (InterfaceItem)diagram.getModel().getValue(figure);
  
    Component editorComponent = renderer.getRendererComponent(diagram, figure, isSelected);
    interfaceComponent = (InterfaceComponent)renderer.getUserComponent();
    
    return editorComponent;

  }

  public Object getCellEditorValue() {

    if(lastValue == null)
      lastValue = new InterfaceItem();

    lastValue.setName(interfaceComponent.getTitle());
    lastValue.setDescription(interfaceComponent.getMembers());

    return lastValue;
    
  }

 
}
```

File: uml.diagram.RealizationItem
```java

package uml.diagram;

public class RealizationItem extends DesignItem {

  public RealizationItem() {
    super(null);
  }

  public String getType() {
    return "realization";
  }

}
```

File: uml.diagram.InterfaceItem
```java

package uml.diagram;

public class InterfaceItem extends DesignItem {

  public InterfaceItem() {
    this(null);
  }

  public InterfaceItem(String interfaceName) {
    super(interfaceName);
  }

  public String getType() {
    return "interface";
  }

}
```

File: uml.diagram.ClassItem
```java

package uml.diagram;




public class ClassItem extends DesignItem {

  protected String attributes;

  public ClassItem() {
    this(null);
  }

  public ClassItem(String className) {
    super(className);
  } 

  public String getType() {
    return "class";
  }

  public void setAttributes(String attributes) {
    this.attributes = attributes;
  }

  public String getAttributes() {
    return (attributes != null) ? attributes : "";
  }

}
```

File: uml.diagram.GeneralizationLinkRenderer
```java

package uml.diagram;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;

import javax.swing.UIManager;

import diagram.DefaultLinkRenderer;
import diagram.shape.ArrowHead;

public class GeneralizationLinkRenderer extends DefaultLinkRenderer {

  protected static final CustomUI generalizationUI = new CustomUI("generalization");

  static {
    UIManager.put("generalization.foreground", Color.black);
    UIManager.put("generalization.background", Color.white);
  }

  public GeneralizationLinkRenderer() {
    setUI(generalizationUI);
  }

  protected GeneralPath getSourceEndpoint(double x, double y, GeneralPath path) {
    return null;
  }

  protected GeneralPath getSinkEndpoint(double x, double y, GeneralPath path) {
    return ArrowHead.createArrowHead(13.0, ArrowHead.FLAT, x, y, path);
  }

  protected void paintSinkEndpoint(Graphics2D g2, AffineTransform at, GeneralPath path) {

    g2.setPaint(getBackground());
    super.paintSinkEndpoint(g2, at, path);

    g2.setPaint(getForeground());
    g2.draw(path);

  }


}
```

File: uml.diagram.AssociationLink
```java

package uml.diagram;

import diagram.Figure;
import diagram.figures.PolyLink;

public class AssociationLink extends PolyLink {
  
  public AssociationLink(Figure f1, Figure f2) {
    super(f1, f2);
  }

}
```

File: uml.diagram.AbstractLayout
```java

package uml.diagram;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.LayoutManager2;
import java.io.Serializable;

public abstract class AbstractLayout 
  implements LayoutManager2, Serializable {

  protected int hgap;
  protected int vgap;
  
  public AbstractLayout()   {
    this(0, 0);
  }
  
  public AbstractLayout(int hgap, int vgap) {
    this.hgap = hgap;
    this.vgap = vgap;
  }

  public int getHgap() {
    return hgap;
  }

  public int getVgap() {
    return vgap; 
  }

  public void setHgap(int hgap) {
    this.hgap = hgap;
  }
  
  public void setVgap(int vgap) {
    this.vgap = vgap;
  }

  public Dimension maximumLayoutSize(Container target) {
    return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);
  }

  public void addLayoutComponent(String name, Component comp) {
    addLayoutComponent(comp, name);
  }
  
  public Dimension minimumLayoutSize(Container parent) {
    return parent.getMinimumSize();
  }


  public Dimension preferredLayoutSize(Container parent) {
    return parent.getPreferredSize();
  }
  
  
  public void removeLayoutComponent(Component comp) {
    throw new UnsupportedOperationException();
  }

  public float getLayoutAlignmentY(Container target) {
    return 0.05f;
  }

  public float getLayoutAlignmentX(Container target) {
    return 0.05f;
  }

  public String toString() {

    StringBuffer buf = new StringBuffer();

    buf.append(getClass().getName());
    buf.append("[hgap=").append(hgap);
    buf.append(",vgap=").append(vgap).append("]");

    return buf.toString();

  }

}
```

File: uml.diagram.CompositionLinkRenderer
```java

package uml.diagram;

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;

import javax.swing.UIManager;

import diagram.DefaultLinkRenderer;
import diagram.Diagram;
import diagram.Figure;
import diagram.shape.DiamondHead;

public class CompositionLinkRenderer extends DefaultLinkRenderer {

  protected static final CustomUI compositionUI = new CustomUI("composition"); 

  private double angle, sourceX, sourceY;
  private String cardinality;
  private Point pt = new Point();

  static {
    UIManager.put("composition.foreground", Color.black);
    UIManager.put("composition.background", Color.white);
  }

  public CompositionLinkRenderer() {
    
    super(new SinkLabelRenderer());

    setUI(compositionUI);

  }

  public Component getRendererComponent(Diagram diagram, Figure figure, boolean isSelected) {

    CompositionItem item = (CompositionItem)diagram.getModel().getValue(figure);
    cardinality = item == null ? "" : item.getCardinality();

    return super.getRendererComponent(diagram, figure, isSelected);

  }

  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds) {

    rcBounds = super.getDecoratedBounds(diagram, figure, rcBounds);
    Font font = getFont();
    if(font == null)
      return rcBounds;
 
    FontMetrics metrics = getFontMetrics(font);    
    int expansion = (int)getExpansion();

    int h = Math.max(metrics.getHeight() + 4 - expansion, 0);
    int w = metrics.charsWidth(cardinality.toCharArray(), 0, cardinality.length());
    w = Math.max(w - expansion, 0);

    rcBounds.setFrame( rcBounds.getX() - w, 
                       rcBounds.getY() - h, 
                       rcBounds.getWidth() + w*2, 
                       rcBounds.getHeight() + h*2);

    return rcBounds; 

  }

  protected GeneralPath getSinkEndpoint(double x, double y, GeneralPath path) {
    return DiamondHead.createDiamondHead(x, y, 7.0, 6.0, path);
  }

  protected GeneralPath getSourceEndpoint(double x, double y, GeneralPath path) {
    return DiamondHead.createDiamondHead(x, y, 7.0, 6.0, path);
  }


  protected double getSinkAngle(double x1, double y1, double x2, double y2) {

    double angle = super.getSinkAngle(x1, y1, x2, y2); 

    FontMetrics metrics = getFontMetrics(getFont());

    int h = metrics.getHeight();
    int w = metrics.charsWidth(cardinality.toCharArray(), 0, cardinality.length());

    pt.x = (int)(x2 + 24.0);
    pt.y = (int)(y2 - 4.0);

    if(angle <= -Math.PI/4)
      pt.translate(w, 0);

    else if(angle > -Math.PI/4 && angle < Math.PI/4) 
      pt.translate(w, -h);
    
    else if(angle <= Math.PI*3/4) 
      pt.translate(0, -h);

    else if(angle <= Math.PI*5/4) 
      pt.translate(0, 0);

      
    return (this.angle = angle);

  }


  protected void paintSourceEndpoint(Graphics2D g2, AffineTransform at, GeneralPath path) {
    
    g2.setPaint(getBackground());
    super.paintSourceEndpoint(g2, at, path);

    g2.setPaint(getForeground());
    g2.draw(path);
  }

  protected void paintSinkEndpoint(Graphics2D g2, AffineTransform at, GeneralPath path) {

    at.transform(pt, pt);
    g2.drawString(cardinality, (float)pt.x, (float)pt.y);

  }

}
```

File: uml.diagram.CustomComponent
```java


package uml.diagram;

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Font;

import javax.swing.JComponent;


public class CustomComponent extends JComponent {


  public void setForeground(Color c) {

    super.setForeground(c);
    setForeground(this, c);

  }

  public void setBackground(Color c) {

    super.setBackground(c);
    setBackground(this, c);

  }

  public void setFont(Font font) {
    
    super.setFont(font);
    setFont(this, font);

  } 

  public static void setBackground(Container parent, Color c) {

    Component[] children = parent.getComponents();
    for(int i=0; i < children.length; i++) {

      Component comp = children[i];   
      comp.setBackground(c);
      
      if(comp instanceof Container)
        setBackground((Container)comp, c);
            
    }
    
  }


  public static void setForeground(Container parent, Color c) {

    Component[] children = parent.getComponents();
    for(int i=0; i < children.length; i++) {

      Component comp = children[i];   
      comp.setForeground(c);
      
      if(comp instanceof Container)
        setForeground((Container)comp, c);
            
    }
    
  }

  public static void setFont(Container parent, Font font) {

    Component[] children = parent.getComponents();
    for(int i=0; i < children.length; i++) {

      Component comp = children[i];   
      comp.setFont(font);
      
      if(comp instanceof Container)
        setFont((Container)comp, font);
            
    }
    
  }

}
```

File: uml.diagram.NoteComponent
```java

package uml.diagram;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Insets;

import javax.swing.UIManager;

import uml.ui.FlatTextArea;

public class NoteComponent extends CustomComponent {

  protected static final CustomUI noteUI = new CustomUI("note");
  protected static final Insets margin = new Insets(1,1,1,1);
  
  protected FlatTextArea text = new FlatTextArea(true);

  static { // Set up some default colors

    UIManager.put("note.background", new Color(0xFF, 0xFF, 0xEE));
    UIManager.put("note.foreground", Color.black);
    UIManager.put("note.border", new NoteBorder());

  }

  public NoteComponent() {

    setLayout(new BorderLayout());

    text.setBorder(null);
    text.setMargin(margin);
    add(text);

    setUI(noteUI);

  }

  public void setText(String s) {
    text.setText(s);
  }
  
  public String getText() {
    return text.getText();
  }

 
}
```

File: uml.diagram.InterfaceRenderer
```java

package uml.diagram;

import java.awt.Component;

import diagram.DefaultFigureRenderer;

public class InterfaceRenderer extends DefaultFigureRenderer {

  protected InterfaceComponent interfaceComponent = new InterfaceComponent();

  public Component getUserComponent() {

    InterfaceItem item = (InterfaceItem)getDiagram().getModel().getValue(getFigure());

    interfaceComponent.setTitle( (item == null) ? null : item.getName() );
    interfaceComponent.setMembers( (item == null) ? "" : item.getDescription() );

    return interfaceComponent;

  }


}
```

File: uml.diagram.DependencyLinkEditor
```java

package uml.diagram;

import diagram.DefaultLinkEditor;

public class DependencyLinkEditor extends DefaultLinkEditor {

  protected DependencyItem lastValue;

  public Object getCellEditorValue() {

    if(lastValue == null)
      lastValue = new DependencyItem();

    lastValue.setName((String)super.getCellEditorValue());
    return lastValue;

  }

}
```

File: uml.diagram.InterfaceFigure
```java

package uml.diagram;

import diagram.figures.RectangularFigure;


public class InterfaceFigure extends RectangularFigure {

  public InterfaceFigure() {
    super(100,75);
  }

}
```

File: uml.diagram.NoteFigure
```java

package uml.diagram;

import diagram.figures.RectangularFigure;

public class NoteFigure extends RectangularFigure {

  public NoteFigure() {
    super(100,100);
  }

}
```

File: uml.diagram.NoteBorder
```java

package uml.diagram;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Insets;

import javax.swing.border.AbstractBorder;

public class NoteBorder extends AbstractBorder {

  private int[] xPoints = new int[3];
  private int[] yPoints = new int[3];

  protected int thickness;
  protected int foldThickness;
  protected Color lineColor;
  protected boolean fillFold;

  public NoteBorder() {
    this(2, 6, Color.black, true);
  }

  public NoteBorder(int thickness, int foldThickness, Color lineColor, boolean fillFold) {

    this.thickness = thickness;
    this.foldThickness = foldThickness;
    this.lineColor = lineColor;
    this.fillFold = fillFold;

  }

  public Insets getBorderInsets(Component c)       {
    return new Insets(foldThickness+thickness+1, thickness, thickness, foldThickness+thickness+1);
  }

  public Insets getBorderInsets(Component c, Insets insets) {
    insets.left = insets.bottom = thickness;
    insets.right = insets.top = foldThickness+thickness+1;
    return insets;
  }

  public Color getLineColor() {
    return lineColor;
  }

  public int getThickness() {
    return thickness;
  }

  public int getFoldThickness() {
    return foldThickness;
  }

  public void paintBorder(Component c, Graphics g, int x, int y, int w, int h) {
    
    g.setColor(c.getBackground());
    g.fillRect(x+thickness, y+thickness, ((x+w)-(foldThickness+thickness)+1), foldThickness+1);
    g.fillRect((x+w)-(foldThickness+thickness+1), y+thickness+foldThickness,
               foldThickness+1, (y+h)-(foldThickness+thickness));

    g.setColor((lineColor == null) ? c.getBackground().darker() : lineColor);

    xPoints[0] = (x+w) - (foldThickness + thickness);
    xPoints[1] = xPoints[0];
    xPoints[2] = (x+w-1);

    yPoints[0] = y;
    yPoints[1] = y + foldThickness + (thickness - 1);
    yPoints[2] = yPoints[1];

    if(fillFold)
      g.fillPolygon(xPoints, yPoints, 3);

    int topX = (x + w) - (foldThickness + thickness) - 1;
    int topY = (y + foldThickness + thickness);

    for(int i = 0; i < thickness; i++)  {

      g.drawLine(x+i, y+i, x+i, y+h+i); // left
      g.drawLine(x+i, y+i, topX, y+i); // top

      g.drawPolygon(xPoints, yPoints, 3);

      xPoints[0]--; xPoints[1]--;
      yPoints[1]++; yPoints[2]++;

      g.drawLine(x+w-i-1, topY, x+w-i-1, y+h-i-1);
      g.drawLine(x+i, y+h-i-1, w-i-1, h-i-1); // bottom

    }

  }

}
```

File: uml.diagram.DesignItem
```java


package uml.diagram;

import java.io.Serializable;

public abstract class DesignItem implements Cloneable, Serializable {

  protected String itemName;
  protected String itemDescription;

  public DesignItem(String itemName) {
    setName(itemName);
  }
  
  public void setDescription(String itemDescription) {
    this.itemDescription = itemDescription;
  }

  public String getName() {
    return itemName;
  }

  public void setName(String itemName) {
    this.itemName = itemName;
  }

  public String getDescription() {
    return itemDescription;
  }
  
  abstract public String getType();

  public String toString() {
    return itemName;
  }

}
```

File: uml.diagram.ClassEditorComponent
```java

package uml.diagram;

import java.awt.Color;
import java.awt.Insets;

import javax.swing.BorderFactory;
import javax.swing.JTextField;

import uml.ui.FlatSplitPane;
import uml.ui.FlatTextArea;

public class ClassEditorComponent extends CustomComponent {

  protected static final CustomUI classUI = new CustomUI("class");
  protected static final Insets margin = new Insets(1,1,1,1);

  protected JTextField title = new JTextField();
  protected FlatSplitPane pane;
  protected FlatTextArea fields = new FlatTextArea(true);
  protected FlatTextArea members = new FlatTextArea(true);

  public ClassEditorComponent() {

    this.setLayout(null);
      
    title.setBorder(BorderFactory.createLineBorder(Color.black, 1));
    title.setOpaque(true);
    title.setMargin(margin);
    title.setHorizontalAlignment(JTextField.CENTER);

    this.add(title);

    fields.setBorder(null);
    fields.setMargin(margin);

    members.setBorder(null);
    members.setMargin(margin);

    pane = new FlatSplitPane(fields, members);
    pane.setBorder(BorderFactory.createLineBorder(Color.black, 1));
    pane.setDividerSize(2);
    
    this.add(pane);

    setUI(classUI);
    setBorder(BorderFactory.createCompoundBorder(BorderFactory.createCompoundBorder(new diagram.SelectionBorder(), BorderFactory.createEmptyBorder(2,2,2,2)),getBorder()));

  }

  public void setEnabled(boolean enabled) {
    super.setEnabled(enabled);
    pane.setEnabled(enabled);
  }

  public int getDividerLocation() {
    return pane.getDividerLocation();
  }

  public void setDividerLocation(int lastDividerLocation) {
    pane.setDividerLocation(lastDividerLocation);
  }


  public void setTitle(String s) {
    title.setText(s);
  }

  public String getTitle() {
    return title.getText();
  }

  public void setFields(String s) {
    fields.setText(s);
  }

  public String getFields() {
    return fields.getText();
  }

  public void setMembers(String s) {
    members.setText(s);
  }

  public String getMembers() {
    return members.getText();
  }
  
  public void doLayout() {

    Insets insets = this.getInsets();

    int w = this.getWidth() - (insets.left + insets.right);
    int h = this.getHeight() - (insets.top + insets.bottom);
    
    int x = insets.left;
    int y = insets.top;

    int componentHeight = title.getPreferredSize().height + 2;

    title.setBounds(x, y, w, componentHeight);

    y += componentHeight;
    h -= componentHeight;
    pane.setBounds(x, y, w, h);
  }

}
```

File: uml.diagram.AssociationLinkEditor
```java

package uml.diagram;

import diagram.DefaultLinkEditor;

public class AssociationLinkEditor extends DefaultLinkEditor {

  protected AssociationItem lastValue;

  public Object getCellEditorValue() {

    if(lastValue == null)
      lastValue = new AssociationItem();

    lastValue.setName((String)super.getCellEditorValue());
    return lastValue;

  }

}
```

File: uml.diagram.DependencyLink
```java

package uml.diagram;

import diagram.Figure;
import diagram.figures.PolyLink;


public class DependencyLink extends PolyLink {
  
  public DependencyLink(Figure f1, Figure f2) {
    super(f1, f2);
  }

}
```

File: uml.diagram.GeneralizationLink
```java

package uml.diagram;

import diagram.Figure;
import diagram.figures.PolyLink;

public class GeneralizationLink extends PolyLink {

  public GeneralizationLink(Figure f1, Figure f2) {
    super(f1, f2);
  }

}
```

File: uml.diagram.CustomUI
```java

package uml.diagram;

import java.awt.Color;
import java.awt.Font;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;

import javax.swing.JComponent;
import javax.swing.UIManager;
import javax.swing.border.Border;
import javax.swing.plaf.ComponentUI;

public class CustomUI extends ComponentUI 
  implements PropertyChangeListener {
  
  protected ArrayList components = new ArrayList();
  protected String prefix;

  public CustomUI(String prefix) {

    if(prefix == null)
      throw new IllegalArgumentException();

    this.prefix = prefix;
    UIManager.getDefaults().addPropertyChangeListener(this);   

  }


  public void installUI(JComponent c) {

    if(components.contains(c))
      return;

    components.add(c);

    Color fg = UIManager.getColor(getPropertyPrefix() + ".foreground");
    if(fg != null)
      c.setForeground(fg);

    Color bg = UIManager.getColor(getPropertyPrefix() + ".background");
    if(bg != null)
      c.setBackground(bg);

    Border border = UIManager.getBorder(getPropertyPrefix() + ".border");
    if(border != null)
      c.setBorder(border);
    
    Font font = UIManager.getFont(getPropertyPrefix() + ".font"); 
    if(font != null)
      c.setFont(font);

  }
  
  public void uninstallUI(JComponent c) {
    components.remove(c);
  }

  protected String getPropertyPrefix() {
    return prefix;
  }

  public void propertyChange(PropertyChangeEvent e) {
    
    String name = e.getPropertyName();

    if(name.equals(getPropertyPrefix() + ".foreground")) {

      Color fg = (Color)e.getNewValue();
      if(fg != null) {

        for(int i=0; i < components.size(); i++)
          ((JComponent)components.get(i)).setForeground(fg);

      }

    } else if(name.equals(getPropertyPrefix() + ".background")) {

      Color bg = (Color)e.getNewValue();     
      if(bg != null) {

        for(int i=0; i < components.size(); i++)
          ((JComponent)components.get(i)).setBackground(bg);
            
      }

    } else if(name.equals(getPropertyPrefix() + ".border")) {

      Border border = (Border)e.getNewValue();
      if(border != null) {

        for(int i=0; i < components.size(); i++)
          ((JComponent)components.get(i)).setBorder(border);

      }

    } else if(name.equals(getPropertyPrefix() + ".font")) {

      Font font = (Font)e.getNewValue();
      if(font != null) {

        for(int i=0; i < components.size(); i++)
          ((JComponent)components.get(i)).setFont(font);

      }

    }

  }


}
```

File: uml.diagram.CompositionLinkEditor
```java

package uml.diagram;

import diagram.DefaultLinkEditor;

public class CompositionLinkEditor extends DefaultLinkEditor {

  protected CompositionItem lastValue;

  public CompositionLinkEditor() {
    super(new SinkLabelRenderer());
  }

  public Object getCellEditorValue() {

    if(lastValue == null)
      lastValue = new CompositionItem();

    lastValue.setName((String)super.getCellEditorValue());
    return lastValue;

  }

}
```

File: uml.diagram.CompositionLink
```java

package uml.diagram;

import diagram.Figure;
import diagram.figures.PolyLink;

public class CompositionLink extends PolyLink {
  
  public CompositionLink(Figure f1, Figure f2) {
    super(f1, f2);
  }

}
```

File: uml.diagram.DependencyItem
```java

package uml.diagram;

public class DependencyItem extends DesignItem {

  public DependencyItem() {
    this(null);
  }

  public DependencyItem(String name) {
    super(name);
  }

  public String getType() {
    return "dependency";
  }

}
```

File: uml.diagram.InterfaceComponent
```java

package uml.diagram;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Insets;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JTextField;
import javax.swing.UIManager;

import uml.ui.FlatTextArea;

public class InterfaceComponent extends CustomComponent {

  protected static final CustomUI interfaceUI = new CustomUI("interface");
  protected static final Insets margin = new Insets(1,1,1,1);

  protected JLabel label = new JLabel("<< interface >>", JLabel.CENTER);
  protected JTextField title = new JTextField();
  protected FlatTextArea members = new FlatTextArea(true);
    
  static { // Set up some default colors

    UIManager.put("interface.background", new Color(0xFF, 0xFF, 0xDD));
    UIManager.put("interface.foreground", Color.black);
    UIManager.put("interface.border", BorderFactory.createLineBorder(Color.black, 1));

  }

  public InterfaceComponent() {

    this.setLayout(null);
      
    label.setOpaque(true);
    this.add(label);

    title.setOpaque(true);
    title.setHorizontalAlignment(JTextField.CENTER);
    title.setMargin(margin);
    title.setBorder(null);

    this.add(title);
      
    members.setBorder(BorderFactory.createLineBorder(Color.black, 1));    
    members.setMargin(margin);
    this.add(members);

    setUI(interfaceUI);
    setFont( title.getFont() );

  }

  public void setTitle(String s) {
    title.setText(s);
  }

  public String getTitle() {
    return title.getText();
  }

  public void setMembers(String s) {
    members.setText(s);
  }

  public String getMembers() {
    return members.getText();
  }

  public void setFont(Font font) {

    super.setFont(font);

    font = font.deriveFont(Font.ITALIC|Font.PLAIN, font.getSize() - 2.0f);
    label.setFont(font);

  }

  public void doLayout() {

    Insets insets = this.getInsets();

    int w = this.getWidth() - (insets.left + insets.right);
    int h = this.getHeight() - (insets.top + insets.bottom);
    
    int x = insets.left;
    int y = insets.top;

    int componentHeight = label.getPreferredSize().height+2;
    label.reshape(x+1, y+1, w-2, componentHeight);

    y += componentHeight+1;
    h -= componentHeight+1;

    componentHeight = title.getPreferredSize().height+2;
    title.setBounds(x+1, y, w-2, componentHeight);

    y += componentHeight+1;
    h -= componentHeight+1;

    componentHeight = h;
    members.setBounds(x, y, w, componentHeight);

  }

  public void paintBorder(Graphics g) {

    super.paintBorder(g);

    Insets insets = this.getInsets();

    int x = insets.left;
    int y = insets.top;
    int w = label.getWidth() + 1;
    int h = label.getHeight() + title.getHeight() + 1;

    g.setColor(Color.black);
    g.drawRect(x, y, w, h);

  }

}
```

File: uml.diagram.GeneralizationLinkEditor
```java

package uml.diagram;

import diagram.DefaultLinkEditor;

public class GeneralizationLinkEditor extends DefaultLinkEditor {

  protected GeneralizationItem lastValue;

  public Object getCellEditorValue() {

    if(lastValue == null)
      lastValue = new GeneralizationItem();

    lastValue.setName((String)super.getCellEditorValue());
    return lastValue;

  }

}
```

File: uml.diagram.DependencyLinkRenderer
```java

package uml.diagram;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;

import javax.swing.UIManager;

import diagram.DefaultLinkRenderer;
import diagram.shape.ArrowHead;


public class DependencyLinkRenderer extends DefaultLinkRenderer  {

  protected static final CustomUI dependencyUI = new CustomUI("dependency");

  protected final static BasicStroke normal = new BasicStroke(1);
  protected final static BasicStroke dashed = 
  new BasicStroke(1.0f, BasicStroke.CAP_ROUND, 
                  BasicStroke.JOIN_MITER, 10.0f, new float[] {5.0f}, 0.0f);
  
  static {
    UIManager.put("dependency.foreground", Color.black);
    UIManager.put("dependency.background", Color.white);
  }

  public DependencyLinkRenderer() {
    setUI(dependencyUI);
  }

  public void paintComponent(Graphics g) {
    ((Graphics2D)g).setStroke(dashed);
    super.paintComponent(g);
  }

  protected GeneralPath getSourceEndpoint(double x, double y, GeneralPath path) {
    return null;
  }

  protected GeneralPath getSinkEndpoint(double x, double y, GeneralPath path) {
    return ArrowHead.createArrowHead(13.0, ArrowHead.OPEN, x, y, path);
  }

  protected void paintSinkEndpoint(Graphics2D g2, AffineTransform at, GeneralPath path) {

    g2.setStroke(normal);
    super.paintSinkEndpoint(g2, at, path);

    g2.draw(path);
    g2.setStroke(dashed);

  }


}
```

File: uml.diagram.ClassEditor
```java

package uml.diagram;

import java.awt.Component;

import diagram.DefaultFigureEditor;
import diagram.Diagram;
import diagram.Figure;


public class ClassEditor extends DefaultFigureEditor {

  protected ClassEditorComponent classComponent = new ClassEditorComponent();

  protected ClassFigure lastFigure;
  protected ClassItem lastValue;

  public Component getFigureEditorComponent(Diagram diagram, Figure figure, boolean isSelected) {

    lastValue = (ClassItem)diagram.getModel().getValue(figure);
    lastFigure = (ClassFigure)figure;

    int last = lastFigure.getDividerLocation();    
    classComponent.setDividerLocation(last);
    
    return classComponent;

  }

  protected void fireEditingStopped() {

    super.fireEditingStopped(); 

    int last = classComponent.getDividerLocation();    
    lastFigure.setDividerLocation(last);

  }


  public Object getCellEditorValue() {

    if(lastValue == null)
      lastValue = new ClassItem();

    lastValue.setName(classComponent.getTitle());
    lastValue.setAttributes(classComponent.getFields());
    lastValue.setDescription(classComponent.getMembers());

    return lastValue;

  }


}
```

File: uml.diagram.RealizationLinkRenderer
```java

package uml.diagram;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;

import javax.swing.UIManager;

import diagram.DefaultLinkRenderer;
import diagram.shape.ArrowHead;

public class RealizationLinkRenderer extends DefaultLinkRenderer {
  
  protected static final CustomUI realizationUI = new CustomUI("realization");

  protected final static BasicStroke normal = new BasicStroke(1);
  protected final static BasicStroke dashed = new BasicStroke(1.0f, 
                                                              BasicStroke.CAP_ROUND, 
                                                              BasicStroke.JOIN_MITER, 
                                                              10.0f, new float[] {5.0f}, 0.0f);

  static {
    UIManager.put("realization.foreground", Color.black);
    UIManager.put("realization.background", Color.white);
  }

  public RealizationLinkRenderer() {

    setUI(realizationUI);

  }

  public void paintComponent(Graphics g) {
    ((Graphics2D)g).setStroke(dashed);
    super.paintComponent(g);
  }
  
  protected GeneralPath getSourceEndpoint(double x, double y, GeneralPath path) {
    return null;
  }

  protected GeneralPath getSinkEndpoint(double x, double y, GeneralPath path) {
    return ArrowHead.createArrowHead(13.0, ArrowHead.FLAT, x, y, path);
  }

  protected void paintSinkEndpoint(Graphics2D g2, AffineTransform at, GeneralPath path) {
    
    g2.setStroke(normal);
    g2.setPaint(getBackground());

    super.paintSinkEndpoint(g2, at, path);

    g2.setPaint(getForeground());
    g2.draw(path);
    g2.setStroke(dashed);

  }


}
```

File: uml.diagram.CompositionItem
```java

package uml.diagram;




public class CompositionItem extends DesignItem {

  protected String cardinality = "";

  public CompositionItem() {
    this(null);
  }

  public CompositionItem(String associationName) {
    super(associationName);
  }

  public String getType() {
    return "association";
  }

  public String getCardinality() {
    return cardinality;
  }

  public void setCardinality(String cardinality) {
    this.cardinality = cardinality;
  }


}
```

File: uml.diagram.NoteRenderer
```java

package uml.diagram;

import java.awt.Component;

import diagram.DefaultFigureRenderer;


public class NoteRenderer extends DefaultFigureRenderer {

  protected NoteComponent noteComponent = new NoteComponent();

  public Component getUserComponent() {

    String text = (String)getDiagram().getModel().getValue(getFigure());
    noteComponent.setText(text);

    return noteComponent;

  }


}
```

File: uml.diagram.ClassRendererComponent
```java
package uml.diagram;

import java.awt.Color;
import java.awt.Insets;

import javax.swing.BorderFactory;
import javax.swing.JTextField;
import javax.swing.UIManager;

import uml.ui.FlatTextArea;

public class ClassRendererComponent extends CustomComponent {

  protected static final CustomUI classUI = new CustomUI("class");
  protected static final Insets margin = new Insets(1,1,1,1);

  protected JTextField title = new JTextField();
  protected FlatTextArea fields = new FlatTextArea(true);
  protected FlatTextArea members = new FlatTextArea(true);
  protected int divider = -1;

  static { // Set up some default colors

    UIManager.put("class.background", new Color(0xFF, 0xFF, 0xDD));
    UIManager.put("class.foreground", Color.black);
    UIManager.put("class.border", BorderFactory.createLineBorder(Color.black, 1));

  }

  public ClassRendererComponent() {

    this.setLayout(null);
      
    title.setBorder(BorderFactory.createLineBorder(Color.black, 1));
    title.setOpaque(true);
    title.setMargin(margin);
    title.setHorizontalAlignment(JTextField.CENTER);

    this.add(title);

    fields.setBorder(BorderFactory.createLineBorder(Color.black, 1));
    fields.setMargin(margin);
    this.add(fields);

    members.setBorder(BorderFactory.createLineBorder(Color.black, 1));
    members.setMargin(margin);
    this.add(members);

    setUI(classUI);

  }


  public void setTitle(String s) {
    title.setText(s);
  }

  public String getTitle() {
    return title.getText();
  }

  public void setFields(String s) {
    fields.setText(s);
  }

  public String getFields() {
    return fields.getText();
  }

  public void setMembers(String s) {
    members.setText(s);
  }

  public String getMembers() {
    return members.getText();
  }

  public void setDivider(int divider) {
    this.divider = divider;
  }

  public void doLayout() {

    Insets insets = this.getInsets();

    int w = this.getWidth() - (insets.left + insets.right);
    int h = this.getHeight() - (insets.top + insets.bottom);
    
    int x = insets.left;
    int y = insets.top;

    int componentHeight = title.getPreferredSize().height + 2;

    title.reshape(x, y, w, componentHeight);

    y += componentHeight;
    h -= componentHeight;


    componentHeight = (divider == -1) ? fields.getPreferredSize().height + 2: divider + 1;  
    fields.reshape(x, y, w, componentHeight);
    
    y += componentHeight;
    h -= componentHeight;

    componentHeight = h;
    members.reshape(x, y, w, componentHeight);

  }

}
```

File: uml.diagram.GeneralizationItem
```java

package uml.diagram;

public class GeneralizationItem extends DesignItem {

  public GeneralizationItem() {
    super(null);
  }

  public String getType() {
    return "generalization";
  }

}
```

File: uml.diagram.AssociationItem
```java

package uml.diagram;

public class AssociationItem extends DesignItem {

  public AssociationItem() {
    this(null);
  }

  public AssociationItem(String name) {
    super(name);
  }

  public String getType() {
    return "dependency";
  }

}
```

File: uml.diagram.RealizationLink
```java

package uml.diagram;

import diagram.Figure;
import diagram.figures.PolyLink;

public class RealizationLink extends PolyLink {


  public RealizationLink(Figure f1, Figure f2) {
    super(f1, f2);
  }



}
```

File: uml.diagram.AssociationLinkRenderer
```java

package uml.diagram;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;

import javax.swing.UIManager;

import diagram.DefaultLinkRenderer;
import diagram.shape.ArrowHead;


public class AssociationLinkRenderer extends DefaultLinkRenderer  {

  protected static final CustomUI associationUI = new CustomUI("association");
  
  static {
    UIManager.put("association.foreground", Color.black);
    UIManager.put("association.background", Color.white);
  }

  public AssociationLinkRenderer() {
    setUI(associationUI);
  }

  public void paintComponent(Graphics g) {
    super.paintComponent(g);
  }

  protected GeneralPath getSourceEndpoint(double x, double y, GeneralPath path) {
    return null;
  }

  protected GeneralPath getSinkEndpoint(double x, double y, GeneralPath path) {
    return ArrowHead.createArrowHead(13.0, ArrowHead.OPEN, x, y, path);
  }

  protected void paintSinkEndpoint(Graphics2D g2, AffineTransform at, GeneralPath path) {

    super.paintSinkEndpoint(g2, at, path);
    g2.draw(path);

  }


}
```

File: uml.diagram.ClassFigure
```java

package uml.diagram;

import diagram.figures.RectangularFigure;


public class ClassFigure extends RectangularFigure {

  private int lastDividerLocation = -1;

  public ClassFigure() {
    super(100,75);
  }
 
  public int getDividerLocation() {
    return lastDividerLocation;
  }

  public void setDividerLocation(int lastDividerLocation) {
    this.lastDividerLocation = lastDividerLocation;
  }

}
```

File: uml.diagram.RealizationLinkEditor
```java

package uml.diagram;

import diagram.DefaultLinkEditor;

public class RealizationLinkEditor extends DefaultLinkEditor {

  protected RealizationItem lastValue;

  public Object getCellEditorValue() {

    if(lastValue == null)
      lastValue = new RealizationItem();

    lastValue.setName((String)super.getCellEditorValue());
    return lastValue;

  }

}
```

File: uml.diagram.ClassRenderer
```java

package uml.diagram;

import java.awt.Component;

import diagram.DefaultFigureRenderer;

public class ClassRenderer extends DefaultFigureRenderer {

  protected ClassRendererComponent classComponent = new ClassRendererComponent();

  public Component getUserComponent() {

    ClassFigure figure = (ClassFigure)getFigure();
    ClassItem item = (ClassItem)getDiagram().getModel().getValue(figure);
   
    classComponent.setTitle( (item == null) ? "" : item.getName() );
    classComponent.setFields( (item == null) ? "" : item.getAttributes() );
    classComponent.setMembers( (item == null) ? "" : item.getDescription() );
    classComponent.setDivider(figure.getDividerLocation());

    return classComponent;

  }


}
```

File: uml.diagram.SinkLabelRenderer
```java

package uml.diagram;

import java.awt.Point;

import diagram.DefaultLabelRenderer;
import diagram.figures.PolyLink;

public class SinkLabelRenderer extends DefaultLabelRenderer {

  protected void calculateSegment(PolyLink link) {

    p2 = (Point)link.getPN(link.getPointCount() - 2, p2);
    p1 = (Point)link.getSink().getConnection(p2, p1);

    p2.x += (p1.x - p2.x)/4;
    p2.y += (p1.y - p2.y)/4;

  }

}
```

File: uml.builder.AbstractBuilder
```java

package uml.builder;

import uml.diagram.ClassItem;
import uml.diagram.CompositionItem;
import uml.diagram.InterfaceItem;
import diagram.Figure;

public abstract class AbstractBuilder implements CodeBuilder {

  protected void checkContext(Context ctx) 
    throws BuilderException {

    if(ctx.hasErrors())
      throw new BuilderException("Errors were detected while identifying classes");

  }

  protected String getName(Context ctx, Figure figure) {
    
    Object value = ctx.getModel().getValue(figure);
    String name = null;

    if(value instanceof ClassItem)
      name = ((ClassItem)value).getName();
    
    else if(value instanceof InterfaceItem)
      name = ((InterfaceItem)value).getName();
    
    else if(value instanceof CompositionItem)
      name = ((CompositionItem)value).getName();

    return (name == null || name.length() < 0) ? "<no name>" : name;     
    
  }

}
```

File: uml.builder.MetaAssociation
```java

package uml.builder;

public class MetaAssociation extends MetaAttribute {

  public MetaAssociation(String description) {
    super(description);
  }

}
```

File: uml.builder.ObjectBuilder
```java

package uml.builder;

import java.util.Iterator;
import java.util.Vector;

import util.FilteredIterator;

public class ObjectBuilder implements CodeBuilder {

  protected static ClassBuilder classBuilder = new ClassBuilder();
  protected static InheritanceBuilder inheritanceBuilder = new InheritanceBuilder();
  protected static RealizationBuilder realizationBuilder = new RealizationBuilder();
  protected static CompositionBuilder compositionBuilder = new CompositionBuilder();
  protected static AssociationBuilder associationBuilder = new AssociationBuilder();
  
  public void build(Context ctx) 
    throws BuilderException {

    classBuilder.build(ctx);
    inheritanceBuilder.build(ctx);
    realizationBuilder.build(ctx);
    compositionBuilder.build(ctx);
    associationBuilder.build(ctx);

    buildConstructors(ctx);

  }

  protected void buildConstructors(Context ctx) {
    
    for(Iterator i = ctx.getClasses(); i.hasNext(); ) {

      MetaClass metaClass = (MetaClass)i.next();

      Vector attrs = new Vector();
      for(Iterator j = new FilteredIterator(metaClass.getAttributes(), MetaAssociation.class); j.hasNext();)
        attrs.add(j.next());
      
      Vector comps = new Vector();
      for(Iterator j = new FilteredIterator(metaClass.getAttributes(), MetaComposition.class); j.hasNext();)
        comps.add(j.next());

      if(attrs.isEmpty() && comps.isEmpty())
        continue;

      MetaConstructor cons = new MetaConstructor((MetaAttribute[])attrs.toArray(new MetaAttribute[attrs.size()]), 
                                                 (MetaAttribute[])comps.toArray(new MetaAttribute[comps.size()]));
      
      metaClass.addMethod(cons);
    }

  }

}
```

File: uml.builder.MetaParameter
```java

package uml.builder;

import java.util.Iterator;
import java.util.StringTokenizer;

public class MetaParameter extends MetaComponent {

  public MetaParameter(String description) {
    parseParameter(description);
  }

  protected void parseParameter(String description) {

    StringTokenizer tok = new StringTokenizer(description);

    if(tok.hasMoreTokens())
      setType(tok.nextToken());

    if(tok.hasMoreTokens())
      setName(tok.nextToken());

  }


  public int compareTo(Object o) {

    if(o instanceof MetaParameter)
      return super.compareTo(o);

    return -1;

  }


  public String toString() {

    StringBuffer buf = new StringBuffer(getType());

    if(getName() != null)
      buf.append(' ').append(getName());

    return buf.toString();

  }

  public static String toString(MetaMethod method) {

    StringBuffer buf = new StringBuffer();

    int n = 0;
    for(Iterator i = method.getParameters(); i.hasNext();) {

      if(n++ > 0) buf.append(", ");
      buf.append(i.next());
      
    }

    return buf.toString();

  }

}
```

File: uml.builder.MetaException
```java

package uml.builder;

import java.util.Iterator;

public class MetaException {

  public static String toString(MetaMethod method) {

    StringBuffer buf = new StringBuffer();

    int n = 0;
    for(Iterator i = method.getExceptions(); i.hasNext();) {

      if(n++ > 0) buf.append(", ");
      buf.append(i.next());
      
    }

    return buf.toString();

  }

}
```

File: uml.builder.SemanticException
```java

package uml.builder;

public class SemanticException extends RuntimeException {

  public SemanticException(String msg) {
    super(msg);
  }

}
```

File: uml.builder.JavaBuilder
```java

package uml.builder;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Iterator;

public class JavaBuilder extends ObjectBuilder {

  protected String prefix;

  public JavaBuilder(String prefix) {
    this.prefix = prefix;
  }   

  public void build(Context ctx) 
    throws BuilderException {

    super.build(ctx);

    try {

      for(Iterator i = ctx.getInterfaces(); i.hasNext();) {
        
        MetaClass metaClass = (MetaClass)i.next();
        PrintWriter out = getWriter(metaClass);
      
        out.println("public " + metaClass + " {");

        writeMethods(metaClass, out, false);
        
        out.println("}");
        out.flush();

      }

      for(Iterator i = ctx.getClasses(); i.hasNext();) {

        MetaClass metaClass = (MetaClass)i.next();
        PrintWriter out = getWriter(metaClass);

        for(Iterator j=metaClass.getAttributes();j.hasNext();) {

          MetaAttribute attr = (MetaAttribute)j.next();
          if(attr.isArray() && attr.getArraySize() == -1) {
            out.println("import java.util.ArrayList;\n");
            break;
          }
            
        }

        out.println("public " + metaClass + " {");

        writeAttributes(metaClass, out);
        writeMethods(metaClass, out, true);
       
        out.println("}");
        out.flush();


      }

    } catch(IOException e) { throw new BuilderException("I/O Error: " + e.getMessage()); }   

  }


  protected PrintWriter getWriter(MetaClass meta) 
    throws IOException {

    String last = "/", name = meta.getName();
    int m = 0, n = 0;

    do {
      
      if((n = name.indexOf('.', m)) > 0) {

        String dir = name.substring(m, n);
        m = ++n;

        last += dir;

        File f = new File(prefix + last);
        f.mkdir();

      }
      
    } while(n > 0);

    return new PrintWriter(new FileOutputStream(prefix + "/" + name.replace('.','/') + ".java"));

  }

  protected void writeAttributes(MetaClass metaClass, PrintWriter out)
    throws IOException {

    out.println("");
    
    for(Iterator i = metaClass.getAttributes(); i.hasNext(); ) {

      MetaAttribute attr = (MetaAttribute)i.next();
      if(attr.isArray() && attr.getArraySize() < 0)
        out.println("\tprivate ArrayList " + attr.getName() + ";");
      else
        out.println("\t" + attr + ";");

    }
  
  }


  protected void writeMethods(MetaClass metaClass, PrintWriter out, boolean withBody)
    throws IOException {

    out.println("");
    
    for(Iterator i = metaClass.getMethods(); i.hasNext(); ) {      

      MetaMethod m = (MetaMethod)i.next();

      if(m instanceof MetaConstructor)
        writeConstructor(metaClass, (MetaConstructor)m, out);

      else {

        out.print("\t" + m);     
        out.print(withBody ? " {\n\n\t}\n\n" : ";\n");

      }

    }


  }

  protected void writeConstructor(MetaClass metaClass, MetaConstructor cons, PrintWriter out)
    throws IOException {

    String signature = cons.toString();
    int n = signature.indexOf("void <init>");
    
    StringBuffer buf = new StringBuffer(signature);
    buf.replace(n, n+11, metaClass.getName());
    signature = buf.toString();
    
    out.print("\t" + signature);
    out.print(" {\n\n");

    for(Iterator i = cons.getAssociations(), j = cons.getParameters(); i.hasNext();) {
      
      MetaAttribute attr = (MetaAttribute)i.next();
      MetaParameter param = (MetaParameter)j.next();

      out.print("\t\tthis.");
      out.print(attr.getName());
      out.print(" = ");
      out.print(param.getName());
      out.print(";\n");
      
    }

    for(Iterator i = cons.getCompositions(); i.hasNext();) {
      
      MetaAttribute attr = (MetaAttribute)i.next();

      out.print("\t\tthis.");
      out.print(attr.getName());
      out.print(" = new ");

      String type = attr.getType();

      if(!attr.isArray()) {

        out.print(type);
        out.print("();\n");
      
      } else {

        int len = attr.getArraySize();

        if(len < 0) 
          out.print("ArrayList()");
        
        else { // array

          out.print(type + "[] {");
          
          for(n=0; n < len; n++) {
            if(n != 0)
              out.print(", ");
            out.print("new " + type + "()");
          }

          out.print("}");

        }

        out.print(";\n");
          
      }

    }

    out.print("\n\t}\n\n");        

  }
    
}
```

File: uml.builder.MetaClass
```java

package uml.builder;

import java.util.Iterator;
import java.util.Vector;

import util.WrappedIterator;

public class MetaClass extends MetaComponent {

  private NamingComponent attributeNamingComponent = new AttributeNamingComponent();

  private MetaClass superClass;
  private boolean anInterface;

  private Vector interfaceList = new Vector();
  private Vector attributeList;
  private Vector methodList;

  public MetaClass(String name, boolean anInterface) {

    isInterface(anInterface);
    setName(name);

  }

  public void setName(String name) {

    int len = (name == null) ? 0 : name.length();
    if(len < 1)
      throw new SyntaxException(getType() + " has no name!");

    if(!Character.isLetter(name.charAt(0)))
      throw new SyntaxException(getType() + " must start with a letter!");

    super.setName(name);

  }

  public String getProperName() {
    return getType() + " '" + getName() + "'";
  }

  public boolean isInterface() {
    return anInterface;
  }

  public void isInterface(boolean anInterface) {
    this.anInterface = anInterface;
  }

  public String getType() {
    return isInterface() ? "interface" : "class";
  }

  public void setSuperClass(MetaClass c) {
    setSuperClass(c, false);
  }

  public void setSuperClass(MetaClass c, boolean validate) {

    if(c == null || !getType().equals(c.getType()))
      throw new SyntaxException("invalid super class");

    if(validate) {

      if(superClass != null)
        throw new SemanticException("multiple inheritence detected in " + getProperName());

      else if(c.isAncestorOf(this)) {

        String msg = "cyclical " + getType() + " inheritance detected in " + "'" + getName();
        for(MetaClass meta = c; meta != this; meta= meta.getSuperClass())
          msg += ", " + meta.getName();

        msg += "'";
        throw new SemanticException(msg);

      }

    }

    superClass = c;

  }

  public MetaClass getSuperClass() {
    return superClass;
  }

  public boolean isAncestorOf(MetaClass c) {

    for(MetaClass meta = getSuperClass(); meta != null; meta = meta.getSuperClass())
      if(meta.equals(c))
        return true;

    return false;

  }

  public void addInterface(MetaClass c) {
    addInterface(c, true);
  }

  public void addInterface(MetaClass c, boolean validate) {

    String msg = null;

    if(!c.isInterface())
      throw new SyntaxException("invalid interface " + c.getProperName() + " on " + getProperName());

    if(hasInterface(c)) {

      if(validate)
        throw new SemanticException("redundant interface " + c.getProperName() + " on " + getProperName());

      for(Iterator i = interfaceList.iterator(); i.hasNext(); ) {

        MetaClass interfaceClass = (MetaClass)i.next();
        if(c.isAncestorOf(interfaceClass)) {
          i.remove();
          msg = "redundant interface " + interfaceClass.getProperName() + " on " + getProperName();
          break;
        }

      }

    }

    interfaceList.add(c);

    if(msg != null && validate)
      throw new SemanticException(msg);

  }

  public void removeInterface(MetaClass c) {
    interfaceList.remove(c);
  }

  public MetaClass getCompatibleInterface(MetaClass metaClass) {

    if(!metaClass.isInterface())
      throw new IllegalArgumentException();

    for(int i = 0; i < interfaceList.size(); i++) {

      MetaClass interfaceClass = (MetaClass)interfaceList.elementAt(i);
      if(interfaceClass.equals(metaClass) || interfaceClass.isAncestorOf(metaClass))
        return interfaceClass;

    }

    return null;

  }

  public boolean hasInterface(MetaClass metaClass) {
    return hasInterface(metaClass, true);
  }

  public boolean hasInterface(MetaClass metaClass, boolean checkParents) {

    if(getCompatibleInterface(metaClass) != null)
      return true;

    if(!checkParents)
      return false;

    MetaClass superClass = getSuperClass();
    return (superClass == null) ? false : superClass.hasInterface(metaClass, true);

  }

  public Iterator getInterfaces() {
    return getInterfaces(true);
  }

  protected Iterator getInterfaces(boolean readOnly) {
    return new WrappedIterator(interfaceList.iterator(), readOnly);
  }

  protected NamingComponent getNamingComponent() {
    return attributeNamingComponent;
  }

  public void addAttribute(MetaAttribute attr) {

    if(isInterface())
      throw new SemanticException("interface may not have attributes " + getProperName());

    getNamingComponent().nameComponent(attr);

    if(attributeList == null)
      attributeList= new Vector();

    attributeList.add(attr);

  }

  public Iterator getAttributes() {
    return getAttributes(true);
  }

  protected Iterator getAttributes(boolean readOnly) {
    return new WrappedIterator(attributeList == null ? null : attributeList.iterator(), readOnly);
  }

  public void addMethod(MetaMethod m) {
    addMethod(m, false);
  }

  public void addMethod(MetaMethod m, boolean replace) {

    String name = m.getName();
    if(getName().equals(name))
      throw new SemanticException("invalid method name for this class '" + m + "'");
    
    if(name.equals("<init>") && isInterface())
      throw new SemanticException("interface can not have constructor this class '" + m + "'");
    
    if(methodList != null) {
      
      if(methodList.contains(m)) {
        
        if(!replace)
          throw new SemanticException("duplicate method signature");
        
        else methodList.remove(m);
        
      }
      
    }
    
    if(methodList == null)
      methodList = new Vector();
    
    if(name.equals("<init>"))
      methodList.add(0, m);
    else
      methodList.add(m);

  }

  public Iterator getMethods() {
    return getMethods(true);
  }

  protected Iterator getMethods(boolean readOnly) {
    return new WrappedIterator(methodList == null ? null : methodList.iterator(), readOnly);
  }

  public int compareTo(Object o) {

    String name = getName();

    if(o instanceof MetaClass)
      return name.compareTo(((MetaClass)o).getName());

    return name.compareTo(o);

  }

  public String toString() {

    StringBuffer buf = new StringBuffer(getType());
    buf.append(' ').append(getName());

    if(getSuperClass() != null)
      buf.append(" extends ").append(getSuperClass().getName());

    for(int i = 0; i < interfaceList.size(); i++) {

      if(i == 0)
        buf.append(" implements ");

      buf.append(((MetaClass)interfaceList.elementAt(i)).getName());

      if(i < interfaceList.size() - 1)
        buf.append(", ");

    }

    return buf.toString();

  }

}
```

File: uml.builder.Context
```java

package uml.builder;

import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Vector;

import util.FilteredIterator;
import diagram.DiagramModel;

public class Context {

  private final static MetaClassComparator comparator = new MetaClassComparator();

  private DiagramModel model;

  private Vector warnings = new Vector();
  private Vector errors = new Vector();
  private Vector classes = new Vector();
  private boolean wantArrays = false;

  public Context(DiagramModel model) {
    this.model = model;
  }

  public DiagramModel getModel() {
    return model;
  }


  public void addClass(MetaClass c) {
      
    if(classes.contains(c))
      throw new SemanticException("Duplicate for '" + c.getProperName() + "'");

    classes.add(c);
    
    Collections.sort(classes);

  }

  public MetaClass getMetaClass(String name) {

    int index = Collections.binarySearch(classes, name, comparator);
    if(index < 0)
      return null;

    return (MetaClass)classes.get(index);
    
  }
  
  public void addWarning(String warning) {
    warnings.add(warning);
  }

  public void addError(String error) {
    errors.add(error);
  }

  public void enableArrays(boolean flag) {
    wantArrays = flag;
  }

  public boolean isArraysEnabled() {
    return wantArrays;
  }

  public boolean hasWarnings() {
    return !warnings.isEmpty();
  }

  public boolean hasErrors() {
    return !errors.isEmpty();
  }


  public Iterator getClasses() {
    return new FilteredIterator(classes.iterator(), new TypeFilter("class"));
  }


  public Iterator getInterfaces() {
    return new FilteredIterator(classes.iterator(), new TypeFilter("interface"));
  }

  public Iterator getWarnings() {
    return warnings.iterator();
  }

  public Iterator getErrors() {
    return errors.iterator();
  }

  public boolean contains(Object o) {
    return classes.contains(o);
  }

  protected static class TypeFilter implements Comparable {
    
    private String type;

    public TypeFilter(String type) {

      if(type == null)
        throw new RuntimeException("Invalid type");

      this.type = type;

    }

    public int compareTo(Object o) {

      if(o instanceof MetaClass) {
        o = ((MetaClass)o).getType();
        return type.compareTo(o);
      }

      return -1;

    }
    
  }

  protected static class MetaClassComparator implements Comparator {

    public int compare(Object o1, Object o2) {

      if(o1 instanceof MetaClass)
        o1 = ((MetaClass)o1).getName();

      if(o2 instanceof MetaClass)
        o2 = ((MetaClass)o2).getName();

      if(o1 instanceof String)
        return ((String)o1).compareTo(o2);

      if(o2 instanceof String)
        return ((String)o2).compareTo(o1);

      return -1;

    }

  }

}
```

File: uml.builder.AssociationBuilder
```java

package uml.builder;

import java.util.Iterator;

import uml.diagram.AssociationLink;
import uml.diagram.ClassFigure;
import uml.diagram.InterfaceFigure;
import diagram.DiagramModel;
import diagram.Figure;
import diagram.FigureIterator;

public class AssociationBuilder extends AbstractBuilder {


  public void build(Context ctx) 
    throws BuilderException {

    identifyAssociations(ctx);

    checkContext(ctx);
    
  }

  protected void identifyAssociations(Context ctx) {

    DiagramModel model = ctx.getModel();
    for(Iterator i = new FigureIterator(model, AssociationLink.class); i.hasNext();) {
      
      AssociationLink figure = (AssociationLink)i.next();

      Figure source = figure.getSource();
      Figure sink = figure.getSink();

      String sourceName = getName(ctx, source);
      String sinkName = getName(ctx, sink);

      if(compatibleFigures(ctx, source, sink)) {
      
        MetaClass sourceClass = ctx.getMetaClass(sourceName);
        MetaClass sinkClass = ctx.getMetaClass(sinkName);
        
        if(sourceClass != null && sinkClass != null) 
          buildAssociation(ctx, sourceClass, sinkClass);

        else
          ctx.addWarning("ignoring association '" + sourceName + " - " + sinkName + "'");
      
      } else {

        if(validFigure(source))
          ctx.addWarning("ignoring invalid association on '" + sourceName + "'");
        else if(validFigure(sink))
          ctx.addWarning("ignoring invalid association from '" + sinkName + "'");
        else
          ctx.addWarning("ignoring invalid association");

      }
      
    } 

  }

  
  protected boolean compatibleFigures(Context ctx, Figure source, Figure sink) {
    
    Class sourceClass = source.getClass();   
    Class sinkClass = sink.getClass();   

    return validFigure(source) && sourceClass == sinkClass;

  }

  protected boolean validFigure(Figure source) {
    Class sourceClass = source.getClass(); 
    return (sourceClass == ClassFigure.class || sourceClass == InterfaceFigure.class);
  }


  protected void buildAssociation(Context ctx, MetaClass sourceClass, MetaClass sinkClass) {

    try {

      sourceClass.addAttribute(new MetaAssociation("private " + sinkClass.getName()));

    } catch(SyntaxException e1) {
      ctx.addWarning(e1.getMessage());
    } catch(SemanticException e2) {
      ctx.addError(e2.getMessage());
    }

  }
 

}
```

File: uml.builder.MetaAccessComparator
```java

package uml.builder;

import java.util.Comparator;

public class MetaAccessComparator implements Comparator {

  public int compare(Object o1, Object o2) {

    if(o1 instanceof MetaAttribute && o2 instanceof MetaAttribute) {

      int a1 = ((MetaAttribute)o1).getAccess() & ~(MetaAccess.ABSTRACT | MetaAccess.STATIC);
      int a2 = ((MetaAttribute)o2).getAccess() & ~(MetaAccess.ABSTRACT | MetaAccess.STATIC);
      
      if(a1 < a2)
        return -1;
      else if(a1 > a2)
        return 1;
      
      String name1 = ((MetaAttribute)o1).getName();
      String name2 = ((MetaAttribute)o2).getName();

      return name1.compareTo(name2);

    }
    
    return -1;
  }

}
```

File: uml.builder.CompositionBuilder
```java

package uml.builder;

import java.util.Iterator;

import uml.diagram.ClassFigure;
import uml.diagram.CompositionItem;
import uml.diagram.CompositionLink;
import uml.diagram.InterfaceFigure;
import diagram.DiagramModel;
import diagram.Figure;
import diagram.FigureIterator;

public class CompositionBuilder extends AbstractBuilder {

  public void build(Context ctx) 
    throws BuilderException {

    identifyCompositions(ctx);

    checkContext(ctx);

  }

  protected void identifyCompositions(Context ctx) {

    DiagramModel model = ctx.getModel();
    for(Iterator i = new FigureIterator(model, CompositionLink.class); i.hasNext();) {
      
      CompositionLink figure = (CompositionLink)i.next();

      Figure source = figure.getSource();
      Figure sink = figure.getSink();

      String sourceName = getName(ctx, source);
      String sinkName = getName(ctx, sink);

      if(compatibleFigures(ctx, source, sink)) {

        MetaClass sourceClass = ctx.getMetaClass(sourceName);
        MetaClass sinkClass = ctx.getMetaClass(sinkName);
        
        if(sourceClass != null && sinkClass != null) {

          try {

          CompositionItem item = (CompositionItem)model.getValue(figure);

          int count = 1;
          if(item != null) {
            
            String card = item.getCardinality();
            if(card.endsWith("*"))
              count = -1;

            else {
              int j = card.length();
              while(--j >= 0) 
                if(!Character.isDigit(card.charAt(j)))
                  break;
              
              try {
                count = Integer.parseInt(card.substring(++j));
              } catch(NumberFormatException e) {} 
            
            }

          }

          if(count == 1 || !ctx.isArraysEnabled()) {          

            while(count-- > 0)
              sourceClass.addAttribute(new MetaComposition("private " + sinkClass.getName()));
            
          } else 
            sourceClass.addAttribute(new MetaComposition("private " + sinkClass.getName() + "[" + count + "]"));       


        } catch(SyntaxException e1) {
          ctx.addWarning(e1.getMessage());
        } catch(SemanticException e2) {
          ctx.addError(e2.getMessage());
        }


        } else
          ctx.addWarning("ignoring composition '" + sourceName + " - " + sinkName + "'");

      } else {

        if(validFigure(source))
          ctx.addWarning("ignoring invalid composition on '" + sourceName + "'");
        else if(validFigure(sink))
          ctx.addWarning("ignoring invalid composition from '" + sinkName + "'");
        else
          ctx.addWarning("ignoring invalid composition");

      }

    } 

  }
  
  protected boolean compatibleFigures(Context ctx, Figure source, Figure sink) {
    
    Class sourceClass = source.getClass();   
    Class sinkClass = sink.getClass();   

    return validFigure(source) && sourceClass == sinkClass;

  }

  protected boolean validFigure(Figure source) {
    Class sourceClass = source.getClass(); 
    return (sourceClass == ClassFigure.class || sourceClass == InterfaceFigure.class);
  }



}
```

File: uml.builder.MetaComponent
```java

package uml.builder;



public abstract class MetaComponent implements Comparable {

  private String type;
  private String name;

  public String getType() {
    return type;
  }

  public void setType(String type) {

    if(type == null || type.length() < 1 || MetaAccess.parse(type) != MetaAccess.NONE)
      throw new SyntaxException("Invalid type");

    this.type = type;

  }

  public String getName() {
    return name;
  }

  public void setName(String name) {

    if(name == null || MetaAccess.parse(name) != MetaAccess.NONE)
      throw new SyntaxException("Invalid name");

    this.name = name;

  }

  public int compareTo(Object o) {

    if(o instanceof MetaComponent) {

      MetaComponent m = (MetaComponent)o;

      if(getName() != null)
        return getName().compareTo(m.getName());

      return (m.getName() == null) ? -1 : 0;

    }

    return -1;

  }

  public boolean equals(Object o) {
    return compareTo(o) == 0;
  }

  public String toString() {

    StringBuffer buf = new StringBuffer(type);

    if(name != null)
      buf.append(' ').append(name);

    return buf.toString();

  }

}
```

File: uml.builder.NamingComponent
```java

package uml.builder;

import java.util.Collection;
import java.util.Iterator;
import java.util.Vector;

public class NamingComponent {

  private Vector names = new Vector();

  public void nameComponent(MetaComponent meta) {
    nameComponent(meta, names);
  }

  public void nameComponents(Collection c) {

    Vector v = new Vector();
    for(Iterator i = c.iterator(); i.hasNext();) {

      Object o = i.next();
      if(!(o instanceof MetaComponent))
        throw new RuntimeException("Collection contains non-MetaComponents");

      nameComponent((MetaComponent)o, v);

    }

  }

  private final void nameComponent(MetaComponent meta, Collection names) {

    String name = meta.getName();
    String type = meta.getType();

    if(!names.contains(type))
      names.add(type);

    String baseName = name = getBaseName(meta);
    names.add(baseName);
    for(int n = 0; name.equals(type) || names.contains(name); n++)
      name = getName(baseName, n);

    meta.setName(name);
    names.add(name);

  }

  protected String getBaseName(MetaComponent meta) {

    String name = meta.getName();
    String type = meta.getType();

    if(name == null || name.length() < 1)
      name = type;

    int n = name.indexOf('[');    
    StringBuffer buf = new StringBuffer(name);

    if(n>0)
      buf.delete(n, name.length());

    while(buf.length() > 0 && buf.charAt(0) == '_')
      buf.deleteCharAt(0);

    if(buf.length() > 0)
      buf.setCharAt(0, Character.toLowerCase(buf.charAt(0)));

    for(; (n = buf.length()) > 0 && Character.isDigit(buf.charAt(--n)); buf.deleteCharAt(n));

    
    return buf.toString();

  }

  protected String getName(String name, int attempt) {
    return (attempt >= 0) ? name + Integer.toString(attempt) : name;
  }

}
```

File: uml.builder.MetaMethod
```java

package uml.builder;

import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.Vector;

import util.WrappedIterator;

public class MetaMethod extends MetaAttribute {

  private NamingComponent parameterNamingComponent = new NamingComponent();
  private Vector params;
  private Vector exceptions;


  public MetaMethod(String description) {

    parseMethod(description);
    if(getName() == null)
      throw new SyntaxException("Invalid method descriptor");

  }

  protected void parseMethod(String description) {

    int m = -1, n = description.indexOf('(');
    if(n > 0)
      m = description.indexOf(')', n);

    if(n < 1 || m < n)
      throw new SyntaxException("Invalid method descriptor");

    parseAttribute(description.substring(0,n));

    if((m - n) > 1)
      parseParameters(description.substring(n+1, m));

    int len = description.length();
    while((m+1) < len && Character.isWhitespace(description.charAt(++m)));

    char[] z = {'t', 'h', 'r', 'o', 'w', 's', ' '};
    int x=0;
    while(m < len && x < z.length)
      if(z[x++] != Character.toLowerCase(description.charAt(m++)))
        break;

    if(x == z.length)
      parseExceptions(description.substring(m));

    checkMethod();

  }

  protected void checkMethod() {
    
    if(getName() == null) {
      setName(getType());
      setType("void");
    }

  }

  protected void parseParameters(String description) {

    StringTokenizer tok = new StringTokenizer(description, ",\f");
    while(tok.hasMoreTokens())
      addParameter(new MetaParameter(tok.nextToken()));

  }

  public void addParameter(MetaParameter param) {

    if(params == null)
      params = new Vector();

    params.add(param);
    getNamingComponent().nameComponent(param);

  }

  protected NamingComponent getNamingComponent() {
    return parameterNamingComponent;
  }

  protected void parseExceptions(String description) {

    StringTokenizer tok = new StringTokenizer(description, ", \f\t\r\n");
    while(tok.hasMoreTokens()) {

      String s = tok.nextToken();
      if(exceptions != null && exceptions.contains(s))
        continue;

      if(exceptions == null)
        exceptions = new Vector();

      exceptions.add(s);

    }

  }

  public boolean hasExceptions() {
    return exceptions != null;
  }


  public Iterator getExceptions() {
    return getExceptions(true);
  }

  protected Iterator getExceptions(boolean readOnly) {
    return new WrappedIterator(exceptions == null ? null : exceptions.iterator(), readOnly);
  }

  public boolean hasParameters() {
    return params != null;
  }


  public Iterator getParameters() {
    return getParameters(true);
  }

  protected Iterator getParameters(boolean readOnly) {
    return new WrappedIterator(params == null ? null : params.iterator(), readOnly);
  }

  public int compareTo(Object o) {

    int result = -1;

    if(o instanceof MetaMethod) {

      MetaMethod m = (MetaMethod)o;

      if((result = m.getName().compareTo(getName())) != 0)
          return result;

      int n = params != null ? params.size() : 0;
      if(n == (m.params != null ? m.params.size() : 0)) {

        while(--n >= 0 && result == 0) {

          MetaParameter p1 = (MetaParameter)params.elementAt(n);
          MetaParameter p2 = (MetaParameter)m.params.elementAt(n);

          result = p1.compareTo(p2);

        }

      } else
        result = -1;
    }

    return result;

  }


  public String toString() {

    StringBuffer buf = new StringBuffer(super.toString());
    buf.append('(');

    if(hasParameters()) {
      int n = 0;
      for(Iterator i = getParameters(); i.hasNext();) {

        if(n++ > 0) buf.append(", ");
        buf.append(i.next());

      }
    }

    buf.append(')');

    if(hasExceptions()) {

      int n = 0;
      for(Iterator i = getExceptions(); i.hasNext();)
        buf.append((n++ > 0) ? ", " : " throws ").append(i.next());

    }

    return buf.toString();

  }


}
```

File: uml.builder.MetaComposition
```java

package uml.builder;

public class MetaComposition extends MetaAttribute {

  public MetaComposition(String description) {
    super(description);
  }

}
```

File: uml.builder.RealizationBuilder
```java

package uml.builder;

import java.util.Iterator;

import uml.diagram.ClassFigure;
import uml.diagram.ClassItem;
import uml.diagram.InterfaceFigure;
import uml.diagram.InterfaceItem;
import uml.diagram.RealizationLink;
import diagram.DiagramModel;
import diagram.Figure;
import diagram.FigureIterator;

public class RealizationBuilder implements CodeBuilder {

  public void build(Context ctx) 
    throws BuilderException {

    identifyRealizations(ctx);

    checkContext(ctx);

  }

  protected void checkContext(Context ctx) 
    throws BuilderException {

    if(ctx.hasErrors())
      throw new BuilderException("Errors were detected while identifying classes");

  }

  protected void identifyRealizations(Context ctx) 
    throws BuilderException {

    DiagramModel model = ctx.getModel();
    for(Iterator i = new FigureIterator(model, RealizationLink.class); i.hasNext();) {
      
      RealizationLink figure = (RealizationLink)i.next();

      Figure source = figure.getSource();
      Figure sink = figure.getSink();

      String sourceName = getName(ctx, source);
      String sinkName = getName(ctx, sink);
      
      if(compatibleFigures(ctx, source, sink)) {
        
        MetaClass sourceClass = ctx.getMetaClass(sourceName);
        MetaClass sinkClass = ctx.getMetaClass(sinkName);
        
        if(sourceClass != null && sinkClass != null)
          buildRealization(ctx, sourceClass, sinkClass);

        else
          ctx.addWarning("skipping realization '" + sourceName + " - " + sinkName + "'");
        
      } else 
        ctx.addWarning("incompatible realization '" + sourceName + " - " + sinkName + "'");
    
              
    } 

  }

  
  protected boolean compatibleFigures(Context ctx, Figure source, Figure sink) 
    throws BuilderException {
    
    Class sourceClass = source.getClass();   
    Class sinkClass = sink.getClass();   

    return (sourceClass == ClassFigure.class && sinkClass == InterfaceFigure.class);

  }

  protected String getName(Context ctx, Figure figure) {
    
    Object value = ctx.getModel().getValue(figure);
    String name = null;

    if(value instanceof ClassItem)
      name = ((ClassItem)value).getName();
    
    else if(value instanceof InterfaceItem)
      name = ((InterfaceItem)value).getName();
    
    return (name == null || name.length() < 0) ? "<no name>" : name;     
    
  }


  protected void buildRealization(Context ctx, MetaClass sourceClass, MetaClass sinkClass) 
    throws BuilderException {

    try {

      sourceClass.addInterface(sinkClass, true);

    } catch(SyntaxException e1) {
      ctx.addWarning(e1.getMessage());
    } catch(SemanticException e2) {
      ctx.addError(e2.getMessage());
    }

  }
 

}
```

File: uml.builder.InheritanceBuilder
```java

package uml.builder;

import java.util.Iterator;

import uml.diagram.ClassFigure;
import uml.diagram.GeneralizationLink;
import uml.diagram.InterfaceFigure;
import diagram.DiagramModel;
import diagram.Figure;
import diagram.FigureIterator;

public class InheritanceBuilder extends AbstractBuilder {

  public void build(Context ctx) 
    throws BuilderException {

    identifyGeneralizations(ctx);

    checkContext(ctx);

  }

  protected void identifyGeneralizations(Context ctx) 
    throws BuilderException {

    DiagramModel model = ctx.getModel();
    for(Iterator i = new FigureIterator(model, GeneralizationLink.class); i.hasNext();) {
      
      GeneralizationLink figure = (GeneralizationLink)i.next();

      Figure source = figure.getSource();
      Figure sink = figure.getSink();

      String sourceName = getName(ctx, source);
      String sinkName = getName(ctx, sink);
      
      if(compatibleFigures(ctx, source, sink)) {
        
        MetaClass sourceClass = ctx.getMetaClass(sourceName);
        MetaClass sinkClass = ctx.getMetaClass(sinkName);

        if(sourceClass != null && sinkClass != null)
          buildGeneralization(ctx, sourceClass, sinkClass);
        else
          ctx.addWarning("skipping generalization '" + sourceName + " - " + sinkName + "'");
        
      } else 
        ctx.addWarning("incompatible generalization '" + sourceName + " - " + sinkName + "'");
    
              
    } 

  }

  
  protected boolean compatibleFigures(Context ctx, Figure source, Figure sink) 
    throws BuilderException {
    
    Class sourceClass = source.getClass();   
    Class sinkClass = sink.getClass();   

    if(sourceClass == sinkClass) {

      if(sourceClass == ClassFigure.class || sourceClass == InterfaceFigure.class)
        return true;

    }
         
    return false;

  }

  protected void buildGeneralization(Context ctx, MetaClass sourceClass, MetaClass sinkClass) 
    throws BuilderException {

    try {

      sourceClass.setSuperClass(sinkClass, true);

    } catch(SyntaxException e1) {
      ctx.addWarning(e1.getMessage());
    } catch(SemanticException e2) {
      ctx.addError(e2.getMessage());
    }

  }
 

}
```

File: uml.builder.SyntaxException
```java

package uml.builder;

public class SyntaxException extends RuntimeException {

  public SyntaxException(String msg) {
    super(msg);
  }

}
```

File: uml.builder.AttributeNamingComponent
```java

package uml.builder;

public class AttributeNamingComponent extends NamingComponent {

  protected String getName(String name, int attempt) {
    return (attempt >= 0) ? ("_" + name + Integer.toString(attempt)) : ("_" + name);
  }


}

```

File: uml.builder.MetaAttribute
```java

package uml.builder;

import java.util.StringTokenizer;

public class MetaAttribute extends MetaComponent {

  private int access;
  
  protected MetaAttribute() { }

  public MetaAttribute(String description) {
    parseAttribute(description);
  }
  
  
  protected void parseAttribute(String description) {

    StringTokenizer tok = new StringTokenizer(description);

    for(int n=0; tok.hasMoreTokens();) {

      String s = tok.nextToken();
      if((n = MetaAccess.parse(s)) != MetaAccess.NONE)
        access |= n;

      else { // Set the type
        setType(s);
        break;
      }

    }

    setAccess(access);

    if(tok.hasMoreTokens())
      setName(tok.nextToken());

  }

  public int getAccess() {
    return access;
  }

  public void setAccess(int access) {

    access = MetaAccess.compress(access);
    if(!MetaAccess.isValid(access))
      throw new SyntaxException("Invalid access modifiers");

    this.access = access;

  }
  
  public String getType() {

    String type =  super.getType();
    int n = type.indexOf('[');

    return (n < 0) ? type : type.substring(0,n);

  }

  public boolean isArray() {
    return super.getType().indexOf('[') > 0;
  }
  
  public int getArraySize() {

    String type =  super.getType(); 
    int n = type.indexOf('[');
    int m = type.indexOf(']');

    if(m > n && n > 0) {
      try { return Integer.parseInt(type.substring(n+1,m)); } catch(Throwable t) {}
    }
    
    return -1;
  }

  public int compareTo(Object o) {

    int result = -1;
    if(o instanceof MetaAttribute && (result = super.compareTo(o)) == 0) {

      MetaAttribute m = (MetaAttribute)o;
      result = getType().compareTo(m.getType());

    }

    return result;

  }


  public String toString() {

    StringBuffer buf = new StringBuffer();

    if(access != MetaAccess.NONE)
      buf.append(MetaAccess.toString(access)).append(' ');

    buf.append(getType());

    if(isArray())
      buf.append("[]");

    if(getName() != null)
      buf.append(' ').append(getName());

    return buf.toString();

  }

}
```

File: uml.builder.BuilderException
```java

package uml.builder;

public class BuilderException extends Exception {

  public BuilderException(String msg) {
    super(msg);
  }

}
```

File: uml.builder.CPlusPlusBuilder
```java

package uml.builder;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Collections;
import java.util.Iterator;
import java.util.Vector;

import util.FilteredIterator;

public class CPlusPlusBuilder extends ObjectBuilder {

  protected static final MetaAccessComparator attributeComparator = new MetaAccessComparator();
  protected String prefix;

  public CPlusPlusBuilder(String prefix) {
    this.prefix = prefix;
  }   

  public void build(Context ctx) 
    throws BuilderException {

    super.build(ctx);

    try {

      for(Iterator i = ctx.getInterfaces(); i.hasNext();) {
        
        MetaClass metaClass = (MetaClass)i.next();
        PrintWriter out = getWriter(metaClass, "h");
        
        writeHeader(metaClass, out);

        out.flush();

      }

      for(Iterator i = ctx.getClasses(); i.hasNext();) {

        MetaClass metaClass = (MetaClass)i.next();
        PrintWriter out = getWriter(metaClass, "h");

        writeHeader(metaClass, out);
        writeSource(metaClass, getWriter(metaClass, "cc"));

        out.flush();

      }

    } catch(IOException e) { throw new BuilderException("I/O Error: " + e.getMessage()); }   

  }


  protected PrintWriter getWriter(MetaClass meta, String ext) 
    throws IOException {

    return new PrintWriter(new FileOutputStream(prefix + "/" + meta.getName() + "." + ext));

  }

 
  protected void writeHeader(MetaClass metaClass, PrintWriter out)
    throws IOException {

    String def = "_" + metaClass.getName().toUpperCase() + "_H_";

    out.println("#ifndef " + def);
    out.println("#define " + def + "\n");
    

    Vector v = new Vector();
    MetaClass superClass = metaClass.getSuperClass();
    if(superClass != null) 
      v.add(superClass.getName());

    for(Iterator i = metaClass.getInterfaces(); i.hasNext();)
      v.add(((MetaClass)i.next()).getName());

    for(int j=0; j < v.size(); j++) 
      out.println("#include \"" + v.get(j) + ".h\"");
    
    Vector used = new Vector();
    for(Iterator i = new FilteredIterator(metaClass.getAttributes(), MetaAssociation.class); i.hasNext();) {
      MetaAttribute attr = (MetaAttribute)i.next();
      String name = attr.getType();
      if(!v.contains(name) && !used.contains(name)) {
        out.println("#include \"" + name + ".h\"");
        used.add(name);
      }
    }

    out.print("\nclass " + metaClass.getName());
    int sz = v.size();
    if(sz > 0) {

      out.print(" : public " + v.get(0));
     
      for(int j=1; j < sz; j++) 
        out.print(", public " + v.get(j));     
     
    }

    out.print(" {\n");
    
    if(!metaClass.isInterface())
      writeHeaderAttributes(metaClass, out);

    writeHeaderMethods(metaClass, out);


    out.println("};\n");
    out.println("#endif // " + def);

  }

  protected void writeHeaderAttributes(MetaClass metaClass, PrintWriter out)
    throws IOException {

    Vector v = new Vector();
    for(Iterator i = metaClass.getAttributes(); i.hasNext();) 
      v.add(i.next());
        
    Collections.sort(v, attributeComparator);

    int n, last = 0;
    for(int j=0; j < v.size(); j++) {

      MetaAttribute attr = (MetaAttribute)v.get(j);

      n = (attr.getAccess() & ~(MetaAccess.ABSTRACT | MetaAccess.STATIC));
      if(n == 0)
        n = MetaAccess.PRIVATE;

      if(last != n) {
        last = n;
        out.println(MetaAccess.toString(n) + ":\n");
      }
        
      out.println("\t" + attr.getType() + " " + attr.getName() + ";");

    }
        
    out.print("\n");

  }

  protected void writeHeaderMethods(MetaClass metaClass, PrintWriter out)
    throws IOException {


    int last = MetaAccess.PUBLIC;
    out.println("public: ");

    Vector v = new Vector();
    for(Iterator i = metaClass.getMethods(); i.hasNext();) {
      Object o = i.next();
      if(o instanceof MetaConstructor)
        writeHeaderConstructor(metaClass, (MetaConstructor)o, out);
      
      else
        v.add(o);
    }

    writeHeaderDestructor(metaClass, out);

    int n;
    for(int j=0; j < v.size(); j++) {

      MetaMethod meth = (MetaMethod)v.get(j);

      n = (meth.getAccess() & ~(MetaAccess.ABSTRACT | MetaAccess.STATIC));
      if(n == 0)
        n = MetaAccess.PRIVATE;

      if(last != n) {
        last = n;
        out.println("\n" + MetaAccess.toString(n) + ":\n");
      }

      String signature = meth.getType() + " " + meth.getName() + "(" + MetaParameter.toString(meth) + ")";
      if(meth.hasExceptions()) 
        signature += " throw(" + MetaException.toString(meth) + ")";

      if(metaClass.isInterface())
        out.println("\tvirtual " + signature + " = 0;");
      else {

        if(MetaAccess.isAbstract(meth.getAccess())) 
          signature = "virtual " + signature + " = 0";
        else if(MetaAccess.isStatic(meth.getAccess())) 
          signature = "static " + signature;

        out.println("\t" + signature + ";");

      }

    }
        
    out.print("\n");

  }

  protected void writeHeaderDestructor(MetaClass metaClass, PrintWriter out)
    throws IOException {

    out.print("\tvirtual ~" + metaClass.getName() + "()");
    out.println(metaClass.isInterface() ? " {};" : ";");

  }

  protected void writeHeaderConstructor(MetaClass metaClass, MetaConstructor cons, PrintWriter out)
    throws IOException {
 
    String signature = metaClass.getName() + "(" + MetaParameter.toString(cons) + ")";
    if(cons.hasExceptions()) 
      signature += " throw(" + MetaException.toString(cons) + ")";

    out.print("\t" + signature);
    out.println(metaClass.isInterface() ? " {};" : ";");

  }

  protected void writeSource(MetaClass metaClass, PrintWriter out)
    throws IOException {
    
    out.println("#include \"" + metaClass.getName() + ".h\"\n");
    
    boolean writtenDestructor = false;
    for(Iterator i = metaClass.getMethods(); i.hasNext();) {

      MetaMethod method = (MetaMethod)i.next();
      if(method instanceof MetaConstructor) 
        writeSourceConstructor(metaClass, (MetaConstructor)method, out);

      else {

        if(!writtenDestructor) {
          writtenDestructor = true;
          writeSourceDestructor(metaClass, out);
        }

        out.print(method.getType() + " " + metaClass.getName() + "::" + method.getName());
        out.print("(" + MetaParameter.toString(method) + ")");

        if(method.hasExceptions()) 
          out.print(" throw(" + MetaException.toString(method) + ")");
                  
        out.print(" { \n\n");
        
        out.print("}\n\n");

      }

    }

    out.flush();

  }

  protected void writeSourceConstructor(MetaClass metaClass, MetaConstructor cons, PrintWriter out)
    throws IOException {

    out.print(metaClass.getName() + "::" + metaClass.getName());
    out.print("(" + MetaParameter.toString(cons) + ")");
    
    if(cons.hasExceptions()) 
      out.print(" throw(" + MetaException.toString(cons) + ")");
    
    int n = 0;
    for(Iterator i = cons.getAssociations(), j = cons.getParameters(); i.hasNext();) {
      
      MetaAttribute attr = (MetaAttribute)i.next();
      MetaParameter param = (MetaParameter)j.next();

      if(n++ == 0)
        out.print("\n\t: ");
      else
        out.print(", ");

      out.print(attr.getName());
      out.print("(" + param.getName() + ")");
      
    }

    out.println(" {\n");

    for(Iterator i = cons.getCompositions(); i.hasNext();) {
      
      MetaAttribute attr = (MetaAttribute)i.next();
      out.println("\t" + attr.getName() + " = new " + attr.getType() + "();");
      
    }
        
    out.println("\n}\n");
      
  }

  protected void writeSourceDestructor(MetaClass metaClass, PrintWriter out)
    throws IOException {

    out.println(metaClass.getName() + "::~" + metaClass.getName() + "{\n");

    for(Iterator i = new FilteredIterator(metaClass.getAttributes(), MetaComposition.class); i.hasNext();) {
      
      MetaAttribute attr = (MetaAttribute)i.next();
      out.println("\tdelete " + attr.getName() + ";");
      
    }

    out.println("\n}\n");

  }
    
}
```

File: uml.builder.ClassBuilder
```java

package uml.builder;

import java.util.Iterator;
import java.util.StringTokenizer;

import uml.diagram.ClassFigure;
import uml.diagram.ClassItem;
import uml.diagram.InterfaceFigure;
import uml.diagram.InterfaceItem;
import diagram.DiagramModel;
import diagram.ValueIterator;

public class ClassBuilder extends AbstractBuilder {

  public void build(Context ctx) 
    throws BuilderException {

    identifyClasses(ctx);
    identifyInterfaces(ctx);

    checkContext(ctx);

  }
  
  protected void checkContext(Context ctx) 
    throws BuilderException {

    if(ctx.hasErrors())
      throw new BuilderException("Errors were detected while identifying classes");

  }

  protected void identifyClasses(Context ctx) {

    DiagramModel model = ctx.getModel();
    for(Iterator i = new ValueIterator(model, ClassFigure.class); i.hasNext();) {
      
      ClassItem item = (ClassItem)i.next();
      
      try { // Add the class to the context

        String className = (item == null) ? null : item.getName();
        MetaClass metaClass = new MetaClass(className, false);

        identifyAttributes(ctx, metaClass, item.getAttributes());
        identifyMethods(ctx, metaClass, item.getDescription());

        ctx.addClass(metaClass);

      } catch(SyntaxException e1) { 
        ctx.addWarning(e1.getMessage()); 
      } catch(SemanticException e2) { 
        ctx.addError(e2.getMessage()); 
      }
                       
    } 

  }

  protected void identifyInterfaces(Context ctx) {

    DiagramModel model = ctx.getModel();
    for(Iterator i = new ValueIterator(model, InterfaceFigure.class); i.hasNext();) {
      
      InterfaceItem item = (InterfaceItem)i.next();
      
      try { // Add the class to the context

        String className = (item == null) ? null : item.getName();
        MetaClass metaClass = new MetaClass(className, true);

        identifyMethods(ctx, metaClass, item.getDescription());

        ctx.addClass(metaClass);

      } catch(SyntaxException e1) { 
        ctx.addWarning(e1.getMessage()); 
      } catch(SemanticException e2) { 
        ctx.addError(e2.getMessage()); 
      }
                       
    } 

  }

  protected void identifyAttributes(Context ctx, MetaClass metaClass, String attributes) {
   
    for(StringTokenizer tok = new StringTokenizer(attributes, "\f\n\r"); tok.hasMoreTokens();) {
      
      try {
        
        metaClass.addAttribute(new MetaAttribute(tok.nextToken()));
        
      } catch(SyntaxException e1) { 
        ctx.addWarning(e1.getMessage()); 
      } catch(SemanticException e2) { 
        ctx.addWarning(e2.getMessage()); 
      }
      
    }

  }

  protected void identifyMethods(Context ctx, MetaClass metaClass, String methods) {
   
    for(StringTokenizer tok = new StringTokenizer(methods, "\f\n\r"); tok.hasMoreTokens();) {
      
      try {
        
        metaClass.addMethod(new MetaMethod(tok.nextToken()));
        
      } catch(SyntaxException e1) { 
        ctx.addWarning(e1.getMessage()); 
      } catch(SemanticException e2) { 
        ctx.addWarning(e2.getMessage()); 
      }
      
    }

  }

}
```

File: uml.builder.CodeBuilder
```java

package uml.builder;



public interface CodeBuilder {

  public void build(Context ctx)
    throws BuilderException;


}
```

File: uml.builder.MetaAccess
```java

package uml.builder;

public abstract class MetaAccess {

  public static int NONE      = 0x00;
  public static int PRIVATE   = 0x01;
  public static int PROTECTED = 0x02;
  public static int PUBLIC    = 0x04;
  public static int STATIC    = 0x08;
  public static int ABSTRACT  = 0x10;

  public static int compress(int access) {

    if(isPublic(access))
      access &= ~PROTECTED & ~PRIVATE;

    else if(isProtected(access))
      access &= ~PROTECTED & ~PRIVATE;

    return access;

  }

  public static boolean isComplementary(int a, int b) {

    return !((a == b) || (isAbstract(a) && isStatic(b)) || (isAbstract(b) && isStatic(a)));

  }

  public static boolean isCompatible(int a, int b) {

    if(isStatic(a) != isStatic(b))
      return false;

    if(isAbstract(a) && !isAbstract(b))
      return false;

    if((isPublic(b) && !isPublic(a)) || (isProtected(b) && isPrivate(a)))
      return false;

    return true;

  }

  public static boolean isPublic(int access) {
    return (access & PUBLIC) != 0;
  }

  public static boolean isProtected(int access) {
    return (access & PROTECTED) != 0;
  }

  public static boolean isPrivate(int access) {
    return (access & PRIVATE) != 0;
  }

  public static boolean isAbstract(int access) {
    return (access & ABSTRACT) != 0;
  }

  public static boolean isStatic(int access) {
    return (access & STATIC) != 0;
  }

  public static boolean isValid(int access) {

    if(isAbstract(access) && isStatic(access))
      return false;

    return !((isPublic(access) && isProtected(access)) || (isPrivate(access) && isProtected(access)) || (isPublic(access) && isPrivate(access)));

  }

  public static int parse(String access) {

    int x = NONE;

    if(access.indexOf("public") >= 0)
      x |= PUBLIC;

    if(access.indexOf("protected") >= 0)
      x |= PROTECTED;

    if(access.indexOf("private") >= 0)
      x |= PRIVATE;

    if(access.indexOf("abstract") >= 0)
      x |= ABSTRACT;

    if(access.indexOf("static") >= 0)
      x |= STATIC;

    return x;

  }

  public static String toString(int access) {

    StringBuffer buf = null;

    if(isPrivate(access))
      buf = append(buf, "private");

    if(isProtected(access))
      buf = append(buf, "protected");

    if(isPublic(access))
      buf = append(buf, "public");

    if(isStatic(access))
      buf = append(buf, "static");

    if(isAbstract(access))
      buf = append(buf, "abstract");

    return (buf == null) ? "" : buf.toString();

  }

  private static StringBuffer append(StringBuffer buf, String s) {

    if(buf != null)
      buf.append(' ').append(s);
    else
      buf = new StringBuffer(s);

    return buf;

  }

}
```

File: uml.builder.MetaConstructor
```java

package uml.builder;

import java.util.Iterator;
import java.util.NoSuchElementException;


public class MetaConstructor extends MetaMethod {

  private MetaAttribute[] associations;
  private MetaAttribute[] compositions;

  public MetaConstructor() {
    this(null, null);
  }

  public MetaConstructor(MetaAttribute[] associations, MetaAttribute[] compositions) {

    super("public void <init>()");

    if(associations != null) 
      initParameters(associations);
    
    this.associations = associations;
    this.compositions = compositions;

  }

  public void initParameters(MetaAttribute[] associations) {

    for(int i=0; i<associations.length; i++)
      addParameter(new MetaParameter(associations[i].getType() + " " + associations[i].getName()));

  }

  public Iterator getAssociations() {
    return getAttributeIterator(associations);
  }

  public Iterator getCompositions() {
    return getAttributeIterator(compositions);
  }

  private final Iterator getAttributeIterator(MetaAttribute[] attr) {

    final MetaAttribute[] array = attr;
    return new Iterator() {

        int n = 0;
        
        public boolean hasNext() { 
          return array != null && n < array.length;
        }

        public Object next() { 

          if(!hasNext())
            throw new NoSuchElementException();

          return array[n++];

        }
        
        public void remove() {}

    };

  }

}
```

File: util.ClassFilter
```java

package util;

public class ClassFilter implements Comparable {
  
  private Class filterClass;
  
  public ClassFilter(Class c) {
    filterClass = c;
  }

  public int compareTo(Object o) {
    
    if(o == null)
      return -1;
    
    return (filterClass.isAssignableFrom(o.getClass())) ? 0 : 1;
         
  }
  
}
```

File: util.WrappedIterator
```java

package util;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class WrappedIterator implements Iterator {

  private Iterator iter;
  private boolean readOnly;

  public WrappedIterator(Iterator iter) {
    this(iter, false);
  }

  public WrappedIterator(Iterator iter, boolean readOnly) {
    setIterator(iter);
    setReadOnly(readOnly);
  }

  public boolean hasNext() {
    return iter != null && iter.hasNext();
  }

  public Object next() {

    if(iter != null)
      return iter.next();

    throw new NoSuchElementException();

  }

  public void remove() {

    if(!readOnly && iter != null)
      iter.remove();

  }

  protected void setReadOnly(boolean readOnly) {
    this.readOnly = readOnly;
  }

  protected boolean isReadOnly() {
    return readOnly;
  }

  protected Iterator getIterator() {
    return iter;
  }

  protected void setIterator(Iterator iter) {
    this.iter = iter;
  }

}
```

File: util.WeakList
```java

package util;

import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.AbstractList;
import java.util.Vector;

public class WeakList extends AbstractList {

  private ReferenceQueue queue = new ReferenceQueue();
  private Vector list = new Vector();


  public boolean add(Object o) {

    list.addElement(new WeakReference(o, queue));
    return true;

  }

  public Object get(int index) {

    WeakReference r = (WeakReference)list.elementAt(index);
    Object o = null;

    if(r == null || ((o = r.get()) == null))
      return null;

    return o;

  }
 
  public int indexOf(Object o) {

    for(int i = 0; i < list.size(); i++) {

      WeakReference r = (WeakReference)list.elementAt(i);

      if(r != null && (r.get() == o))
        return i;

    }

    cleanUp();

    return -1;

  }


  public boolean remove(Object o) {

    boolean found = false;

    for(int i = 0; !found && i<list.size(); i++) {

      WeakReference r = (WeakReference)list.elementAt(i);

      if(r != null && (r.get() == o)) {

        list.removeElement(r);
        found = true;

      }

    }

    cleanUp();

    return found;

  }

  public int size() {

    cleanUp();
    return list.size();

  }

  protected void cleanUp() {

    WeakReference r;

    while((r = (WeakReference)queue.poll()) != null)
      list.removeElement(r);

  }


}

```

File: util.AssociativeMap
```java

package util;

import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public class AssociativeMap extends AbstractMap
  implements MultiMap, Serializable {

  private HashMap keyMap = new HashMap();

  private ArrayList collectionList = new ArrayList();

  private Object[] copyList = new Object[4];

  public void clear() {
    keyMap.clear();
  }

  public boolean contains(Object key, Object value) {

    if(key == null || value == null)
      return false;

    ArrayList list = (ArrayList)keyMap.get(key);
    return list.contains(value);

  }

  public boolean containsKey(Object key) {
    return keyMap.containsKey(key);
  }


  public boolean containsValue(Object value) {

    for(int i=0; i < collectionList.size(); i++)
      if( ((ArrayList)collectionList.get(i)).contains(value) )
          return true;


    return false;

  }

  public Set keySet() {
    return keyMap.keySet();
  }


  public Object get(Object key) {

    if(key == null)
      throw new IllegalArgumentException();

    ArrayList list = (ArrayList)keyMap.get(key);
    if(list == null)
      return null;

    if(list.size() > 0)
      return list.get(0);

    removeEntryList(key, list);
    return null;

  }

  public boolean isEmpty() {

    if(!keyMap.isEmpty()) {

      for(int i=0; i < collectionList.size(); i++)
        if( ((ArrayList)collectionList.get(i)).size() != 0)
          return false;

    }

    return true;

  }

  public Object put(Object key, Object value) {

    if(key == null || value == null)
      throw new IllegalArgumentException();

    return getEntryList(key).add(value) ? value : null;

  }

  private final ArrayList getEntryList(Object key) {


    ArrayList list = (ArrayList)keyMap.get(key);
    if(list == null) {

      list = new ArrayList();
      keyMap.put(key, list);
      collectionList.add(list);

    }

    return list;

  }

  private final void removeEntryList(Object key, ArrayList list) {

    keyMap.remove(key);
    collectionList.remove(list);
    list.clear();

  }

  public Object remove(Object key) {

    ArrayList list = (ArrayList)keyMap.get(key);
    Object value;

    if(list == null || ((value = list.remove(0)) == null))
      return null;

    if(list.size() == 0)
      removeEntryList(key, list);

    return value;

  }

  public void remove(Object key, Object value) {

    if(key == null)
      removeAllValues(value);

    else { // Remove one mapping

      ArrayList list = (ArrayList)keyMap.get(key);
      int index;

      if(list != null && ((index = list.indexOf(value)) >= 0)) {

        list.remove(index);

        if(list.size() == 0)
          removeEntryList(key, list);

      }

    }

  }

  private final void removeAllValues(Object value) {

    int index;
    for(int i=0; i < collectionList.size(); i++) {

      ArrayList list = (ArrayList)collectionList.get(i);
      if((index = list.indexOf(value)) > -1)
        list.remove(index);

    }

  }


  public void removeAll(Object key) {

    ArrayList list = (ArrayList)keyMap.get(key);

    if(list != null)
      removeEntryList(key, list);

  }


  public void putAll(Map m) {

    for(Iterator i = m.entrySet().iterator(); i.hasNext(); ) {

      Map.Entry e = (Map.Entry)i.next();
      put(e.getKey(), e.getValue());

    }

  }


  public void putAll(Object key, Collection c) {

    for(Iterator i = c.iterator(); i.hasNext(); )
      put(key, i.next());

  }


  public void putAll(Object key, Object[] o) {

    for(int i=0; i <  o.length; i++)
      if(o[i] != null)
        put(key, o[i]);

  }

  public void put(Object value) {
    put(keyMap, value);
  }

  public Object[] getAll(Object key, Object[] array) {

    if(key == null) { // Copy all

      Class t = (array == null) ? Object.class : array.getClass().getComponentType();
      int sz = size();

      if(array.length < sz)
        array = (Object[])java.lang.reflect.Array.newInstance(t, sz);

      for(int x = 0, i=0; i < collectionList.size(); i++) {

        ArrayList list = (ArrayList)collectionList.get(i);
        copyList = list.toArray(copyList);

        int z = list.size();
        System.arraycopy(copyList, 0, array, x, z);
        x += z;

      }

      if(array.length > sz)
        java.util.Arrays.fill(array, sz, array.length, null);

      java.util.Arrays.fill(copyList, null);

      return array;

    }

    ArrayList list = (ArrayList)keyMap.get(key);
    return list.toArray(array);

  }

  public int size() {

    int sz = 0;

    for(int i=0; i < collectionList.size(); i++)
      sz += ((ArrayList)collectionList.get(i)).size();


    return sz;

  }

  public Set entrySet() {

    return new AbstractSet() {

      public Iterator iterator() {
        return new EntryIterator();
      }

      public int size() {
        return AssociativeMap.this.size();
      }

    };

  }

  public Collection values() {

    return new AbstractCollection() {

      ValueIterator iter = new ValueIterator();

      public Iterator iterator() {
        iter.reset();
        return iter;
      }

      public int size() {
        return AssociativeMap.this.size();
      }

    };

  }

  public Collection values(Object key) {

    if(key == null)
      throw new IllegalArgumentException();

    final Object k = key;

    return new AbstractCollection() {

      ValueIterator iter = new ValueIterator();

      public Iterator iterator() {

        iter.reset();
        iter.key = k;

        return iter;

      }

      public int size() {
        return (iter.list == null) ? 0 : iter.list.size();
      }

    };

  }

  protected class ValueIterator implements Iterator {

    int n = 0, m = 0;
    ArrayList list = null;
    Object key = null;

    public void setKey(Object key) {
      this.key = key;
    }

    public boolean hasNext() {

      while(list != null || n < collectionList.size()) {

        if(list != null && m < list.size())
          return true;

        if(list == null) {

          list = (ArrayList)collectionList.get(n++);
          m = 0;

          if( key == null || keyMap.get(key) == list)
            return true;

        }

        list = null;

      }

      key = null;
      return false;

    }

    public Object next() {//System.err.println("K:" + key + " " + list.size() + "/" + m);
      return list.get(m++);
    }

    public void remove() {
    }

    public void reset() {

      n = 0;
      m = 0;
      list = null;

    }



  }


  protected class EntryIterator implements Iterator {

    Iterator v = keyMap.entrySet().iterator();
    Iterator i;

    MultiMap.Entry e = new MultiMap.Entry();

    public boolean hasNext() {

      while(i == null || !i.hasNext()) {

        if(!v.hasNext())
          return false;

        Map.Entry entry = (Map.Entry)v.next();
        ArrayList list = (ArrayList)entry.getValue();

        if(list.size() > 0) {

          e.key = entry.getKey();
          i = list.iterator();

        }

      }

      return true;


    }

    public Object next() {
      e.val = i.next();
      return e;
    }

    public void remove() { }

    public void reset() {

      v = keyMap.entrySet().iterator();
      i = null;

    }

  }


  public static void main(String[] args) {

    MultiMap m = new AssociativeMap();

    m.put("A", "1");
    m.put("A", "2");
    m.put("B", "3");

    printAll(m);

    m.removeAll("A");

    printAll(m);

  }

  protected static void printAll(MultiMap m) {

    System.err.println("VALUES:");
    for(Iterator i = m.values("A").iterator(); i.hasNext();)
      System.err.println(i.next());

    System.err.println("ENTRIES:");
    for(Iterator i = m.entrySet().iterator(); i.hasNext();)
      System.err.println(i.next());

  }

}
```

File: util.FilteredIterator
```java

package util;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class FilteredIterator extends WrappedIterator {

  private Comparable filter;
  private Object nextValue;

  public FilteredIterator(Iterator iter, Class filter) {
    this(iter, new ClassFilter(filter));
  }

  public FilteredIterator(Iterator iter, Comparable filter) {
    this(iter, filter, true);
  }

  public FilteredIterator(Iterator iter, Comparable filter, boolean readOnly) {

    super(iter, readOnly);
    this.filter = filter;
    
  }

  public boolean hasNext() {
    
    if(nextValue != null)
      return true;

    while(super.hasNext()) {

      nextValue = super.next();
      if(filter.compareTo(nextValue) == 0)
        return true;
      
    }
    
    return false;

  }

  public Object next() {

    if(nextValue == null)
      throw new NoSuchElementException();

    Object o = nextValue;
    nextValue = null;

    return o;

  }

}
```

File: util.MultiMap
```java

package util;

import java.util.Collection;
import java.util.Map;

public interface MultiMap extends Map {

  public boolean contains(Object key, Object value);

  public void remove(Object key, Object value);

  public void removeAll(Object key);

  public void put(Object value);

  public void putAll(Object key, Collection c);


  public void putAll(Object key, Object[] o);

  public Object[] getAll(Object key, Object[] array);

  public Collection values(Object key);

  public static class Entry implements Map.Entry {

    public Object key;
    public Object val;

    public Entry() {
      this(null, null);
    }

    public Entry(Object key, Object val) {
      this.key = key;
      this.val = val;
    }

    public Object getKey() {
      return this.key;
    }

    public Object getValue() {
      return this.val;
    }

    public Object setValue(Object value) {
      throw new UnsupportedOperationException();
    }

    public String toString() {
      return "[" + key + "], [" + val + "]";
    }

  }

 

}
```

File: diagram.AbstractSelectionModel
```java

package diagram;

import util.WeakList;

public abstract class AbstractSelectionModel implements SelectionModel {

  private WeakList listeners = new WeakList();

  public void addSelectionListener(DiagramSelectionListener l) {
    listeners.add(l);
  }

  public void removeSelectionListener(DiagramSelectionListener l) {
    listeners.remove(l);
  }


  protected void fireFigureAdded(Figure f) {

    for(int i = 0; i < listeners.size(); i++) {

      DiagramSelectionListener l = (DiagramSelectionListener)listeners.get(i);
      if(l != null)
        l.figureAdded(this, f);

    }

  }

  protected void fireFigureRemoved(Figure f) {

    for(int i = 0; i < listeners.size(); i++) {

      DiagramSelectionListener l = (DiagramSelectionListener)listeners.get(i);
      if(l != null)
        l.figureRemoved(this, f);

    }

  }

}
```

File: diagram.DefaultSelectionModel
```java

package diagram;

import java.util.ArrayList;
import java.util.Iterator;

public class DefaultSelectionModel extends AbstractSelectionModel {

  private ArrayList selectionList = new ArrayList();
 
  public boolean contains(Figure f) {
    return selectionList.contains(f);
  }

  public boolean contains(Link l) { return false; }

  public void add(Figure f) {
    add(f, false);
  }

  public void add(Figure f, boolean reset) {

    if(reset)
      clear();

    selectionList.add(f);
    fireFigureAdded(f);

  }

  public void remove(Figure f) {

    selectionList.remove(f);
    fireFigureRemoved(f);

  }


  public void clear() {

    while(!selectionList.isEmpty() )
      remove((Figure)selectionList.get(selectionList.size()-1));

  }

  public int size() {
    return selectionList.size();
  }

  public Iterator iterator() {
    return new ValueIterator();

  }


  public Object[] toArray(Object[] a) {

    Class itemClass = (a == null) ? Object.class : a.getClass().getComponentType();
    if(itemClass == Object.class)
      return selectionList.toArray(a);

    int len = selectionList.size();
    if(a.length < len) 
      a = (Object[])java.lang.reflect.Array.newInstance(itemClass, len);
    
    int n = 0;
    for(int i=0; i < len; i++) {
      
      Object o = selectionList.get(i);
      Class c = o.getClass();
      
      if(c == itemClass || itemClass.isAssignableFrom(c))
        a[n++] = o;

    }
    
    if(n < a.length) 
      java.util.Arrays.fill(a, n, a.length, null);
    
    return a;

  }


  protected class ValueIterator implements Iterator {

    int n = 0;
    
    public boolean hasNext() {
      
      if(n++ < selectionList.size())
        return true;

      reset();

      return false;

    }

    public Object next() {
      return selectionList.get(n);
    }

    public void remove() { }

    public void reset() {
      n = 0;
    }

  }

}
```

File: diagram.DefaultLinkEditor
```java

package diagram;

import java.awt.Component;
import java.awt.geom.Rectangle2D;

public class DefaultLinkEditor extends DefaultFigureEditor {

  protected DefaultLabelRenderer renderer;
   
  public DefaultLinkEditor() {
    this(new DefaultLabelRenderer());
  }

  public DefaultLinkEditor(DefaultLabelRenderer renderer) {
    super(renderer);
    this.renderer = (DefaultLabelRenderer)getComponent();
  }

  public Component getFigureEditorComponent(Diagram diagram, Figure figure, boolean isSelected) {
    return renderer.getRendererComponent(diagram, figure, false);
  }


  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds) {
    return renderer.getDecoratedBounds(diagram, figure, rcBounds);
  }


}
```

File: diagram.FigureIterator
```java

package diagram;

import java.lang.reflect.Array;
import java.util.Iterator;

public class FigureIterator implements Iterator {

  private Class figureClass;
  private Figure[] figures = new Figure[4];
  private int current = 0;

  public FigureIterator(DiagramModel model, Class figureClass) {

    Class c = Figure.class;
    if(!c.isAssignableFrom(figureClass))
      throw new RuntimeException("Can only scan a DiagramModel for Figures");

    this.figureClass = figureClass;

    figures = (Figure[])Array.newInstance(figureClass, 4);
    figures = (Figure[])model.toArray((Object[])figures);

  }

  public Object next() {
    return figures[current++];
  }

  public boolean hasNext() {
    return current < figures.length && figures[current] != null;
  }

  public void remove() { }

}
```

File: diagram.Figure
```java

package diagram;

import java.awt.Shape;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

public interface Figure extends Shape {

  public Point2D getAnchor(Point2D pt);

  public Rectangle2D getBounds2D(Rectangle2D rc);

  public Point2D getCenter(Point2D pt);

  public Point2D getConnection(Point2D ptFrom, Point2D pt);

  
  public void setBounds(double x, double y, double w, double h); 

  public void translate(double x, double y);

  public Object clone();


}
```

File: diagram.FigureRenderer
```java

package diagram;

import java.awt.Component;
import java.awt.geom.Rectangle2D;

public interface FigureRenderer {

  public Component getRendererComponent(Diagram diagram, Figure figure, boolean isSelected);


  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds);

}
```

File: diagram.Link
```java

package diagram;

import java.awt.geom.Point2D;

public interface Link extends Figure {
  
  public Figure getSource();

  public Figure setSource(Figure figure);

  public Point2D getSourceAnchor(Point2D pt);

  public Figure getSink();

  public Figure setSink(Figure figure);

  public Point2D getSinkAnchor(Point2D pt);




}


```

File: diagram.DiagramSelectionListener
```java

package diagram;

public interface DiagramSelectionListener {

  public void figureAdded(SelectionModel model, Figure figure);

  public void figureRemoved(SelectionModel model, Figure figure);

}
```

File: diagram.AbstractDiagramModel
```java

package diagram;

import util.WeakList;

public abstract class AbstractDiagramModel implements DiagramModel {

  private WeakList listeners = new WeakList();

  public void addDiagramDataListener(DiagramModelListener l) {
    listeners.add(l);
  }

  public void removeDiagramDataListener(DiagramModelListener l) {
    listeners.remove(l);
  }


  protected void fireFigureAdded(Figure figure) {

    for(int i = 0; i < listeners.size(); i++) {

      DiagramModelListener l = (DiagramModelListener)listeners.get(i);
      if(l != null)
        l.figureAdded(this, figure);

    }

  }

  protected void fireFigureRemoved(Figure figure) {

    for(int i = 0; i < listeners.size(); i++) {

      DiagramModelListener l = (DiagramModelListener)listeners.get(i);
      if(l != null)
        l.figureRemoved(this, figure);

    }

  }


}
```

File: diagram.ValueIterator
```java

package diagram;

import java.util.NoSuchElementException;

public class ValueIterator extends FigureIterator {

  private DiagramModel model;
  private Object value;
  private boolean haveNext = false;
  private boolean includeNulls;

  public ValueIterator(DiagramModel model, Class figureClass) {
    this(model, figureClass, true);
  }


  public ValueIterator(DiagramModel model, Class figureClass,  boolean includeNulls) {

    super(model, figureClass);
    this.model = model;
    this.includeNulls = includeNulls;

  }

  public Object next() {
    
    if(!haveNext)
      haveNext = hasNext();
    
    if(!haveNext)
      throw new NoSuchElementException();

    haveNext = false;
    return value;

  }

  public boolean hasNext() {
    
    if(super.hasNext() && !haveNext) {
      value = model.getValue((Figure)super.next());

      if((!includeNulls && value == null) || includeNulls)
        haveNext = true;

    }

    return haveNext;

  }


}
```

File: diagram.FigureComparator
```java

package diagram;

import java.awt.Rectangle;
import java.util.Comparator;

public class FigureComparator implements Comparator {

  protected Rectangle r1 = new Rectangle();
  protected Rectangle r2 = new Rectangle();

  public int compare(Object o1, Object o2) {

    Figure f1 = (Figure)o1;
    Figure f2 = (Figure)o2;

    if(f1 == f2 || o1.equals(f2))
      return 0;

    Class c1 = f1.getClass();
    Class c2 = f2.getClass();

    if(c1 != c2) // Sort on class name 
      return c1.getName().compareTo(c2.getName());

    r1 = (Rectangle)f1.getBounds2D(r1);
    r2 = (Rectangle)f2.getBounds2D(r2);


    return (r1.hashCode() < r2.hashCode()) ? -1 : 1;

  }

}
```

File: diagram.DiagramModel
```java

package diagram;

import java.util.Iterator;

public interface DiagramModel {

  public void add(Figure figure);
  
  public void remove(Figure figure);

  public void clear();

  public Iterator iterator();

  public int size();

  public void setValue(Figure figure, Object value);

  public Object getValue(Figure figure);

  public void addDiagramDataListener(DiagramModelListener listener);

  public void removeDiagramDataListener(DiagramModelListener listener);

  public Object[] toArray(Object[] array);

}
```

File: diagram.DefaultFigureEditor
```java

package diagram;

import java.awt.Component;
import java.awt.geom.Rectangle2D;

import javax.swing.BorderFactory;
import javax.swing.DefaultCellEditor;
import javax.swing.JTextField;

public class DefaultFigureEditor extends DefaultCellEditor 
  implements FigureEditor {

  public DefaultFigureEditor() {
    this(new JTextField());
  }

  public DefaultFigureEditor(JTextField comp) {
    super(comp);
    setClickCountToStart(2);
  }

  public Component getFigureEditorComponent(Diagram diagram, Figure figure, boolean isSelected) {

    JTextField comp = ((JTextField)getComponent());

    Object label = diagram.getModel().getValue(figure);
    comp.setText(label != null ? label.toString() : "");

    comp.setOpaque(true);
    comp.setForeground(diagram.getForeground());
    comp.setBorder(BorderFactory.createLineBorder(diagram.getBackground().darker()));

    return comp;

  }

  public Object getCellEditorValue() {
    return ((JTextField)getComponent()).getText();
  }


  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds) {

    FigureRenderer renderer = diagram.getFigureRenderer(figure.getClass());
    return renderer.getDecoratedBounds(diagram, figure, rcBounds);

  }

}
```

File: diagram.DefaultFigureRenderer
```java

package diagram;

import java.awt.Component;
import java.awt.geom.Rectangle2D;

import javax.swing.JComponent;

public class DefaultFigureRenderer extends JComponent
  implements FigureRenderer {

  private final static double DEFAULT_EXPANSION = 8.0;
  private final static SelectionBorder selectionBorder = new SelectionBorder();

  private Component userComponent = null;

  private Figure lastFigure = null;
  private Diagram lastDiagram = null;
  
  public DefaultFigureRenderer() {
    this(null);
  }

  public DefaultFigureRenderer(Component userComponent) {

    setLayout(null);
    setUserComponent(userComponent);

  }

  public Component getRendererComponent(Diagram diagram, Figure figure, boolean isSelected) {

    lastFigure = figure;
    lastDiagram = diagram;

    Component component = getUserComponent();
    if(userComponent != component) 
      setUserComponent(component);

    setBorder( (isSelected) ? selectionBorder : null );

    return this;
    
  }


  public void setUserComponent(Component component) {
    
    if(component != userComponent) {

      userComponent = component;
      removeAll();
      
      if(component != null)
        add(component);  

    }

  }

  public Component getUserComponent() {
    return userComponent;
  }

  public Figure getFigure() {
    return lastFigure;
  }

  public Diagram getDiagram() {
    return lastDiagram;
  }


  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds) {

    double expansion = getExpansion();

    rcBounds = figure.getBounds2D(rcBounds);
    rcBounds.setFrame( rcBounds.getX() - expansion, 
                       rcBounds.getY() - expansion, 
                       rcBounds.getWidth() + 2*expansion, 
                       rcBounds.getHeight() + 2*expansion);

    return rcBounds; 

  }

  protected double getExpansion() { 
    return DEFAULT_EXPANSION; 
  }


  public void setBounds(int x, int y, int w, int h) {
    
    super.setBounds(x, y, w, h);

    int ex = (int)getExpansion();
    if(userComponent != null)
      userComponent.setBounds(ex, ex, w-2*ex, h-2*ex);

  }


}
```

File: diagram.FigureEditor
```java

package diagram;

import java.awt.Component;
import java.awt.geom.Rectangle2D;

import javax.swing.CellEditor;

public interface FigureEditor extends CellEditor {

  public Component getFigureEditorComponent(Diagram diagram, Figure figure, boolean isSelected);

  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds);
    
}
```

File: diagram.DefaultDiagramModel
```java

package diagram;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

public class DefaultDiagramModel extends AbstractDiagramModel 
  implements Serializable {

  private static FigureComparator comparator = new FigureComparator();

  private ArrayList figures = new ArrayList();
  private HashMap valueMap = new HashMap();

  public void add(Figure fig) {

    if(!figures.contains(fig)) {

      figures.add(fig);
      fireFigureAdded(fig);
   
    }

  }
  

  public void remove(Figure fig) {

    if(figures.contains(fig)) {

      figures.remove(fig);
      fireFigureRemoved(fig);

    }

  }

  public void clear() {

    while(!figures.isEmpty())
      fireFigureRemoved((Figure)figures.remove(figures.size()-1));

    valueMap.clear();

  }

  public int size() {
    return figures.size();
  }

  public Iterator iterator() {
    return new RepeatingIterator(figures);
  }

  public void setValue(Figure figure, Object value) {
    valueMap.put(figure, value);
  }

  public Object getValue(Figure figure) {
    return valueMap.get(figure);
  }

  protected class RepeatingIterator implements Iterator {

    private List list;
    private int index;

    public RepeatingIterator(List list) {
      this.list = list;
      this.index = -1;
    }

    public boolean hasNext() {

      if(++index == list.size()) {

        index = -1;
        return false;

      }

      return true;

    }

    public Object next() {
      return list.get(index);
    }

    public void remove() {}

  }

  public Object[] toArray(Object[] a) {

    Class itemClass = (a == null) ? Object.class : a.getClass().getComponentType();
    if(itemClass == Object.class)
      return figures.toArray(a);

    int len = figures.size();
    if(a.length < len) 
      a = (Object[])java.lang.reflect.Array.newInstance(itemClass, len);
    
    int n = 0;
    for(int i=0; i < len; i++) {
      
      Object o = figures.get(i);
      Class c = o.getClass();
      
      if(c == itemClass || itemClass.isAssignableFrom(c))
        a[n++] = o;

    }
    
    if(n < a.length) 
      java.util.Arrays.fill(a, n, a.length, null);
    
    return a;

  }

}
```

File: diagram.DefaultLabelRenderer
```java

package diagram;

import java.awt.Color;
import java.awt.Component;
import java.awt.FontMetrics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.geom.Rectangle2D;

import javax.swing.JTextField;
import javax.swing.UIManager;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.PlainDocument;

import diagram.figures.PolyLink;


public class DefaultLabelRenderer extends JTextField 
  implements FigureRenderer {
  
  protected Insets insets = new Insets(0,0,0,0);

  protected Point p1 = new Point();
  protected Point p2 = new Point();
  
  private int lastWidth;
  private final static int MAXIMUM_WIDTH = 150;

  static {
    UIManager.put("label.foreground", Color.black);
    UIManager.put("label.background", Color.white);
  }

  public DefaultLabelRenderer() {

    setBackground(UIManager.getColor("label.background"));
    setForeground(UIManager.getColor("label.foreground"));

  }

  public Document createDefaultModel() {
    return new SimpleDocument();
  }
  
  public Component getRendererComponent(Diagram diagram, Figure figure, boolean isSelected) {

    Object label = diagram.getModel().getValue(figure);
    setText(label != null ? label.toString() : "");

    return this;

  }

  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds) {
    
    if(rcBounds == null)
      rcBounds = new Rectangle2D.Double();

    return calculateLabelBounds((PolyLink)figure, getText(), rcBounds);

  }

  protected void calculateSegment(PolyLink link) {

    double d, max = 0;
    int n = 0;

    p2 = (Point)link.getPN(1, p2);
    p1 = (Point)link.getSource().getConnection(p2, p1);
      
    max = p1.distance(p2);
    
    for(int i = 1; i < link.getSegmentCount() - 1; i++) {
        
      p1 = (Point)link.getPN(i, p1);
      p2 = (Point)link.getPN(i+1, p2);

      if((d = p1.distance(p2)) > max) {
        max = d;
        n = i;
      }

    }

    p2 = (Point)link.getPN(link.getPointCount() - 2, p2);
    p1 = (Point)link.getSink().getConnection(p2, p1);

    if((d = p1.distance(p2)) > max)
      n = link.getSegmentCount() - 1;

    p2 = (Point)link.getPN(n, p2);
    p1 = (Point)link.getPN(n+1, p1);

  }

  protected Rectangle2D calculateLabelBounds(PolyLink link, String text, Rectangle2D rc) {

    calculateSegment(link);
    
    double x1 = p1.x;
    double y1 = p1.y;
    double x2 = p2.x;
    double y2 = p2.y;
    
    double dx = (x1 > x2) ? (x1 - x2)*-1 : (x2 - x1);
    double dy = (y1 > y2) ? (y1 - y2)*-1 : (y2 - y1);

    FontMetrics metrics = getFontMetrics( getFont() );
    insets = getInsets(insets);
    
    int w = metrics.charsWidth(text.toCharArray(), 0, text.length());
    w += insets.left + insets.right;
    w = Math.min(MAXIMUM_WIDTH, w);

    int h = metrics.getHeight();
    h += insets.top + insets.bottom;

    dx -= w;
    dy -= h;

    dx /= 2;
    dy /= 2;


    y1 -= insets.top;
    x1 -= insets.left;

    lastWidth = w;

    if(rc == null)
      return new Rectangle2D.Double((x1 + dx), (y1 + dy), w, h);

    rc.setFrame((x1 + dx), (y1 + dy), w, h);
    return rc;
  }

  protected void updateBounds() {

    String text = getText();

    FontMetrics metrics = getFontMetrics( getFont() );
    int w = metrics.charsWidth(text.toCharArray(), 0, text.length());
    w = Math.min(MAXIMUM_WIDTH, w);

    int dx = (w - lastWidth);
    lastWidth = w;

    setBounds(getX()-dx/2, getY(), Math.max(getWidth()+dx, 5), getHeight());

  }


  class SimpleDocument extends PlainDocument {
    
    public void insertString(int offs, String str, AttributeSet a) 
      throws BadLocationException {
      
      super.insertString(offs, str, a);
      updateBounds();
      
    }
    
    public void remove(int offs, int len)
      throws BadLocationException {
      
      super.remove(offs, len);
      updateBounds();
      
    }
    
  }


}
```

File: diagram.SelectionModel
```java

package diagram;

import java.util.Iterator;

public interface SelectionModel {

  public boolean contains(Figure figure);

  public boolean contains(Link link);

  public void add(Figure figure);

  public void add(Figure f, boolean reset);

  public void remove(Figure figure);

  public void clear();


  public int size();


  public Iterator iterator();


  public Object[] toArray(Object[] array);



  public void addSelectionListener(DiagramSelectionListener listener);

  public void removeSelectionListener(DiagramSelectionListener listener);

}
```

File: diagram.DefaultLinkRenderer
```java

package diagram;

import java.awt.Color;
import java.awt.Component;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.BorderFactory;
import javax.swing.UIManager;

import diagram.figures.PolyLink;
import diagram.shape.ArrowHead;

public class DefaultLinkRenderer extends DefaultFigureRenderer {

  protected AffineTransform at = new AffineTransform();
  protected GeneralPath path = null;
  
  protected Point2D p1;
  protected Point2D p2;

  protected FontMetrics font;
  
  private Rectangle labelBounds = new Rectangle();
  private DefaultLabelRenderer labelRenderer; 
  private Component labelComponent;

  static {
    UIManager.put("link.foreground", Color.black);
    UIManager.put("link.background", Color.white);
  }


  public DefaultLinkRenderer() {
    this(new DefaultLabelRenderer());
  }

  public DefaultLinkRenderer(DefaultLabelRenderer labelRenderer) {
    
    setBackground(UIManager.getColor("link.background"));
    setForeground(UIManager.getColor("link.foreground"));

    labelRenderer.setBorder(BorderFactory.createEmptyBorder(1,1,1,1));
    labelRenderer.setOpaque(false);

    this.labelRenderer = labelRenderer;

  }

  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds) {
    
    rcBounds = super.getDecoratedBounds(diagram, figure, rcBounds);
    
    labelComponent = labelRenderer.getRendererComponent(diagram, figure, false);
    if(labelRenderer.getText() != null) {

      labelBounds = (Rectangle)labelRenderer.getDecoratedBounds(diagram, figure, labelBounds);

      double x = Math.min(rcBounds.getX(), labelBounds.x);
      double y = Math.min(rcBounds.getY(), labelBounds.y);
      double w = Math.max(rcBounds.getWidth(), (labelBounds.x - x) + labelBounds.width);
      double h = Math.max(rcBounds.getHeight(), (labelBounds.y - y) + labelBounds.height);
     
      rcBounds.setFrame(x, y, w, h);
      
    } else 
      labelComponent = null;

    return rcBounds;  

  }
  
  public void paintComponent(Graphics g) {
    
    PolyLink link = (PolyLink)getFigure();
    
    Graphics2D g2 = (Graphics2D)g;
    GeneralPath path;
    
    double x1, x2, y1, y2;
    double angle;
    
    if(link != null) {
      
      double dx = getX(); 
      double dy = getY();
      
      g2.setPaint(getForeground());
      
      p2 = link.getPN(1, p2);
      p1 = link.getSource().getConnection(p2, p1);

      x1 = p1.getX() - dx; x2 = p2.getX() - dx;
      y1 = p1.getY() - dy; y2 = p2.getY() - dy;

      g2.drawLine((int)x1, (int)y1, (int)x2, (int)y2);
      
      angle = getSourceAngle(x2, y2, x1, y1);

      
      if((path = getSourceEndpoint(x1, y1, this.path)) != null) {
        
        at.setToRotation(angle+Math.PI, x1, y1);
        paintSourceEndpoint(g2, at, path);
        
      }
      
      p2 = link.getPN(link.getPointCount() - 2, p2);
      p1 = link.getSink().getConnection(p2 , p1);
      
      x1 = p1.getX() - dx; x2 = p2.getX() - dx;
      y1 = p1.getY() - dy; y2 = p2.getY() - dy;
      
      angle = getSinkAngle(x2, y2, x1, y1);
      
      if(link.getSegmentCount() > 1)
        g2.drawLine((int)x1, (int)y1, (int)x2, (int)y2);
      
      if((path = getSinkEndpoint(x1, y1, this.path)) != null) {
        
        at.setToRotation(angle+Math.PI, x1, y1);
        paintSinkEndpoint(g2, at, path);
        
      }
      

      for(int i = 1; i < link.getSegmentCount() - 1; i++)
        g2.drawLine((int)(link.getXN(i)-dx), (int)(link.getYN(i)-dy), 
                    (int)(link.getXN(i+1)-dx), (int)(link.getYN(i+1)-dy));


                       
      if(labelComponent != null) {
        
        dx = labelBounds.x-getX();
        dy = labelBounds.y-getY();

        g2.translate(dx, dy);
        labelComponent.setBounds(labelBounds.x, labelBounds.y, 
                                 labelBounds.width, labelBounds.height);

        labelComponent.paint(g);
        g2.translate(-dx, -dy);
        
      }
      
    }
    
  }
  

  protected void paintSourceEndpoint(Graphics2D g2, AffineTransform at, GeneralPath path) {
    path.transform(at);
    g2.fill(path);
  }
  
  protected void paintSinkEndpoint(Graphics2D g2, AffineTransform at, GeneralPath path) {
    path.transform(at);
    g2.fill(path);
  }
  
  
  protected double getSourceAngle(double x1, double y1, double x2, double y2) {
    return getAngle(x1, y1, x2, y2); 
  }

  protected double getSinkAngle(double x1, double y1, double x2, double y2) {
    return getAngle(x1, y1, x2, y2); 
  } 

  final private double getAngle(double x1, double y1, double x2, double y2) {
    
    double angle;
    
    if((x2 - x1) == 0) {
      
      angle = Math.PI/2;
      return (y2 < y1) ? (angle + Math.PI) : angle; 
      
    }
    
    angle = Math.atan((y1-y2)/(x1-x2));
    return (x2 < x1) ? (angle + Math.PI) : angle; 
    
  }
  
  
  protected GeneralPath getSourceEndpoint(double x, double y, GeneralPath path) {
    return ArrowHead.createArrowHead(7.0, ArrowHead.FLAT, x, y, path);
  }
  
  protected GeneralPath getSinkEndpoint(double x, double y, GeneralPath path) {
    return ArrowHead.createArrowHead(7.0, ArrowHead.FLAT, x, y, path);
  }
  
}
```

File: diagram.SelectionBorder
```java

package diagram;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Insets;

import javax.swing.border.AbstractBorder;

public class SelectionBorder extends AbstractBorder {

  protected int thickness;
  protected Color lineColor;


  public SelectionBorder() {
    this(6, Color.lightGray);
  }

  public SelectionBorder(int thickness, Color lineColor) {

    this.thickness = thickness;
    this.lineColor = lineColor;

  }

  public Insets getBorderInsets(Component c)       {
    return new Insets(thickness,thickness,thickness,thickness);
  }

  public Insets getBorderInsets(Component c, Insets insets) {

    insets.left = insets.bottom = thickness;
    insets.right = insets.top = thickness;

    return insets;

  }

  public Color getLineColor() {
    return lineColor;
  }

  public int getThickness() {
    return thickness;
  }

  public void paintBorder(Component c, Graphics g, int x, int y, int w, int h) {
      

    int dx = (x+w)-thickness-1;
    int dy = (y+h)-thickness-1;

    Color fillColor = c.getBackground();
    g.setColor((fillColor == null) ? lineColor : fillColor.darker());

    g.fillRect(x, y, thickness, thickness);
    g.fillRect(dx, y, thickness, thickness);

    g.fillRect(x, dy, thickness, thickness);
    g.fillRect(dx, dy, thickness, thickness);

    g.fillRect((w/2)-(thickness/2), y, thickness, thickness);
    g.fillRect((w/2)-(thickness/2), dy, thickness, thickness);

    g.fillRect(x, (h/2)-(thickness/2), thickness, thickness);
    g.fillRect(dx, (h/2)-(thickness/2), thickness, thickness);

    g.setColor((lineColor == null) ? c.getBackground().darker() : lineColor.darker());

    g.drawRect(x, y, thickness, thickness);
    g.drawRect(dx, y, thickness, thickness);

    g.drawRect(x, dy, thickness, thickness);
    g.drawRect(dx, dy, thickness, thickness);

    g.drawRect((w/2)-(thickness/2), y, thickness, thickness);
    g.drawRect((w/2)-(thickness/2), dy, thickness, thickness);

    g.drawRect(x, (h/2)-(thickness/2), thickness, thickness);
    g.drawRect(dx, (h/2)-(thickness/2), thickness, thickness);

  }

}
```

File: diagram.Diagram
```java

package diagram;

import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.HashMap;

import javax.swing.JComponent;
import javax.swing.JViewport;
import javax.swing.Scrollable;
import javax.swing.SwingConstants;
import javax.swing.UIManager;

public class Diagram extends JComponent 
  implements Scrollable {
  
  private static final String uiClassID = "DiagramUI";

  private SelectionModel selectionModel;
  private DiagramModel diagramModel;

  private Rectangle figureBounds = new Rectangle();

  private HashMap rendererMap = new HashMap();
  private HashMap editorMap = new HashMap();

  private boolean fastRefresh;

  static {
    UIManager.put("DiagramUI", "diagram.DiagramUI");
  }

  public Diagram() {
    this(new DefaultDiagramModel());
  }


  public Diagram(DiagramModel model) {
    this(model, new DefaultSelectionModel());
  }


  public Diagram(DiagramModel model, SelectionModel selectionModel) {
    this(model, selectionModel, true);

  }

  public Diagram(DiagramModel model, SelectionModel selectionModel, boolean doubleBuffered) {

    if(model == null || selectionModel == null)
      throw new IllegalArgumentException();

    setDoubleBuffered(doubleBuffered);

    updateUI();
    
    setOpaque(true);
    setModel(model);
    setSelectionModel(selectionModel);

    enableFastRefresh(true);

  }


  public DiagramUI getUI() {
    return (DiagramUI)ui;
  }


  public String getUIClassID() {
    return uiClassID;
  }


  public void setUI(DiagramUI ui) {
    super.setUI(ui);
  }


  public void updateUI() { 
    setUI((DiagramUI)UIManager.getUI(this));
  }


  public void setModel(DiagramModel diagramModel) {
     
    DiagramModel oldValue = this.diagramModel;
    this.diagramModel = diagramModel;

    firePropertyChange("model", oldValue, diagramModel);
    
  }


  public DiagramModel getModel() {
    return diagramModel;
  }


  public void setSelectionModel(SelectionModel selectionModel) {

    SelectionModel oldValue = this.selectionModel;
    this.selectionModel = selectionModel;

    firePropertyChange("selectionModel", oldValue, selectionModel);

  }


  public SelectionModel getSelectionModel() {
    return selectionModel;
  }


  public FigureRenderer getFigureRenderer(Class itemClass) {
    
    for(Object o = null; o == null && itemClass != null; itemClass = itemClass.getSuperclass()) {
      if((o = rendererMap.get(itemClass)) != null)
        return (FigureRenderer)o;
    }
    
    return null;

  }

  public void setFigureRenderer(Class itemClass, FigureRenderer renderer) {

    if(renderer == null)
      rendererMap.remove(itemClass);
    else
      rendererMap.put(itemClass, renderer);

  }


  public FigureEditor getFigureEditor(Class itemClass) {

    for(Object o = null; o == null && itemClass != null; itemClass = itemClass.getSuperclass()) {
      if((o = editorMap.get(itemClass)) != null)
        return (FigureEditor)o;
    }
    
    return null;

  }


  public void setFigureEditor(Class itemClass, FigureEditor editor) {

    if(editor == null)
      editorMap.remove(itemClass);
    else
      editorMap.put(itemClass, editor);

  }


  public Figure findFigure(Point2D pt) {
    return (ui == null) ? null : ((DiagramUI)ui).findFigure(pt);
  }


  public void enableFastRefresh(boolean flag) {

    if(flag != fastRefresh) {

      boolean last = fastRefresh;
      fastRefresh = flag;
      
      firePropertyChange("fastRefresh", (last ? "true":"false"), (last ? "false":"true"));
    
    }

  }

  public boolean isFastRefreshEnabled() {
    return fastRefresh;
  }


  public Rectangle2D getDecoratedBounds(Figure figure, Rectangle2D rcBounds) {
    
    FigureRenderer renderer = null;
    if(figure == null || (renderer = getFigureRenderer(figure.getClass())) == null)
      return rcBounds;

    return (rcBounds = renderer.getDecoratedBounds(this, figure, rcBounds));

  }




  private void checkScrollableParameters(Rectangle visibleRect, int orientation) {

    if (visibleRect == null) 
      throw new IllegalArgumentException("visibleRect must be non-null");

    switch (orientation) {
        case SwingConstants.VERTICAL:
        case SwingConstants.HORIZONTAL:
          break;
        default:
          throw new IllegalArgumentException("orientation must be one of: VERTICAL, HORIZONTAL");
    }

  }

  public Dimension getPreferredScrollableViewportSize() {
    return getPreferredSize();
  }

  public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
    
    checkScrollableParameters(visibleRect, orientation);
    return 4;

  }

  public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
    checkScrollableParameters(visibleRect, orientation);
    return (orientation == SwingConstants.VERTICAL) ? visibleRect.height : visibleRect.width;

  }

  public boolean getScrollableTracksViewportWidth() {

    if(getParent() instanceof JViewport) 
      return (((JViewport)getParent()).getWidth() > getPreferredSize().width);
    
    return false;

  }

  public boolean getScrollableTracksViewportHeight() {

    if(getParent() instanceof JViewport) 
      return (((JViewport)getParent()).getHeight() > getPreferredSize().height);
    
    return false;

  }

}
```

File: diagram.DiagramUI
```java

package diagram;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.awt.geom.Point2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import javax.swing.CellRendererPane;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.KeyStroke;
import javax.swing.RepaintManager;
import javax.swing.UIManager;
import javax.swing.border.Border;
import javax.swing.plaf.ComponentUI;

import diagram.figures.PolyLink;

public class DiagramUI extends ComponentUI { 

  static { // Install the UI with the UIManager

    UIManager.put("diagram.background", new Color(0xEF, 0xEF, 0xEF));
    UIManager.put("diagram.foreground", Color.black);

  }

  protected Diagram diagram;
  protected boolean fastRefresh;

  protected CellRendererPane cellRendererPane = new CellRendererPane();
  protected ModelHandler modelListener = new ModelHandler();
  protected PropertyChangeHandler propertyListener = new PropertyChangeHandler();

  protected Layer figureLayer = new Layer();
  protected Layer linkLayer = new Layer();

  protected Rectangle clip = new Rectangle();
  protected Rectangle bounds = new Rectangle();

  private static HashMap editorCache = new HashMap();
  private static HashMap rendererCache = new HashMap();

  protected HashMap linkMap = new HashMap();

  private Color originalForeground;
  private Color originalBackground;

  public DiagramUI() {
    UIManager.getDefaults().addPropertyChangeListener(propertyListener);
  }

  public synchronized static FigureRenderer getRenderer(Class c) {

    FigureRenderer renderer = (FigureRenderer)rendererCache.get(c);

    if(renderer == null) {
      try { 
        renderer = (FigureRenderer)c.newInstance();
        rendererCache.put(c, renderer);
    }

    return renderer;

  }


  public synchronized static FigureEditor getEditor(Class c) {

    FigureEditor editor = (FigureEditor)editorCache.get(c);

    if(editor == null) {
      try { 
        editor = (FigureEditor)c.newInstance();
        editorCache.put(c, editor);
    }

    return editor;

  }

  public static ComponentUI createUI(JComponent c) {
    return new DiagramUI();
  }

 
  public void installUI(JComponent c) {

    if(!(c instanceof Diagram))
      throw new RuntimeException("This UI is for Diagram components only");
    
    diagram = (Diagram)c;

    diagram.add(cellRendererPane);
    diagram.addPropertyChangeListener(propertyListener);

    DiagramModel model = diagram.getModel();
    if(model != null)
      model.addDiagramDataListener(modelListener);

    SelectionModel selectionModel = diagram.getSelectionModel();
    if(selectionModel != null)
      selectionModel.addSelectionListener(modelListener);

    InputMap map = c.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    map.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false), "cancelEditing");

    map = diagram.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);

    map.put(KeyStroke.getKeyStroke(KeyEvent.VK_CUT, 0, false), "cut");
    map.put(KeyStroke.getKeyStroke(KeyEvent.VK_COPY, 0, false), "copy");
    map.put(KeyStroke.getKeyStroke(KeyEvent.VK_PASTE, 0, false), "paste");

    map.put(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0, false), "cut");
    map.put(KeyStroke.getKeyStroke("control X"), "cut");
    map.put(KeyStroke.getKeyStroke("control C"), "copy");
    map.put(KeyStroke.getKeyStroke("control INSERT"), "copy");
    map.put(KeyStroke.getKeyStroke("control V"), "paste");
    map.put(KeyStroke.getKeyStroke("shift INSERT"), "paste");

    installRenderers(diagram);
    installEditors(diagram);

    installColors(diagram);

  }

  protected void installColors(Diagram diagram) {  

    originalForeground = diagram.getForeground();
    originalBackground = diagram.getBackground();

    diagram.setBackground(UIManager.getColor("diagram.background"));
    diagram.setForeground(UIManager.getColor("diagram.foreground"));
    
  }

  protected void installRenderers(Diagram diagram) {

    diagram.setFigureRenderer(Object.class, getRenderer(DefaultFigureRenderer.class));
    diagram.setFigureRenderer(PolyLink.class, getRenderer(DefaultLinkRenderer.class));

  }

  protected void installEditors(Diagram diagram) {

    diagram.setFigureEditor(Object.class, getEditor(DefaultFigureEditor.class));
    diagram.setFigureEditor(PolyLink.class, getEditor(DefaultLinkEditor.class));

  }

  public void uninstallUI(JComponent c) {

    if(!(c instanceof Diagram))
      throw new RuntimeException("This UI is for Diagram components only");

    if(c != diagram)
      throw new RuntimeException("This UI is not installed on this Diagram");

    diagram.remove(cellRendererPane);
    diagram.removePropertyChangeListener(propertyListener);

    DiagramModel model = diagram.getModel();
    if(model != null)
      model.removeDiagramDataListener(modelListener);

    SelectionModel selectionModel = diagram.getSelectionModel();
    if(selectionModel != null)
      selectionModel.removeSelectionListener(modelListener);
    
    InputMap map = c.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    map.remove(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false));

    map = diagram.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);

    map.remove(KeyStroke.getKeyStroke(KeyEvent.VK_CUT, 0, false));
    map.remove(KeyStroke.getKeyStroke(KeyEvent.VK_COPY, 0, false));
    map.remove(KeyStroke.getKeyStroke(KeyEvent.VK_PASTE, 0, false));

    map.remove(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0, false));
    map.remove(KeyStroke.getKeyStroke("control X"));
    map.remove(KeyStroke.getKeyStroke("control C"));
    map.remove(KeyStroke.getKeyStroke("control INSERT"));
    map.remove(KeyStroke.getKeyStroke("control V"));
    map.remove(KeyStroke.getKeyStroke("shift INSERT"));

    uninstallColors(diagram);

    diagram = null;

    linkLayer.removeAll();
    figureLayer.removeAll();
    
  }

  protected void uninstallColors(Diagram diagram) {  

    diagram.setBackground(originalBackground);
    diagram.setForeground(originalForeground);
    
  }

  public Figure findFigure(Point2D pt) {

    Figure figure = figureLayer.findFigure(pt);
    if(figure == null) 
      figure = linkLayer.findFigure(pt);

    return figure;

  }


  public void paint(Graphics g, JComponent c) {

    linkLayer.paintLayer(g);
    figureLayer.paintLayer(g);

  }

  public void refreshFigure(Figure figure) {

    if(fastRefresh)
      repaintFigure(figure);
    else
      damageFigure(figure);

  }

  public void refreshRegion(Rectangle rc) {

    if(fastRefresh)
      repaintRegion(rc);
    else
      damageRegion(rc);

  }

  public void repaintRegion(Rectangle rc) {

    RepaintManager m = RepaintManager.currentManager(diagram);

    if(rc != null)
      m.addDirtyRegion(diagram, rc.x, rc.y, rc.width, rc.height);
    else
      m.markCompletelyDirty(diagram);

    m.paintDirtyRegions();

  }

  public void repaintFigure(Figure figure) {

    FigureRenderer renderer = diagram.getFigureRenderer(figure.getClass());
    bounds = (Rectangle)renderer.getDecoratedBounds(diagram, figure, bounds);
    
    repaintRegion(bounds);

  }

  public void damageRegion(Rectangle rc) {

    RepaintManager m = RepaintManager.currentManager(diagram);

    if(rc == null)
      m.markCompletelyDirty(diagram);
    else
      m.addDirtyRegion(diagram, rc.x, rc.y, rc.width, rc.height);

  }

  public void damageFigure(Figure figure) {

    FigureRenderer renderer = diagram.getFigureRenderer(figure.getClass());
    bounds = (Rectangle)renderer.getDecoratedBounds(diagram, figure, bounds);   
    damageRegion(bounds);

  }


  public void addConnection(Figure figure, Link link) {
    
    ArrayList list = (ArrayList)linkMap.get(figure);
    if(list == null) {
      list = new ArrayList();
      linkMap.put(figure, list);
    }

    list.add(link);
    
  }

  public void removeConnection(Figure figure, Link link) {

    ArrayList list = (ArrayList)linkMap.get(figure);
    if(list != null) { 

      list.remove(link);
      if(list.isEmpty())
        linkMap.remove(figure);

    }

  }

  public Figure[] getConnected(Figure figure, Figure[] array) {

    ArrayList list = (ArrayList)linkMap.get(figure);
    if(list != null) {
      
      if(array == null)
        array = new Figure[list.size()];

      array = (Figure[])list.toArray((Object[])array);

    } else if(array != null && list != null && list.size() > 0)
      list.set(0, null); // Terminate array
      
    return array;

  }

  protected class Layer {

    protected ArrayList figureList = new ArrayList();
    
    public void add(Figure f) {
      figureList.add(f);
    }

    public void removeAll() {
      figureList.clear();
    }

    public void remove(Figure f) {
      figureList.remove(f);
    }

    public void raise(Figure f) {
      
      figureList.remove(f);
      figureList.add(f);
      
    }
    
    public void lower(Figure f) {
      
      figureList.remove(f);
      figureList.add(0, f);
      
    }
    
    public boolean contains(Figure f) {
      return figureList.contains(f);
    }
    
    public Figure findFigure(Point2D pt) {
      
      for(int i = figureList.size(); --i >= 0;) {
        
        Figure f = (Figure)figureList.get(i);
        if(f.contains(pt))
          return f;
        
      }
      
      return null;
      
    }

    public void paintLayer(Graphics g) {

      clip = g.getClipBounds(clip);

      SelectionModel selectionModel = diagram.getSelectionModel();

      for(int i=0; i < figureList.size(); i++) {
      
        Figure figure = (Figure)figureList.get(i);
        FigureRenderer renderer = diagram.getFigureRenderer(figure.getClass());
        if(renderer == null)
          throw new RuntimeException("No renderer for this Figure");

        if(clip == null || figure.intersects(clip)) {

          boolean hasFocus = (selectionModel == null) ? false : selectionModel.contains(figure);
          
          Component c = renderer.getRendererComponent(diagram, figure, hasFocus);
          if(c == null)
            throw new RuntimeException("No renderer Component for this Figure");

          bounds = (Rectangle)renderer.getDecoratedBounds(diagram, figure, bounds);
          
          paintFigure(g, c, bounds);
          
        }
        
      }


    }

    
    public void paintFigure(Graphics g, Component c, Rectangle r) {
      cellRendererPane.paintComponent(g, c, diagram, r.x, r.y, r.width, r.height, true);
    }




  protected class ModelHandler 
    implements DiagramModelListener, DiagramSelectionListener {

    public void figureAdded(DiagramModel model, Figure figure) {

      if(figure instanceof Link) {

        Link link = (Link)figure;
        linkLayer.add(link);      
        
        addConnection(link.getSource(), link);
        addConnection(link.getSink(), link);

      } else
        figureLayer.add(figure);
      
    }
    
    public void figureRemoved(DiagramModel model, Figure figure) {

      if(figure instanceof Link) {

        Link link = (Link)figure;
        linkLayer.remove(link);

        removeConnection(link.getSource(), link);
        removeConnection(link.getSink(), link);

      } else
        figureLayer.remove(figure);

    }
      
    public void figureAdded(SelectionModel model, Figure figure) {
      
      if((figure instanceof Link) && linkLayer.contains(figure))
        linkLayer.raise(figure);
      else if(figureLayer.contains(figure))
        figureLayer.raise(figure);

    }
    
    public void figureRemoved(SelectionModel model, Figure figure) { }
    


  protected class PropertyChangeHandler implements PropertyChangeListener {

    public void propertyChange(PropertyChangeEvent e) {

      String propertyName = e.getPropertyName();

      if(propertyName.equals("model")) {

        DiagramModel oldModel = (DiagramModel)e.getOldValue();
        DiagramModel newModel = (DiagramModel)e.getNewValue();

        if(oldModel != null)
          oldModel.removeDiagramDataListener(modelListener);

        linkLayer.removeAll();
        figureLayer.removeAll();
        linkMap.clear();

        if(newModel != null) {

          newModel.addDiagramDataListener(modelListener);       
          for(Iterator i = newModel.iterator();i.hasNext();) 
            modelListener.figureAdded(newModel, (Figure)i.next());
          
          
        }

        repaintDiagram();

      } else if(propertyName.equals("selectionModel")) {

        SelectionModel oldModel = (SelectionModel)e.getOldValue();
        SelectionModel newModel = (SelectionModel)e.getNewValue();

        if(oldModel != null)
          oldModel.removeSelectionListener(modelListener);
        
        if (newModel != null) 
          newModel.addSelectionListener(modelListener);
        
        repaintDiagram();

      } else if(propertyName.equals("fastRefresh")) {
        fastRefresh = e.getNewValue().equals("true");
      } else if(propertyName.equals("diagram.background")) {
        diagram.setBackground((Color)e.getNewValue());
      } else if(propertyName.equals("diagram.foreground")) {
        diagram.setForeground((Color)e.getNewValue());
      } else if(propertyName.equals("diagram.border")) {
        diagram.setBorder((Border)e.getNewValue());
      }

    }


  private final void repaintDiagram() {
    diagram.invalidate();
    diagram.repaint();
  }

}
```

File: diagram.DiagramModelListener
```java

package diagram;

public interface DiagramModelListener {

  public void figureAdded(DiagramModel model, Figure figure);
  
  public void figureRemoved(DiagramModel model, Figure figure);


}
```

File: diagram.FigureEditorListener
```java

package diagram;

public interface FigureEditorListener {

  public void editingCanceled(FigureEditor editor, Figure figure, Object lastValue);

  public void editingStarted(FigureEditor editor, Figure figure, Object lastValue);

  public void editingStopped(FigureEditor editor, Figure figure, Object lastValue);

}
```

File: diagram.LinkLabel
```java

package diagram;

import java.awt.Component;
import java.awt.FontMetrics;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.JTextField;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.PlainDocument;

import diagram.figures.PolyLink;


public class LinkLabel extends JTextField 
  implements FigureRenderer {
  
  protected Point2D p1 = null;
  protected Point2D p2 = null;

  public Document createDefaultModel() {
    return new SimpleDocument();
  }
  
  protected void updateBounds() {

  }

  public Component getRendererComponent(Diagram diagram, Figure figure, boolean isSelected) {
    return this;
  }

  public Rectangle2D getDecoratedBounds(Diagram diagram, Figure figure, Rectangle2D rcBounds) {
    
    Object label = diagram.getModel().getValue(figure);
    setText(label != null ? label.toString() : "");

    if(rcBounds == null)
      rcBounds = new Rectangle2D.Double();

    return calculateLabelBounds((PolyLink)figure, getText(), rcBounds);

  }

  protected int calculateLabelSegment(PolyLink link) {

    double d, max = 0;
    int n = 0;

    p2 = link.getPN(1, p2);
    p1 = link.getSource().getConnection(p2, p1);
      
    max = p1.distance(p2);
    
    for(int i = 1; i < link.getSegmentCount() - 1; i++) {
        
      p1 = link.getPN(i, p1);
      p2 = link.getPN(i+1, p2);

      if((d = p1.distance(p2)) > max) {
        max = d;
        n = i;
      }

    }

    p2 = link.getPN(link.getPointCount() - 2, p2);
    p1 = link.getSink().getConnection(p2, p1);

    if((d = p1.distance(p2)) > max)
      n = link.getSegmentCount() - 1;

    return n;

  }

  public Rectangle2D calculateLabelBounds(PolyLink link, String text, Rectangle2D rc) {

    int seg = calculateLabelSegment(link);
    
    double dx = 0;//getX(); 
    double dy = 0;//getY();

    double x1 = link.getXN(seg) - dx; double x2 = link.getXN(seg+1) - dx;
    double y1 = link.getYN(seg) - dy; double y2 = link.getYN(seg+1) - dy;

    dx = (x1 > x2) ? (x1 - x2)*-1 : (x2 - x1);
    dy = (y1 > y2) ? (y1 - y2)*-1 : (y2 - y1);

    FontMetrics metrics = getFontMetrics( getFont() );
    
    int w = metrics.charsWidth(text.toCharArray(), 0, text.length());
    int h = metrics.getHeight();

    dx -= w;
    dy -= h;

    dx /= 2;
    dy /= 2;

    if(rc == null)
      return new Rectangle2D.Double((x1 + dx), (y1 + dy), w, h);

    rc.setFrame((x1 + dx), (y1 + dy), w, h);
    return rc;
  }

  class SimpleDocument extends PlainDocument {
    
    public void insertString(int offs, String str, AttributeSet a) 
      throws BadLocationException {
      
      super.insertString(offs, str, a);
      updateBounds();
      
    }
    
    public void remove(int offs, int len)
      throws BadLocationException {
      
      super.remove(offs, len);
      updateBounds();
      
    }
    
  }


}
```

File: diagram.shape.DiamondHead
```java

package diagram.shape;

import java.awt.geom.GeneralPath;

public class DiamondHead {


  public static GeneralPath createDiamondHead(double x, double y, double w, double h) {
    return createDiamondHead(x, y, w, h, null);
  }

  public static GeneralPath createDiamondHead(double x, double y, double w, double h, GeneralPath path) {

    if(path == null)
      path = new GeneralPath();
    else
      path.reset();

    path.moveTo((float)x, (float)y);   
    path.lineTo((float)(x+1.5*w), (float)(y-h));
    path.lineTo((float)(x+3.0*w), (float)y);
    path.lineTo((float)(x+1.5*w), (float)(y+h));

    path.closePath();

    return path;

  }

}
```

File: diagram.shape.ArrowHead
```java

package diagram.shape;

import java.awt.geom.GeneralPath;

public class ArrowHead {

  public final static int CROOKED = 0;
  public final static int FLAT = 1;
  public final static int OPEN = 2;

  public static GeneralPath createArrowHead(double size, int type, double x, double y) {
    return createArrowHead(size, type, x, y, null);
  }

  public static GeneralPath createArrowHead(double size, int type, double x, double y, GeneralPath path) {

    if(path == null)
      path = new GeneralPath();
    else
      path.reset();

    double l1 = size*1.0;
    double l2 = size*1.0;
    double l3 = size*0.5;

    path.moveTo((float)x, (float)y);
    path.lineTo((float)(x+l2), (float)(y+l3));
    
    if(type != OPEN) {

      if(type == CROOKED)
        path.lineTo((float)(x+l1*0.85), (float)y);
      
      path.lineTo((float)(x+l2), (float)(y-l3));
      
      path.closePath();

    } else {

      path.moveTo((float)x, (float)y);
      path.lineTo((float)(x+l2), (float)(y-l3));

    }

    return path;

  }

}
```

File: diagram.shape.PolyLine2D
```java

package diagram.shape;

import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.util.NoSuchElementException;

public abstract class PolyLine2D extends Line2D 
  implements Serializable {

  protected int pointCount = 2;

  abstract public Point2D getPN(int index);

  abstract public Point2D getPN(int index, Point2D pt);
   
  public void setPN(int index, Point2D pt) {
    setPN(index, pt.getX(), pt.getY());
  }

  abstract public void setPN(int index, double x, double y);

  abstract public double getXN(int index);

  abstract public double getYN(int index);


  public int getPointCount() {
    return pointCount;
  }

  public int getSegmentCount() {
    return (getPointCount() - 1);
  }

  public int segmentFor(Point2D pt, double tolerance) {
    return segmentFor(pt.getX(), pt.getY(), tolerance);
  }
  
  abstract public int segmentFor(double x, double y, double tolerance);
  
  abstract public int pointFor(double x, double y, double tolerance);

  abstract public Rectangle2D getBounds2D(Rectangle2D rc);

  public Rectangle2D getBounds2D() {
    return getBounds2D(null);
  }

  public boolean contains(Point2D pt) {
    return contains(pt.getX(), pt.getY());
  }

  public boolean contains(double x, double y) {
    return contains(x, y, 3.0);
  }

  public boolean contains(double x, double y, double tolerance) {
    return segmentFor(x, y, tolerance) != -1;
  }

  
  public Point2D getCenter(Point2D pt) {   
    
    double x1 = getX1(), x2 = getX2();
    double y1 = getY1(), y2 = getY2();
    
    double x = (x1 > x2) ? (x1-x2)/2.0 : (x2-x1)/2.0;
    double y = (y1 > y2) ? (y1-y2)/2.0 : (y2-y1)/2.0;

    if(pt == null)
      return  new Point2D.Double(x, y);
    
    pt.setLocation(x, y);
    return pt;
    
  }

  public boolean intersects(double x, double y, double w, double h) {
    throw new UnsupportedOperationException();
  }
  
  abstract public void translate(double x, double y);

  abstract public Point2D split(int segment, double x, double y);

  public Point2D split(int segment, Point2D pt) {
    return split(segment, pt.getX(), pt.getY());
  }

  abstract public void join(int point);


  public PathIterator getPathIterator(AffineTransform at, double flatness) {
    return getPathIterator(at);
  }

  public PathIterator getPathIterator(AffineTransform at) {
    return new Iterator(at);
  }


  static public class Double extends PolyLine2D 
    implements Serializable {

    protected Point2D.Double[] points;
 
    public Double() {
      points = new Point2D.Double[] { new Point2D.Double(0,0), new Point2D.Double(0,0) };
    }

    public Double(Point2D p1, Point2D p2) {
      points[0].setLocation(p1);
      points[1].setLocation(p2);
    }

    public void setPN(int index, double x, double y) {

      if(index >= pointCount)
        throw new NoSuchElementException("index out of bounds");
      
      points[index].x = x;
      points[index].y = y;

    }

    public Point2D getPN(int index) {

      if(index >= pointCount)
        throw new NoSuchElementException("index out of bounds");

      return points[index];

    }

    public Point2D getPN(int index, Point2D pt) {

      if(index >= pointCount)
        throw new NoSuchElementException("index out of bounds");

      if(pt == null)
        return new Point2D.Double(points[index].x, points[index].y);

      pt.setLocation(points[index]);
      return pt;

    }

    public Point2D getP1() {
      return points[0];
    }

    public Point2D getP2() {
      return points[pointCount-1];
    }

    public double getXN(int index) {

      if(index >= pointCount)
        throw new NoSuchElementException("index out of bounds");

      return points[index].x;

    }

    public double getYN(int index) {

      if(index >= pointCount)
        throw new NoSuchElementException("index out of bounds");

      return points[index].y;

    }

    public double getX1() {
      return points[0].x;
    }

    public double getY1() {
      return points[0].y;
    }

    public double getX2() {
      return points[pointCount-1].x;
    }

    public double getY2() {
      return points[pointCount-1].y;
    }

    public Rectangle2D getBounds2D(Rectangle2D rc) {

      double x1 = java.lang.Double.MAX_VALUE;
      double y1 = java.lang.Double.MAX_VALUE;
      double x2 = 0;
      double y2 = 0;
      
      for(int i = 0; i < pointCount; i++) {

        double x = points[i].x;
        double y = points[i].y;

        if(x < x1) 
          x1 = x;
        
        if(x > x2)
          x2 = x;
               
        if(y < y1) 
          y1 = y;
        
        if(y > y2) 
          y2 = y;
            
      }
     
      if((x2-x1) < 0 || (y2-y1) < 0)
        throw new RuntimeException("Bad Bounds2D [" + x1 + ", " + y1 + ", " + x2 + ", "+ y2 +"]");

      if(rc == null)
        return new Rectangle2D.Double(x1,y1,(x2-x1+1),(y2-y1+1));

      rc.setRect(x1,y1,(x2-x1+1) ,(y2-y1+1));
      return rc;

    }

    public int segmentFor(double x, double y, double tolerance) {
      
      double x1 = points[0].x, y1 = points[0].y;
      double x2, y2;

      int s = -1;
      
      for(int i = 1; i < getPointCount(); i++) {
        
        x2 = points[i].x;
        y2 = points[i].y;
        
        double dist;
        if((dist = ptSegDist(x1, y1, x2, y2, x, y)) < tolerance) {
          tolerance = dist;
          s = (i-1);
        }
        
        x1 = x2;
        y1 = y2;

      }
        
      return s;

    }


    public int pointFor(double x, double y, double tolerance) {

      int p = -1;
      double dist = tolerance;

      for(int i = 0; i < getPointCount(); i++) {
        
        dist = Point2D.distanceSq(x, y, points[i].x, points[i].y);
        if(dist < tolerance) {
          tolerance = dist;
          p = i; 
        }

      }
      
      return p;

    }

    public void setLine(double X1, double Y1, double X2, double Y2) {
      
      points[0].setLocation(X1, Y1);
      points[1].setLocation(X2, Y2);

      pointCount = 2;

    }

    public void translate(double x, double y) {
      
      for(int i=0; i < pointCount; i++) {
        points[i].x += x;
        points[i].y += y;
      }

    }

    public Point2D split(int segment, double x, double y) {

      if(segment++ >= (pointCount - 1))
        throw new NoSuchElementException("segment index out of bounds");     

      if(pointCount == points.length) {
        
        Point2D.Double[] temp = new Point2D.Double[pointCount*2];
        System.arraycopy(points, 0, temp, 0, pointCount);
        points = temp;        

      }
   
      System.arraycopy(points, segment, points, (segment+1), pointCount-segment);
      points[segment] = new Point2D.Double(x, y);
      pointCount++;

      return points[segment];

    }
    
    public void join(int point) {
     
      if(point > (pointCount - 2) || point < 1)
        throw new NoSuchElementException("point index out of bounds");    

      System.arraycopy(points, point+1, points, point, (pointCount-point-1));
      pointCount--;

    }

    public boolean intersects(Rectangle2D rc) {
      
      for(int i=0; i < pointCount-1; i++) {
        if(rc.intersectsLine(points[i].x, points[i].y, points[i+1].x, points[i+1].y))
          return true;
      }
      return false;
    }

    private void writeObject(java.io.ObjectOutputStream out)
      throws java.io.IOException {
      
      out.writeInt(pointCount);
      for(int i = 0; i < pointCount; i++) {
        out.writeDouble(points[i].x);
        out.writeDouble(points[i].y);
      }
      
    }
    
    private void readObject(java.io.ObjectInputStream in)
      throws java.io.IOException, ClassNotFoundException {
      
      pointCount = in.readInt();
      points = new Point2D.Double[pointCount];

      for(int i = 0; i < pointCount; i++) 
        points[i] = new Point2D.Double(in.readDouble(), in.readDouble());
      
    }

    public Object clone() {
      
      Double link = (Double)super.clone();
      link.points = new Point2D.Double[pointCount];
      for(int i=0; i < pointCount; i++) 
        link.points[i] = new Point2D.Double(points[i].x, points[i].y);
      
      return link;

    }




  protected class Iterator implements PathIterator {

    private AffineTransform affine;
    private int index;

    public Iterator(AffineTransform at) {
      this.affine = at;
      this.index = 0;
    }

    public int currentSegment(double coords[]) {

      coords[0] = getXN(index);
      coords[1] = getYN(index);

      if(affine != null) 
        affine.transform(coords, 0, coords, 0, 1);

      return (index == 0) ? SEG_MOVETO : SEG_LINETO;

    }

    public int currentSegment(float coords[]) {

      coords[0] = (float)getXN(index);
      coords[1] = (float)getYN(index);

      if(affine != null) 
        affine.transform(coords, 0, coords, 0, 1);

      return (index == 0) ? SEG_MOVETO : SEG_LINETO;

    }

    public int getWindingRule() {
      return WIND_NON_ZERO;
    }

    public boolean isDone() {
      return (index >= getPointCount());
    }
    
    public void next() {
      index++;
    }



  public String toString() {
    return getClass() + "[" + getBounds() + "]@" + hashCode();
  }


}

```

File: diagram.figures.PointFigure
```java

package diagram.figures;



public class PointFigure extends CircularFigure {

  public PointFigure() {
    this(0);
  }

  public PointFigure(double diameter) {
    this(0, 0, diameter);
  }

  public PointFigure(double x, double y, double diameter) {
    super(x, y, diameter, diameter);
  }

  public void setBounds(double x, double y, double w, double h) {
    super.setBounds(x, y, (w > h) ? w: h, (w > h) ? w: h);
  }

  public void setLocation(double x, double y) {
    this.x = x;
    this.y = y;
  }

}
```

File: diagram.figures.PolyLink
```java

package diagram.figures;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;

import diagram.Figure;
import diagram.Link;
import diagram.shape.PolyLine2D;

public class PolyLink extends PolyLine2D.Double 
  implements Link, Serializable {

  protected Figure source;
  protected Figure sink;

  public PolyLink(Figure source, Figure sink) {

    if(source == null || sink == null)
      throw new IllegalArgumentException("null Figures not allowed");

    this.source = source;
    this.sink = sink;

  } 


  public Figure getSource() {
    return this.source;
  }

  public Point2D getSourceAnchor(Point2D pt) {
    return (pt = source.getAnchor(pt));
  }
  

  public Figure getSink() {
    return this.sink;
  }

  public Point2D getSinkAnchor(Point2D pt) {
    return (pt = sink.getAnchor(pt));
  }


  private final void updateEndpoints() {

    getSourceAnchor(getP1());
    getSinkAnchor(getP2());

  }

  public boolean contains(double x, double y, double tolerance) {
    updateEndpoints();
    return super.contains(x, y, tolerance);
  }
  
  public Rectangle2D getBounds2D(Rectangle2D rc) {
    updateEndpoints();
    return super.getBounds2D(rc);
  }

  public Point2D getAnchor(Point2D pt) {
    updateEndpoints();
    return getCenter(pt);
  }

  public Point2D getConnection(Point2D ptFrom, Point2D pt) {

    updateEndpoints();

    double dist = java.lang.Double.MAX_VALUE;

    for(int i=1; i < pointCount-1; i++) {
      
      double d = getPN(i).distance(ptFrom);
      if(d < dist) {

        dist = d;
        if(pt == null)
          pt = new Point2D.Double(getXN(i), getYN(i));
        else 
          pt.setLocation(getXN(i), getYN(i));

      }

    }

    return pt;

  }

  public boolean intersects(double x, double y, double w, double h) {
    updateEndpoints(); 
    return super.intersects(x, y, w, h);
  }

  public void setBounds(double x, double y, double w, double h) {
  }


  public Figure setSource(Figure figure) {

    Figure oldSource = source;

    source = figure;
    return oldSource;

  }

  public Figure setSink(Figure figure) {

    Figure oldSink = sink;

    sink = figure;
    return oldSink;

  }
  
  public int hashCode() {
    return getClass().hashCode();
  }

}
```

File: diagram.figures.RectangularFigure
```java

package diagram.figures;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;

import diagram.Figure;

public class RectangularFigure extends Rectangle2D.Double 
  implements Cloneable, Figure, Serializable {
  
  public RectangularFigure() { 
    this(0, 0, 0, 0);
  }

  public RectangularFigure(double w, double h) { 
    this(0, 0, w, h);
  }

  public RectangularFigure(double x, double y, double w, double h) { 
    setRect(x, y, w, h);
  }

  public Rectangle2D getBounds2D(Rectangle2D rc) {

    if(rc == null)
      return getBounds2D();

    rc.setRect(x, y, width, height);
    return rc;

  }

 
  public Point2D getCenter(Point2D pt) {
    
    if(pt == null)
      return new Point2D.Double(getCenterX(), getCenterY());

    pt.setLocation(getCenterX(), getCenterY());
    return pt;

  }



  public void translate(double x, double y) {

    this.x += x;
    this.y += y;

  }


  public Point2D getConnection(Point2D ptFrom, Point2D pt) {
    
    if(contains(ptFrom)) {

      if(pt == null)
        pt = new Point2D.Double();

      pt.setLocation(ptFrom);
      return pt;

    }

    double right  = this.x + this.width - 1;
    double bottom = this.y + this.height - 1;
    
    double centerX = getCenterX();
    double centerY = getCenterY();
    
    double s, t;
    
    double dx = (ptFrom.getX() - centerX);
    double dy = (ptFrom.getY() - centerY);
    
    if(dx > 0)
      s = (right - centerX) / dx;
    else 
      s = (dx < 0) ? ((this.x - centerX) / dx) : java.lang.Double.POSITIVE_INFINITY;
    
    if(dy < 0)
      t = (this.y - centerY) / dy;
    else
      t = (dy > 0) ? ((bottom - centerY) / dy) : java.lang.Double.POSITIVE_INFINITY;
    
    double A = (s < t) ? (centerX + s * dx) : (centerX + t * dx);
    double B = (s < t) ? (centerY + s * dy) : (centerY + t * dy);
    
    if(pt == null)
      return new Point2D.Double(A, B);

    pt.setLocation(A, B);
    return pt;

  }


  public Point2D getAnchor(Point2D pt) {
    return getCenter(pt);
  }


  public void setBounds(double x, double y, double w, double h) {

    this.x = x;
    this.y = y;
    this.width = w;
    this.height = h;

  }
 
  private static int generateLocalHash() {
    Class c = RectangularFigure.class;
    return (c.hashCode() + figureId++);
  }
  private static int figureId = 0;

  private int hash = generateLocalHash();

  public int hashCode() {
    return figureId;
  }



  private void writeObject(java.io.ObjectOutputStream out)
    throws java.io.IOException {
    
    out.writeDouble(x);
    out.writeDouble(y);
    out.writeDouble(width);
    out.writeDouble(height);

  }

  private void readObject(java.io.ObjectInputStream in)
    throws java.io.IOException, ClassNotFoundException {

    x = in.readDouble();
    y = in.readDouble();
    width = in.readDouble();
    height = in.readDouble();

  }

 
}
```

File: diagram.figures.CircularFigure
```java

package diagram.figures;

import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;

import diagram.Figure;

public class CircularFigure extends Ellipse2D.Double 
  implements Cloneable, Figure, Serializable {

  public CircularFigure() { 
    this(0, 0, 0, 0);
  }

  public CircularFigure(double w, double h) { 
    this(0, 0, w, h);
  }

  public CircularFigure(double x, double y, double w, double h) { 
    setFrame(x, y, w, h);
  }

  
  public Rectangle2D getBounds2D(Rectangle2D rc) {

    if(rc == null)
      return getBounds2D();

    rc.setRect(x, y, width, height);
    return rc;

  }

 
  public Point2D getCenter(Point2D pt) {
    
    if(pt == null)
      return new Point2D.Double(getCenterX(), getCenterY());

    pt.setLocation(getCenterX(), getCenterY());
    return pt;

  }

 
  public void translate(double x, double y) {

    this.x += x;
    this.y += y;

  }

  public Point2D getConnection(Point2D ptFrom, Point2D pt) {
    
    if(contains(ptFrom)) {

      if(pt == null)
        pt = new Point2D.Double();

      pt.setLocation(ptFrom);
      return pt;

    }
       
    double centerX = getCenterX();
    double centerY = getCenterY();
    
    double dy = (ptFrom.getY() - centerY);
    double dx = (ptFrom.getX() - centerX);

    double theta = Math.atan2(dy, dx);
    
    double rx = width / 2.0;
    double ry = height / 2.0;
    
    double A = centerX, B = centerY;
    
    if(rx == ry) { 
      
      A += rx*Math.cos(theta);
      B += ry*Math.sin(theta);
      
    } else {
      
      if((Math.abs(theta - (Math.PI/2.0)) == 0))
        B += ry;
      
      else if((Math.abs(theta + (Math.PI/2.0)) == 0))
        B -= ry;
      
      else {
        
        double m = Math.tan(theta);
        double n = rx*ry / (Math.sqrt(ry*ry + rx*rx * m*m));
        
        if(theta > (Math.PI/2.0) || theta < -(Math.PI/2.0))
          n = -n;
        
        A += n;
        B += m*n;
        
      }        
      
    }    
    
    if(pt == null)
      return new Point2D.Double(A, B);
    
    pt.setLocation(A, B);
    return pt;

  }

  public Point2D getAnchor(Point2D pt) {
    return getCenter(pt);
  }

  public void setBounds(double x, double y, double w, double h) {

    this.x = x;
    this.y = y;
    this.width = w;
    this.height = h;

  }

  private static int generateLocalHash() {
    Class c = CircularFigure.class;
    return (c.hashCode() + figureId++);
  }

  private int hash = generateLocalHash();
  private static int figureId = 0;

  public int hashCode() {
    return figureId;
  }


  private void writeObject(java.io.ObjectOutputStream out)
    throws java.io.IOException {
    
    out.writeDouble(x);
    out.writeDouble(y);
    out.writeDouble(width);
    out.writeDouble(height);

  }

  private void readObject(java.io.ObjectInputStream in)
    throws java.io.IOException, ClassNotFoundException {

    x = in.readDouble();
    y = in.readDouble();
    width = in.readDouble();
    height = in.readDouble();

  }

}
```

File: diagram.figures.FigureBorder
```java

package diagram.figures;

import java.awt.geom.Point2D;

import diagram.Figure;

public class FigureBorder {

  public static boolean isBorderPoint(Figure figure, Point2D pt) {
    return isBorderPoint(figure, pt, 8.0); 
  }

  public static boolean isBorderPoint(Figure figure, Point2D pt, double tolerance) {

    double pressX = pt.getX();
    double pressY = pt.getY();
    
    return (!figure.contains(pressX + tolerance, pressY + tolerance) ||
            !figure.contains(pressX + tolerance, pressY - tolerance) ||
            !figure.contains(pressX - tolerance, pressY + tolerance) ||
            !figure.contains(pressX - tolerance, pressY - tolerance));

  }

}
```

File: diagram.figures.PolygonFigure
```java

package diagram.figures;

import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.Serializable;

import diagram.Figure;

public class PolygonFigure extends Polygon
  implements Cloneable, Figure, Serializable {

  public Rectangle2D getBounds2D(Rectangle2D rc) {

    if(rc == null)
      return new Rectangle2D.Double(bounds.x, bounds.y, bounds.width, bounds.height);

    rc.setRect(bounds.x, bounds.y, bounds.width, bounds.height);
    return rc;

  }

  public Point2D getCenter(Point2D pt) {

    double centerX = bounds.x + bounds.width/2;
    double centerY = bounds.y + bounds.height/2;
    
    if(pt == null)
      return new Point2D.Double(centerX, centerY);

    pt.setLocation(centerX, centerY);
    return pt;

  }


  public void translate(double x, double y) {
    super.translate((int)x, (int)y);
  }
  

  public Point2D getConnection(Point2D ptFrom, Point2D pt) {
    
    if(contains(ptFrom)) {

      if(pt == null)
        pt = new Point2D.Double();

      pt.setLocation(ptFrom);
      return pt;

    }
    
    double x0,x1,y0,y1;
    
    double centerX = bounds.x + bounds.width/2;
    double centerY = bounds.y + bounds.height/2;
    
    double dy = (ptFrom.getY() - centerY);
    double dx = (ptFrom.getX() - centerX);
    
    double theta = Math.atan2(dy, dx);
    
    double px = centerX + Math.cos(theta);
    double py = centerY + Math.sin(theta);
    
    double A = 0, B = 0, max = 0;
    
    x1 = this.xpoints[this.npoints-1];
    y1 = this.ypoints[this.npoints-1];

    for(int i=0; i < this.npoints; i++) {
      
      x0 = x1;
      y0 = y1;
      x1 = this.xpoints[i];
      y1 = this.ypoints[i];
        
      double n = (x0-centerX)*(py-centerY) - (y0-centerY)*(px-centerX);
      double m = (y1-y0)*(px-centerX) - (x1-x0)*(py-centerY);
      double t = n/m;
      
      
      if(0 <= t && t <= 1) {
        
        double tx = x0 + (x1-x0)*t;
        double ty = y0 + (y1-y0)*t;
        
        boolean xGood = (tx >= centerX && px >= centerX)||(tx < centerX && px < centerX);
        boolean yGood = (ty >= centerY && py >= centerY)||(ty < centerY && py < centerY);
        
        
        if(xGood && yGood) {
          double r = (tx-centerX)*(tx-centerX) + (ty-centerY)*(ty-centerY);
          
          if(r > max) {
            A = tx;
            B = ty;
            max = r;
          }
        }
        
      }
      
    }

    if(pt == null)
      return new Point2D.Double(A, B);
    
    pt.setLocation(A, B);
    return pt;

  }

  public Point2D getAnchor(Point2D pt) {
    return getCenter(pt);
  }

  public void setBounds(double x, double y, double w, double h) {
    
  }

  public Object clone() {

    PolygonFigure fig = new PolygonFigure();

    fig.bounds = (Rectangle)bounds.clone();
    fig.npoints = npoints;

    fig.xpoints = new int[xpoints.length];
    fig.ypoints = new int[ypoints.length];

    System.arraycopy(xpoints, 0, fig.xpoints, 0, xpoints.length);
    System.arraycopy(ypoints, 0, fig.ypoints, 0, ypoints.length);

    return fig;

  }

  private static int generateLocalHash() {
    Class c = PolygonFigure.class;
    return (c.hashCode() + figureId++);
  }

  private int hash = generateLocalHash();
  private static int figureId = 0;

  public int hashCode() {
    return figureId;
  }

}
```

File: diagram.tool.ClipboardTool
```java

package diagram.tool;

import java.awt.event.ActionEvent;
import java.lang.ref.WeakReference;
import java.util.ArrayList;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;

import diagram.Diagram;
import diagram.DiagramModel;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.Link;
import diagram.SelectionModel;

public class ClipboardTool extends AbstractTool {

  protected static ThreadLocal diagramKey = new InheritableThreadLocal();

  protected Action actionCut = new CutAction();
  protected Action actionCopy = new CopyAction();
  protected Action actionPaste = new PasteAction();

  private Figure[] figures = new Figure[4];
  private Figure[] related = new Figure[4];

  private ArrayList clipboard = new ArrayList();
  private ArrayList copyboard = new ArrayList();

  public void install(Diagram diagram) {

    ActionMap map = diagram.getActionMap();

    map.put("cut", actionCut);
    map.put("copy", actionCopy);
    map.put("paste", actionPaste);

    setDiagram(diagram);

  }

  public void uninstall(Diagram diagram) {

    ActionMap map = diagram.getActionMap();

    map.remove("cut");
    map.remove("copy");
    map.remove("paste");

    setDiagram(null);

  }

  static public void setDiagram(Diagram diagram) {
    
    if(getDiagram() != diagram)
      diagramKey.set(new WeakReference(diagram));

  }

  static public Diagram getDiagram() {
    
    Object o = diagramKey.get();
    if(o != null) 
      o = ((WeakReference)o).get();
    
    return (Diagram)o;

  }
  
  protected boolean prepareSelection() {

    Diagram diagram = getDiagram();
    if(diagram == null)
      return false;

    SelectionModel selectionModel = diagram.getSelectionModel();
    if(selectionModel == null)
      return false;

    figures = (Figure[])selectionModel.toArray(figures);
    
    return true;

  }

  public void doCopy() {

    if(!prepareSelection())
      return;

    synchronized(figures) {

      clipboard.clear();
      for(int i=0; i<figures.length && figures[i] != null; i++) {
        
        Figure figure = figures[i];
        clipboard.add(figure);
        
      }
      
    }
    
  }

  public void doCut() {

    if(!prepareSelection())
      return;

    DiagramModel model = getDiagram().getModel();
    DiagramUI ui = (DiagramUI)getDiagram().getUI();

    Figure figure = null;
    for(int i=0; i<figures.length && figures[i] != null; i++) {
      
      figure = figures[i];
      
      related = ui.getConnected(figure, related);
      for(int j=0; j<related.length && related[j] != null; j++) {

        model.remove(related[j]);
        ui.damageFigure(related[j]);
      
      }

      model.remove(figure);
      ui.damageFigure(figure);
      
    }
    
    ui.refreshFigure(figure);
      
  }


  public void doPaste() {

    Diagram diagram = getDiagram();
    if(diagram == null)
      return;

    SelectionModel selectionModel = diagram.getSelectionModel();
    if(selectionModel == null)
      return;

    if(clipboard.isEmpty())
      return;
    
    DiagramModel model = getDiagram().getModel();
    DiagramUI ui = (DiagramUI)getDiagram().getUI();
    Figure figure = null;

    copyboard.addAll(clipboard);
    clipboard.clear();

    selectionModel.clear();

    for(int i=0; i<copyboard.size(); i++) {

      Figure f = (Figure)copyboard.get(i);
      if(f == null)
        continue;

      figure = f;
      ui.damageFigure(figure);

      if(figure instanceof Link) {

        Link link = (Link)figure;
        int index;

        Figure sink = link.getSink();
        if(sink != null && (index = copyboard.indexOf(sink)) != -1) {

          sink = (Figure)sink.clone();

          doPaste(sink, model, selectionModel, ui);
          copyboard.set(index, null);

          Figure source = link.getSource();
          if(source != null && (index = copyboard.indexOf(source)) != -1) {
            
            source = (Figure)source.clone();

            doPaste(source, model, selectionModel, ui);
            copyboard.set(index, null);
            
            System.err.println( link.equals(link.clone()));
            link = (Link)link.clone();

            link.setSink(sink);
            link.setSource(source);
            
            doPaste(link, model, selectionModel, ui);

            copyboard.set(i, null);
            
          }

        }


      } 

    }

    for(int i=0; i<copyboard.size(); i++) {

      Figure f = (Figure)copyboard.get(i);
      if(f != null) {

        ui.damageFigure(f);
        
        figure = (Figure)f.clone();     
        doPaste(figure, model, selectionModel, ui);
                
      }

    }
      
    copyboard.clear();

    ui.refreshFigure(figure);
    
  
  }

  private final void doPaste(Figure figure, 
                             DiagramModel model, SelectionModel selectionModel, DiagramUI ui) {

    figure.translate(10,10);   

    model.add(figure);
    selectionModel.add(figure);

    clipboard.add(figure);
    ui.damageFigure(figure);

  }

  protected class CutAction extends AbstractAction {

    public CutAction() {
      super("Cut");
    }

    public void actionPerformed(ActionEvent e) {
      doCut();
    }

  }

  protected class CopyAction extends AbstractAction {

    public CopyAction() {
      super("Copy");
    }

    public void actionPerformed(ActionEvent e) {
      doCopy();
    }

  }

  protected class PasteAction extends AbstractAction {

    public PasteAction() {
      super("Paste");
    }

    public void actionPerformed(ActionEvent e) {
      doPaste();
    }

  }

}
```

File: diagram.tool.ToolListener
```java


package diagram.tool;

public interface ToolListener {

  public void toolStarted(Tool tool);

  public void toolFinished(Tool tool);

}
```

File: diagram.tool.FigureDraggingTool
```java

package diagram.tool;

import java.awt.Cursor;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.util.ArrayList;

import javax.swing.SwingUtilities;
import javax.swing.event.MouseInputAdapter;

import diagram.Diagram;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.SelectionModel;
import diagram.figures.FigureBorder;

public class FigureDraggingTool extends AbstractTool {

  private static final Cursor MV_CURSOR = new Cursor(Cursor.MOVE_CURSOR);

  private Cursor originalCursor = null;

  protected Figure[] selectedFigures = new Figure[4];
  protected Figure[] relatedFigures = new Figure[4];
  
  private ArrayList relatedList = new ArrayList();

  private Diagram diagram;

  private Point2D dragPoint;

  private MouseHandler mouseHandler  = new MouseHandler();

  public void install(Diagram diagram) {

    diagram.addMouseListener(mouseHandler);
    diagram.addMouseMotionListener(mouseHandler);

  }

  public void uninstall(Diagram diagram) {

    diagram.removeMouseListener(mouseHandler);
    diagram.removeMouseMotionListener(mouseHandler);

    reset();

  }

  protected class MouseHandler extends MouseInputAdapter {

    private final boolean shouldIgnore(MouseEvent e) {
      
      if(e.isControlDown() || e.isAltDown() || e.getClickCount() > 1)
        return true;
      
      return (e.isConsumed() || !SwingUtilities.isLeftMouseButton(e) || dragPoint != null);
      
    }
    
    public void mousePressed(MouseEvent e) {
      
      if(shouldIgnore(e))
        return;
      
      diagram = (Diagram)e.getSource();
      Point2D pt = e.getPoint();
      
      Diagram diagram = (Diagram)e.getSource();
      SelectionModel selectionModel = diagram.getSelectionModel();
      
      if(selectionModel == null || selectionModel.size() < 1)
        return;
      
      Figure node = (Figure)diagram.findFigure(e.getPoint());
      
      if(node == null || !selectionModel.contains(node) || 
         FigureBorder.isBorderPoint(node, pt))
        return;
      
      e.consume();
      fireToolStarted();

      selectedFigures = (Figure[])selectionModel.toArray(selectedFigures);
      getRelatedFigures();
      
      dragPoint = pt;
      
      originalCursor = diagram.getCursor();
      diagram.setCursor(MV_CURSOR);
      
    }
    
    public void mouseDragged(MouseEvent e) {
      
      if(!e.isConsumed() && dragPoint != null) {
        
        e.consume();
        
        Point2D pt = e.getPoint();
        
        double dx = pt.getX() - dragPoint.getX();
        double dy = pt.getY() - dragPoint.getY();
        
        DiagramUI ui = (DiagramUI)diagram.getUI();
        
        Figure[] selected = selectedFigures;
        Figure[] related = relatedFigures;
        
        for(int j=0; j < related.length && related[j] != null; j++)
          ui.damageFigure(related[j]);
        
        Figure figure = null;
        for(int i=0; i < selected.length && selected[i] != null; i++) {
          
          figure = selected[i];
          
          ui.damageFigure(figure);
          figure.translate(dx, dy);
          ui.damageFigure(figure);
          
        }
        
        for(int j=0; j < related.length && related[j] != null; j++) 
          ui.damageFigure(related[j]);
        
        ui.refreshFigure(figure);
        
        dragPoint = pt;
        
      }
      
    }
    
    public void mouseReleased(MouseEvent e) {
      
      if(dragPoint == null)
        return;
      
      e.consume();

      ((DiagramUI)diagram.getUI()).repaintRegion(null);
      
      reset();
      fireToolFinished();      
      
    }
    
  }
  

  protected void getRelatedFigures() {

    ArrayList list = relatedList;

    Figure[] figures = selectedFigures;
    Figure[] cache = relatedFigures;

    DiagramUI ui = (DiagramUI)diagram.getUI();
    for(int i=0; i < figures.length && figures[i] != null; i++) {
      
      cache = ui.getConnected(figures[i], cache);
      for(int j=0; j<cache.length && cache[j] != null; j++)
        relatedList.add(cache[j]);

    }

    relatedFigures = (Figure[])list.toArray(relatedFigures);
    list.clear();

  }



  protected void reset() {

    if(diagram != null && originalCursor != null)
      diagram.setCursor(originalCursor);
    
    diagram = null;
    dragPoint = null;

    java.util.Arrays.fill(selectedFigures, 0, selectedFigures.length, null);
    java.util.Arrays.fill(relatedFigures, 0, relatedFigures.length, null);

  }

}
```

File: diagram.tool.FigureTool
```java

package diagram.tool;

import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.event.MouseInputAdapter;

import diagram.Diagram;
import diagram.DiagramUI;
import diagram.Figure;

public class FigureTool extends AbstractTool {

  private Diagram diagram;
  private Point2D ptPress;

  private Figure fig;
  private Figure current;
  
  private Rectangle2D rcBounds = new Rectangle2D.Double();

  private MouseHandler mouseHandler = new MouseHandler();

  public FigureTool(Figure fig) {
    this.fig = fig;
  }


  public void install(Diagram diagram) {

    diagram.addMouseListener(mouseHandler);
    diagram.addMouseMotionListener(mouseHandler);

  }

  public void uninstall(Diagram diagram) {

    diagram.removeMouseListener(mouseHandler);
    diagram.removeMouseMotionListener(mouseHandler);

    reset();

  }
  

  protected class MouseHandler extends MouseInputAdapter {

    public void mousePressed(MouseEvent e) {
      
      Object o = e.getSource();
      
      if(!e.isConsumed() && (o instanceof Diagram)) {
        
        e.consume();
        fireToolStarted();
        
        ptPress = e.getPoint();
        
        current = (Figure)fig.clone();
        
        diagram = (Diagram)o;
        diagram.getModel().add(current);
      
      }
      
    }
    
    public void mouseDragged(MouseEvent e) {
      
      if(diagram == null)
        return;
      
      updateBounds(e.getPoint(), ptPress);
      
      DiagramUI ui = (DiagramUI)diagram.getUI();
      
      ui.damageFigure(current);
      current.setBounds(rcBounds.getX(), rcBounds.getY(), rcBounds.getWidth(), rcBounds.getHeight());
      ui.refreshFigure(current);
      
    }
    
    public void mouseReleased(MouseEvent e) {
      
      if(diagram == null)
        return;
      
      updateBounds(e.getPoint(), ptPress);
      
      if(rcBounds.getWidth() < 20 || rcBounds.getHeight() < 20) {
        
        rcBounds = fig.getBounds2D(rcBounds);
        current.setBounds(ptPress.getX(), ptPress.getY(),
                          rcBounds.getWidth(), rcBounds.getHeight());
        
        DiagramUI ui = (DiagramUI)diagram.getUI();
        ui.repaintFigure(current);
        
      }
      
      reset();
      fireToolFinished();

    }
    

  protected void updateBounds(Point2D pt1, Point2D pt2) {
    
    double x1 = pt1.getX();
    double x2 = pt2.getX();
    double y1 = pt1.getY();
    double y2 = pt2.getY();

    double x, y, w, h;

    if(x1 < x2) {
      x = x1;
      w = (x2 - x1);
    } else {
      w = (x1 - x2);
      x = x2;
    }

    if(y1 < y2) {
      y = y1; 
      h = (y2 - y1);
    } else {
      h = (y1 - y2);
      y = y2;
    }

    rcBounds.setFrame(x, y, w, h);

  }

  protected void reset() {
    current = null;
    diagram = null;
  }

}
```

File: diagram.tool.FigureShappingTool
```java

package diagram.tool;

import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import javax.swing.SwingUtilities;
import javax.swing.event.MouseInputAdapter;

import diagram.Diagram;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.Link;
import diagram.figures.FigureBorder;


public class FigureShappingTool extends AbstractTool {

  private static final Cursor HZ_CURSOR = new Cursor(Cursor.W_RESIZE_CURSOR);
  private static final Cursor VT_CURSOR = new Cursor(Cursor.N_RESIZE_CURSOR);
  private static final Cursor SENW_CURSOR = new Cursor(Cursor.NW_RESIZE_CURSOR);
  private static final Cursor SWNE_CURSOR = new Cursor(Cursor.SW_RESIZE_CURSOR);

  private static final int QUAD_LEFT   = 0x01;
  private static final int QUAD_MIDDLE = 0x02;
  private static final int QUAD_RIGHT  = 0x04;
  private static final int QUAD_TOP    = 0x100;
  private static final int QUAD_CENTER = 0x200;
  private static final int QUAD_BOTTOM = 0x400;

  private static final int MINIMUM_SIZE = 0x10;

  private MouseHandler mouseHandler = new MouseHandler();

  private Graphics2D graphics;
  
  private Point2D dragPoint;
  private Point2D lastPoint;

  private Rectangle2D.Double outline = new Rectangle2D.Double();
  private Cursor originalCursor = null;
  private Diagram diagram;

  private Point2D center;
  private Rectangle2D bounds;
  private Figure figure = null;
  protected Figure[] relatedFigures = new Figure[4];

  private int sizingDirection = -1;


  public void install(Diagram diagram) {
    diagram.addMouseListener(mouseHandler);
    diagram.addMouseMotionListener(mouseHandler);
  }
  
  public void uninstall(Diagram diagram) {

    diagram.removeMouseListener(mouseHandler);
    diagram.removeMouseMotionListener(mouseHandler);

    reset();

  }

  
  protected class MouseHandler extends MouseInputAdapter {

    public void mousePressed(MouseEvent e) {
      
      if(e.isConsumed() || !SwingUtilities.isLeftMouseButton(e))
        return;
      
      diagram = (Diagram)e.getSource();
      Point2D pt = e.getPoint();
      
      figure = (Figure)diagram.findFigure(pt);
      
      if(figure == null || (figure instanceof Link)) {
        reset();
        return;
      }
      
      
      bounds  = figure.getBounds2D(bounds);
      center = figure.getCenter(center);
      
      if(!FigureBorder.isBorderPoint(figure, pt)) {
        reset();
        return;
      }

      e.consume();
      fireToolStarted();

      outline.setFrame(bounds);
      
      dragPoint = pt;
      getQuadrant(dragPoint);

      originalCursor = diagram.getCursor();
      diagram.setCursor(getCursor());
    
      graphics = getGraphics(diagram);
      
      DiagramUI ui = (DiagramUI)diagram.getUI();
      relatedFigures = ui.getConnected(figure, relatedFigures);

    } 


    public void mouseDragged(MouseEvent e) {

      if(dragPoint == null) 
        return;

      Point2D pt = e.getPoint();

      double dx = pt.getX() - dragPoint.getX();
      double dy = pt.getY() - dragPoint.getY();

      paintOutline(dx, dy, false);

      lastPoint = pt;

    }

    public void mouseReleased(MouseEvent e) {

      if(dragPoint != null) {
      
        if(lastPoint != null) { 

          paintOutline(0, 0, true);
        
          figure.setBounds(outline.getX(), outline.getY(), 
                           outline.getWidth(), outline.getHeight());

        }

        DiagramUI ui = (DiagramUI)diagram.getUI();
        Figure[] related = relatedFigures;

        for(int j=0; j < related.length && related[j] != null; j++)
          ui.damageFigure(related[j]);

        ((DiagramUI)diagram.getUI()).refreshFigure(figure);
        reset();

        fireToolFinished();

      }
    
    }

  }

  private final void paintOutline(double dx, double dy, boolean eraseOnly) {

    if(lastPoint != null)
      graphics.drawRect((int)outline.x, (int)outline.y, (int)outline.width, (int)outline.height);

    if(!eraseOnly && !(dx == 0 && dy == 0)) {

      reshapeOutline(dx, dy);
      graphics.drawRect((int)outline.x, (int)outline.y, (int)outline.width, (int)outline.height);

    }

    ((DiagramUI)diagram.getUI()).damageFigure(figure);
    
  }

  private final void reshapeOutline(double dx, double dy) {

    int min = MINIMUM_SIZE;
    double t;

    if(hasQuad(QUAD_LEFT)) {
      
      if((t = bounds.getWidth() - dx) > min) {
        outline.x = bounds.getX() + dx;
        outline.width = t;
      }

    } else if(hasQuad(QUAD_RIGHT))

      if((t = bounds.getWidth() + dx) > min)
        outline.width = t;

    if(hasQuad(QUAD_TOP)) {

      if((t = bounds.getHeight() - dy) > min) {
        outline.y = bounds.getY() + dy;
        outline.height = t;
      }

    } else if(hasQuad(QUAD_BOTTOM))

      if((t = bounds.getHeight() + dy) > min)
        outline.height = t;

  }

  private final void getQuadrant(Point2D pt) {

    double padx = bounds.getWidth() / 8d;
    double pady = bounds.getHeight() / 8d;

    double x = pt.getX();
    double y = pt.getY();
    
    double centerX = center.getX();
    double centerY = center.getY();

    int dir;

    if(x < centerX - padx) 
      dir = QUAD_LEFT;
    else if(x < centerX + padx)  
      dir = QUAD_MIDDLE;
    else 
      dir = QUAD_RIGHT;

    if(y < centerY - pady)  
      dir |= QUAD_TOP;
    else if(y < centerY + pady)  
      dir |= QUAD_CENTER;
    else
      dir |= QUAD_BOTTOM;

    sizingDirection = dir;

  }


  private final boolean hasQuad(int quad) {
    return ((sizingDirection & quad) == quad);
  }


  private final Cursor getCursor() {

    if(hasQuad(QUAD_CENTER|QUAD_LEFT) || hasQuad(QUAD_CENTER|QUAD_RIGHT))
      return HZ_CURSOR;

    if(hasQuad(QUAD_MIDDLE|QUAD_TOP) || hasQuad(QUAD_MIDDLE|QUAD_BOTTOM))
      return VT_CURSOR;

    if(hasQuad(QUAD_BOTTOM|QUAD_LEFT) || hasQuad(QUAD_TOP|QUAD_RIGHT))
      return SWNE_CURSOR;

    return SENW_CURSOR;

  }

  final private Graphics2D getGraphics(Component c) {

    Graphics2D g = (Graphics2D)c.getGraphics();

    g.setColor(Color.gray);
    g.setXORMode(c.getBackground());
    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

    return g;

  }


  protected void reset() {

    if(diagram != null && originalCursor != null)
      diagram.setCursor(originalCursor);
    
    originalCursor = null;
    diagram = null;
    figure = null;
    graphics = null;
    lastPoint = dragPoint = null;

    java.util.Arrays.fill(relatedFigures, 0, relatedFigures.length, null);

  }

}
```

File: diagram.tool.SelectionTool
```java

package diagram.tool;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.SwingUtilities;

import diagram.Diagram;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.SelectionModel;

public class SelectionTool extends AbstractTool {

  private Figure[] figures = new Figure[4]; 

  private MouseHandler mouseHandler = new MouseHandler();

  public void install(Diagram diagram) {

    diagram.addMouseListener(mouseHandler);

  }

  public void uninstall(Diagram diagram) {

    diagram.removeMouseListener(mouseHandler);

  }

  protected class MouseHandler extends MouseAdapter {
  
    public void mouseClicked(MouseEvent e) {
      
      if(e.isConsumed() || !SwingUtilities.isLeftMouseButton(e) || e.getClickCount() > 1)
        return;
      
      
      Diagram diagram = (Diagram)e.getSource();
      Figure node = (Figure)diagram.findFigure(e.getPoint());
      
      SelectionModel selectionModel = diagram.getSelectionModel();
      
      if(e.isShiftDown() && node != null) {
        
        if(selectionModel.contains(node))
          selectionModel.remove(node);
      else
        selectionModel.add(node);
        
        DiagramUI ui = (DiagramUI)diagram.getUI();
        ui.refreshFigure(node);
        
      } else if(!e.isShiftDown())
        deselectAll(diagram, selectionModel, node);

    }
    
    public void mousePressed(MouseEvent e) {
      
      if(e.isConsumed() || e.isShiftDown() || !SwingUtilities.isLeftMouseButton(e) || 
         e.getClickCount() > 1)
        return; 
      
      Diagram diagram = (Diagram)e.getSource();
      Figure node = (Figure)diagram.findFigure(e.getPoint());
      
      SelectionModel selectionModel = diagram.getSelectionModel();
      
      if(selectionModel.size() <= 1 && node != null) 
        deselectAll(diagram, selectionModel, node);
      
    }


  private final void deselectAll(Diagram diagram, SelectionModel model, Figure except) {

    Figure[] items = (Figure[])model.toArray((Object[])figures);
    DiagramUI ui = (DiagramUI)diagram.getUI();
    
    for(int i=0; i<items.length && items[i] != null; i++) {

      Figure node = items[i];

      if(except == null || node != except) {
        
        ui.damageFigure(node);
        model.remove(node);

      }

    }
 
    if(except != null && !model.contains(except)) {

      ui.damageFigure(except);
      model.add(except);

    }

    if(items.length > 0 && items[0] != null) 
      ui.refreshFigure(items[0]);
    else if(except != null)
      ui.refreshFigure(except);

    java.util.Arrays.fill(items, 0, items.length, null);
    
  }


}

```

File: diagram.tool.LinkShappingTool
```java

package diagram.tool;

import java.awt.Cursor;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;

import javax.swing.SwingUtilities;
import javax.swing.event.MouseInputAdapter;

import diagram.Diagram;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.figures.PolyLink;

public class LinkShappingTool extends AbstractTool {

  public static final double CLICK_TOLERANCE = 6.0;
  public static final double DRAG_TOLERANCE = 6.0;
  private static final Cursor HD_CURSOR = new Cursor(Cursor.HAND_CURSOR);

  private Cursor originalCursor = null;

  private Diagram diagram;

  private Point2D dragPoint; 

  private PolyLink polyLink;
  
  private Point2D pressPoint;

  private MouseHandler mouseHandler = new MouseHandler();

  public void install(Diagram diagram) {

    if(diagram.getSelectionModel() == null)
      throw new RuntimeException("LinkShapping requires SelectionModel support");

    diagram.addMouseListener(mouseHandler);
    diagram.addMouseMotionListener(mouseHandler);

  }

  public void uninstall(Diagram diagram) {

    diagram.removeMouseListener(mouseHandler);
    diagram.removeMouseMotionListener(mouseHandler);

    reset();

  }

  protected void linkPressed(PolyLink link, MouseEvent event) { }

  protected void linkClicked(PolyLink link, MouseEvent event) { }

  protected void linkReleased(PolyLink link, MouseEvent event) { }

  protected class MouseHandler extends MouseInputAdapter {

    public void mousePressed(MouseEvent e) {
      
      if(e.isConsumed() || e.isShiftDown() || e.isControlDown() || e.isAltDown())
        return;
      
      diagram = (Diagram)e.getSource();
      Point2D pt = e.getPoint();
      
      Diagram diagram = (Diagram)e.getSource();
      Figure figure = diagram.findFigure(pt);
      
      if(!(figure instanceof PolyLink)) {
        reset();
        return;
      }
      
      polyLink = (PolyLink)figure;

      if(SwingUtilities.isLeftMouseButton(e))
        pressPoint = pt;
      
      linkPressed(polyLink, e);

    }
    

    public void mouseClicked(MouseEvent e) {
     
      if(!e.isConsumed() && SwingUtilities.isRightMouseButton(e)) {

        Diagram diagram = (Diagram)e.getSource();
        Point pt = e.getPoint();

        Figure figure = diagram.findFigure(pt);
        if(!(figure instanceof PolyLink))
          return;
        
        PolyLink polyLink = (PolyLink)figure;
        DiagramUI ui = (DiagramUI)diagram.getUI();
        
        int point = polyLink.pointFor(pt.getX(), pt.getY(), CLICK_TOLERANCE*2.0);
        if(point > 0 && point < (polyLink.getPointCount() - 1)) {
          
          e.consume();
          fireToolStarted();        
          
          ui.damageFigure(polyLink);
          polyLink.join(point);
          ui.refreshFigure(polyLink);
            

        }
        
        linkClicked(polyLink, e);

      }  
    
    }

    public void mouseDragged(MouseEvent e) {
      
      if(e.isConsumed() || !SwingUtilities.isLeftMouseButton(e)) 
        return;
      
      if(pressPoint != null) {
        
        if(pressPoint.distance(e.getPoint()) >= DRAG_TOLERANCE) {
          
          Point2D pt = pressPoint;
          pressPoint = null;
          
          int segment = polyLink.segmentFor(pt, CLICK_TOLERANCE);
          if(segment == -1)
            return;

          fireToolStarted();
          
          int point = polyLink.pointFor(pt.getX(), pt.getY(), CLICK_TOLERANCE*2.0);
          if(point > 0 && point < (polyLink.getPointCount() - 1))
            dragPoint = polyLink.getPN(point);
          else 
            dragPoint = polyLink.split(segment, pt);
          
          originalCursor = diagram.getCursor();
          diagram.setCursor(HD_CURSOR);
          
        }
        
      }
      
      if(dragPoint != null) {
        
        e.consume();    
        
        DiagramUI ui = (DiagramUI)diagram.getUI();
        
        ui.damageFigure(polyLink);
        dragPoint.setLocation(e.getPoint());
        ui.refreshFigure(polyLink);
        
      }
      
    }

    public void mouseReleased(MouseEvent e) {
      
      if(dragPoint != null) {
        
        e.consume();
        ((DiagramUI)diagram.getUI()).refreshRegion(null);
       

        linkReleased(polyLink, e);
        
        fireToolFinished();
        reset();
        
      }
      
      
    }



  protected void reset() {

    if(diagram != null && originalCursor != null)
      diagram.setCursor(originalCursor);

    diagram = null;
    dragPoint = null;
    originalCursor = null;
    polyLink = null;    
    pressPoint = null;

  }

}
```

File: diagram.tool.Tool
```java

package diagram.tool;

import diagram.Diagram;

public interface Tool {

  public void addToolListener(ToolListener l);

  public void removeToolListener(ToolListener l);

  public void install(Diagram diagram);

  public void uninstall(Diagram diagram);

}
```

File: diagram.tool.EditingTool
```java

package diagram.tool;


import java.awt.Component;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;
import java.util.EventObject;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.SwingUtilities;
import javax.swing.event.MouseInputAdapter;

import diagram.Diagram;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.FigureEditor;
import diagram.Link;
import diagram.SelectionModel;

public class EditingTool extends AbstractTool {

  protected MouseHandler mouseHandler = new MouseHandler();
  protected FocusHandler focusHandler = new FocusHandler();

  protected Action actionStart  = new StartEditingAction();
  protected Action actionStop   = new StopEditingAction();
  protected Action actionCancel = new CancelEditingAction();

  private Diagram diagram;
  private Figure figure;
  private Component dispatchComponent;
  private Component editorComponent;
  private Rectangle editorBounds = new Rectangle();
  private FigureEditor editor;
  private Figure[] selected = new Figure[1];


  public void install(Diagram diagram) {

    diagram.addMouseListener(mouseHandler);
    diagram.addMouseMotionListener(mouseHandler);
    diagram.addFocusListener(focusHandler);
    
    ActionMap map = diagram.getActionMap();

    map.put("startEditing", actionStart);
    map.put("stopEditing", actionStop);
    map.put("cancelEditing", actionCancel);

  }


  public void uninstall(Diagram diagram) {

    diagram.removeMouseListener(mouseHandler);
    diagram.removeMouseMotionListener(mouseHandler);
    diagram.removeFocusListener(focusHandler);

    ActionMap map = diagram.getActionMap();

    map.remove("startEditing");
    map.remove("stopEditing");
    map.remove("cancelEditing");

  }

  protected boolean isEditing() {
    return (editor != null);
  }
 
  
  protected class MouseHandler extends MouseInputAdapter {

    private Link[] links = new Link[4];

    private final boolean shouldIgnore(MouseEvent e) { 
      return !(!e.isConsumed() && SwingUtilities.isLeftMouseButton(e));
    }

    private final void setDispatchComponent(MouseEvent e) { 
      
      Point p = SwingUtilities.convertPoint(diagram, e.getPoint(), editorComponent);
      dispatchComponent = SwingUtilities.getDeepestComponentAt(editorComponent, p.x, p.y);
      
    }
  
  
    private final boolean repostEvent(MouseEvent e) { 

      if(dispatchComponent == null)
        return false; 
      
      MouseEvent e2 = SwingUtilities.convertMouseEvent(diagram, e, dispatchComponent);
      dispatchComponent.dispatchEvent(e2); 
      return true; 
      
    }
    
    
    public void mousePressed(MouseEvent e) {

      if(!isEditing() && shouldIgnore(e))
        return;

      Diagram diagram = (Diagram)e.getSource();
      Figure pressedFigure = findPressedFigure(diagram, e.getPoint());

      if(isEditing() && pressedFigure != figure)
        stopEditing(diagram, figure);

      if(isEditing() || startEditing(diagram, pressedFigure, e)) {

        setDispatchComponent(e); 
        repostEvent(e); 
      
        e.consume();

      } 

    }
    
    public void mouseReleased(MouseEvent e) {
      
      if(!isEditing() || shouldIgnore(e))
        return;
      
      repostEvent(e); 
      dispatchComponent = null;
      
    }
    
    public void mouseDragged(MouseEvent e) {
      
      if(!isEditing() || shouldIgnore(e)) 
        return;     
      
      repostEvent(e); 
      
    }

    protected Figure findPressedFigure(Diagram diagram, Point2D pt) {

      Figure pressedFigure = diagram.findFigure(pt);
      
      if(pressedFigure == null) {

        links = (Link[])diagram.getModel().toArray(links);
        for(int i=0; i < links.length && links[i] != null; i++) {

          if(diagram.getModel().getValue(links[i]) == null)
            continue;

          FigureEditor editor = diagram.getFigureEditor(links[i].getClass());
          editorBounds = (Rectangle) editor.getDecoratedBounds(diagram, links[i], editorBounds);
          
          if(editorBounds.contains(pt))
            return links[i];

        }

      }

      return pressedFigure;

    }



  
  protected class FocusHandler extends FocusAdapter {

    public void focusGained(FocusEvent e) {
      repaintEditorCell((Diagram)e.getSource());
    }

    public void focusLost(FocusEvent e) {
      repaintEditorCell((Diagram)e.getSource());
    }

    private final void repaintEditorCell(Diagram diagram) {
      diagram.paintImmediately(editorBounds);
    }



  protected boolean startEditing(Diagram diagram, Figure figure, EventObject e) {

    if(figure != null && diagram != null) {

      editor = diagram.getFigureEditor(figure.getClass());
      if(editor == null || !editor.isCellEditable(e)) {
        editor = null;
        return false;
      }

      SelectionModel selectionModel = diagram.getSelectionModel();
      if(editor.shouldSelectCell(e)) 
        selectionModel.add(figure, true);
      
      boolean isSelected = selectionModel.contains(figure);
      editorComponent = editor.getFigureEditorComponent(diagram, figure, isSelected);
      if(editorComponent == null)
        throw new RuntimeException("Bad FigureEditor!");

      fireToolStarted();
      
      editorBounds = (Rectangle)editor.getDecoratedBounds(diagram, figure, editorBounds);
      
      editorComponent.setBounds(editorBounds.x, editorBounds.y, 
                                editorBounds.width, editorBounds.height);
      
      
      
      diagram.add(editorComponent);
      editorComponent.validate();
      editorComponent.setVisible(true);
      
      editorComponent.requestFocus();
      
      this.diagram = diagram;
      this.figure = figure;
      
      return true;

    }

    return false;

  }

  protected void stopEditing(Diagram diagram, Figure figure) {

    diagram.getModel().setValue(figure, editor.getCellEditorValue());
    editor.stopCellEditing();
    removeEditor();

    fireToolFinished();

  }

  protected void removeEditor() {

    editorBounds = (Rectangle)editorComponent.getBounds(editorBounds);
    diagram.remove(editorComponent);

    diagram.requestFocus();
    DiagramUI ui = (DiagramUI)diagram.getUI();

    ui.damageFigure(figure);
    ui.repaintRegion(editorBounds);

    diagram = null;
    editor = null;
    figure = null;
    editorComponent = null;
   
  }

  

  private class StartEditingAction extends AbstractAction {

    public void actionPerformed(ActionEvent e) { 

      Diagram diagram = (Diagram)e.getSource(); 
      SelectionModel model = diagram.getSelectionModel();

      if(model.size() != 1)
        return;
      
      selected = (Figure[])model.toArray(selected);
      startEditing(diagram, selected[0], e);

    }

  } 

  private class StopEditingAction extends AbstractAction {

    public void actionPerformed(ActionEvent e) { 

      if(!isEditing())
        return;
      
      editor.stopCellEditing();
      removeEditor();

    }

  } 

  private class CancelEditingAction extends AbstractAction {

    public void actionPerformed(ActionEvent e) { 

      if(!isEditing())
        return;

      editor.cancelCellEditing();
      removeEditor();

    }

  } 



}
```

File: diagram.tool.AbstractTool
```java

package diagram.tool;

import util.WeakList;
import diagram.Diagram;

public abstract class AbstractTool implements Tool {

  private WeakList listeners = new WeakList();
  
  public void addToolListener(ToolListener l) {
    listeners.add(l);
  }

  public void removeToolListener(ToolListener l) {
    listeners.remove(l);
  }


  abstract public void install(Diagram diagram);

  abstract public void uninstall(Diagram diagram);

  protected void fireToolStarted() {

    try {

      for(int i = 0; i < listeners.size(); i++) {
        
        ToolListener l = (ToolListener)listeners.get(i);
        if(l != null)
          l.toolStarted(this);
        
      }

    } catch(Throwable t) { 
      handleError(t);
    }

  }

  protected void fireToolFinished() {

    try {

      for(int i = 0; i < listeners.size(); i++) {
        
        ToolListener l = (ToolListener)listeners.get(i);
        if(l != null)
          l.toolFinished(this);
        
      }


    } catch(Throwable t) { 
      handleError(t);
    }

  }

  protected void handleError(Throwable t) {

    System.err.println("Error dispatching event");

    t.printStackTrace();
    System.exit(0);

  }

}
```

File: diagram.tool.CompositeTool
```java

package diagram.tool;

import java.util.Iterator;
import java.util.Vector;

import diagram.Diagram;

public class CompositeTool implements Tool {

  private Vector tools = new Vector();

  public void addToolListener(ToolListener l) {

    for(Iterator i = tools.iterator(); i.hasNext();)
      ((Tool)i.next()).addToolListener(l);

  }

  public void removeToolListener(ToolListener l) {

    for(Iterator i = tools.iterator(); i.hasNext();)
      ((Tool)i.next()).removeToolListener(l);

  }

  public void install(Diagram diagram) {
    
    for(Iterator i = tools.iterator(); i.hasNext();)
      ((Tool)i.next()).install(diagram);

  }

  public void uninstall(Diagram diagram) {

    for(Iterator i = tools.iterator(); i.hasNext();)
      ((Tool)i.next()).uninstall(diagram);

  }

  public void add(Tool tool) {
    if(!tools.contains(tool))
      tools.add(tool);
  }

  public void remove(Tool tool) {
    tools.remove(tool);
  }

}
```

File: diagram.tool.LinkTool
```java

package diagram.tool;

import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;

import javax.swing.event.MouseInputAdapter;

import diagram.Diagram;
import diagram.DiagramUI;
import diagram.Figure;
import diagram.Link;
import diagram.figures.PointFigure;
import diagram.figures.PolyLink;

public class LinkTool extends AbstractTool {

  private final static double POINT_SIZE = 5;

  private Diagram diagram;

  private Figure figSource;
  private Figure figSink;

  private PointFigure ptSink = new PointFigure(POINT_SIZE);
  private Point2D ptCenter;

  private Link link;

  private MouseHandler mouseHandler = new MouseHandler();

  public void install(Diagram diagram) {


    diagram.addMouseListener(mouseHandler);
    diagram.addMouseMotionListener(mouseHandler);

  }

  public void uninstall(Diagram diagram) {

    diagram.removeMouseListener(mouseHandler);
    diagram.removeMouseMotionListener(mouseHandler);

    reset();

  }
  

  protected class MouseHandler extends MouseInputAdapter {


    public void mousePressed(MouseEvent e) {
      
      Object o = e.getSource();
      
      if(!e.isConsumed() && e.getClickCount() == 1 && (o instanceof Diagram)) {
        
        diagram = (Diagram)o;
        
        Point2D pt = e.getPoint();
        if(((figSource = (Figure)diagram.findFigure(pt)) == null) || (figSource instanceof Link)) {
          reset();
          return;
        }
        
        e.consume();
        fireToolStarted();

        
        ptSink.setLocation(pt.getX(), pt.getY());
        link = createLink(figSource, ptSink);
        
        diagram.getModel().add(link);
        
        DiagramUI ui = (DiagramUI)diagram.getUI();
        ui.removeConnection(ptSink, link);    
        
      }
      
    }
    
    
    public void mouseDragged(MouseEvent e) {
      
      if(diagram == null)
        return;
      
      Point2D pt = e.getPoint();   
      DiagramUI ui = (DiagramUI)diagram.getUI();
      
      ui.damageFigure(link);
      
      Figure sink = (Figure)diagram.findFigure(pt);
      
      if(sink != null && !(sink instanceof Link) && sink != figSource && sink != figSink) {
        
        ui.addConnection(sink, link);
        link.setSink(sink);
        
        figSink = sink;
        
      } else if(sink != figSink) { 
        
        ptSink.setLocation(pt.getX(), pt.getY());
        
        if(figSink != ptSink) {
          ui.removeConnection(link.setSink(ptSink), link);    
          figSink = ptSink;
          
        }
        
      }
      
      ui.refreshFigure(link);
      
    }
    
    public void mouseReleased(MouseEvent e) {
      
      if(diagram == null)
        return;
      
      e.consume();

      DiagramUI ui = (DiagramUI)diagram.getUI();
      ui.damageFigure(link);
      
      if(figSink == null || figSink == ptSink)
        diagram.getModel().remove(link);
      
      else {
        
        Link finalLink = finalizeLink(link);
        if(finalLink != link) {
          diagram.getModel().remove(link);
          diagram.getModel().add(finalLink);
        }
        
        ui.refreshFigure(finalLink);
        
      }
      
      fireToolFinished();
      reset();
      
    }
    


  protected void reset() {

    diagram = null;
    figSink = null;
    figSource = null;
    link = null;

  }

  protected Link createLink(Figure source, Figure sink) {
    return new PolyLink(source, sink);
  }

  protected Link finalizeLink(Link link) {
    return link;
  }

}
```

File: acme.ImageEncoder
```java

package acme;

import java.awt.Image;
import java.awt.image.ColorModel;
import java.awt.image.ImageConsumer;
import java.awt.image.ImageProducer;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Hashtable;


public abstract class ImageEncoder implements ImageConsumer
    {

    protected OutputStream out;

    private ImageProducer producer;
    private int width = -1;
    private int height = -1;
    private int hintflags = 0;
    private boolean started = false;
    private boolean encoding;
    private IOException iox;
    private static final ColorModel rgbModel = ColorModel.getRGBdefault();
    private Hashtable props = null;

    public ImageEncoder( Image img, OutputStream out ) throws IOException
	{
	this( img.getSource(), out );
	}

    public ImageEncoder( ImageProducer producer, OutputStream out ) throws IOException
	{
	this.producer = producer;
	this.out = out;
	}



    abstract void encodeStart( int w, int h ) throws IOException;

    abstract void encodePixels(
	int x, int y, int w, int h, int[] rgbPixels, int off, int scansize )
	throws IOException;

    abstract void encodeDone() throws IOException;



    public synchronized void encode() throws IOException
	{
	encoding = true;
	iox = null;
	producer.startProduction( this );
	while ( encoding )
	    try
		{
		wait();
		}
	    catch ( InterruptedException e ) {}
	if ( iox != null )
	    throw iox;
	}

    private boolean accumulate = false;
    private int[] accumulator;

    private void encodePixelsWrapper(
	int x, int y, int w, int h, int[] rgbPixels, int off, int scansize )
	throws IOException
	{
	if ( ! started )
	    {
	    started = true;
	    encodeStart( width, height );
	    if ( ( hintflags & TOPDOWNLEFTRIGHT ) == 0 )
		{
		accumulate = true;
		accumulator = new int[width * height];
		}
	    }
	if ( accumulate )
	    for ( int row = 0; row < h; ++row )
		System.arraycopy(
		    rgbPixels, row * scansize + off,
		    accumulator, ( y + row ) * width + x,
		    w );
	else
	    encodePixels( x, y, w, h, rgbPixels, off, scansize );
	}

    private void encodeFinish() throws IOException
	{
	if ( accumulate )
	    {
	    encodePixels( 0, 0, width, height, accumulator, 0, width );
	    accumulator = null;
	    accumulate = false;
	    }
	}

    private synchronized void stop()
	{
	encoding = false;
	notifyAll();
	}



    public void setDimensions( int width, int height )
	{
	this.width = width;
	this.height = height;
	}

    public void setProperties( Hashtable props )
	{
	this.props = props;
	}

    public void setColorModel( ColorModel model )
	{
	}

    public void setHints( int hintflags )
	{
	this.hintflags = hintflags;
	}

    public void setPixels(
	int x, int y, int w, int h, ColorModel model, byte[] pixels,
	int off, int scansize )
	{
	int[] rgbPixels = new int[w];
	for ( int row = 0; row < h; ++row )
	    {
	    int rowOff = off + row * scansize;
	    for ( int col = 0; col < w; ++col )
		rgbPixels[col] = model.getRGB( pixels[rowOff + col] & 0xff );
	    try
		{
		encodePixelsWrapper( x, y + row, w, 1, rgbPixels, 0, w );
		}
	    catch ( IOException e )
		{
		iox = e;
		stop();
		return;
		}
	    }
	}

    public void setPixels(
	int x, int y, int w, int h, ColorModel model, int[] pixels,
	int off, int scansize )
	{
	if ( model == rgbModel )
	    {
	    try
		{
		encodePixelsWrapper( x, y, w, h, pixels, off, scansize );
		}
	    catch ( IOException e )
		{
		iox = e;
		stop();
		return;
		}
	    }
	else
	    {
	    int[] rgbPixels = new int[w];
            for ( int row = 0; row < h; ++row )
		{
		int rowOff = off + row * scansize;
                for ( int col = 0; col < w; ++col )
                    rgbPixels[col] = model.getRGB( pixels[rowOff + col] );
		try
		    {
		    encodePixelsWrapper( x, y + row, w, 1, rgbPixels, 0, w );
		    }
		catch ( IOException e )
		    {
		    iox = e;
		    stop();
		    return;
		    }
		}
	    }
	}

    public void imageComplete( int status )
	{
	producer.removeConsumer( this );
	if ( status == ImageConsumer.IMAGEABORTED )
	    iox = new IOException( "image aborted" );
	else
	    {
	    try
		{
		encodeFinish();
		encodeDone();
		}
	    catch ( IOException e )
		{
		iox = e;
		}
	    }
	stop();
	}

    }
```

File: acme.GifEncoder
```java

package acme;

import java.awt.Image;
import java.awt.image.ImageProducer;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Enumeration;


public class GifEncoder extends ImageEncoder
    {

    private boolean interlace = false;

    public GifEncoder( Image img, OutputStream out ) throws IOException
	{
	super( img, out );
	}

    public GifEncoder( Image img, OutputStream out, boolean interlace ) throws IOException
	{
	super( img, out );
	this.interlace = interlace;
	}

    public GifEncoder( ImageProducer prod, OutputStream out ) throws IOException
	{
	super( prod, out );
	}

    public GifEncoder( ImageProducer prod, OutputStream out, boolean interlace ) throws IOException
	{
	super( prod, out );
	this.interlace = interlace;
	}


    int width, height;
    int[][] rgbPixels;

    void encodeStart( int width, int height ) throws IOException
	{
	this.width = width;
	this.height = height;
	rgbPixels = new int[height][width];
	}

    void encodePixels(
	int x, int y, int w, int h, int[] rgbPixels, int off, int scansize )
	throws IOException
	{
	for ( int row = 0; row < h; ++row )
	    System.arraycopy(
		rgbPixels, row * scansize + off,
		this.rgbPixels[y + row], x, w );

	}

    IntHashtable colorHash;

    void encodeDone() throws IOException
	{
	int transparentIndex = -1;
	int transparentRgb = -1;
        colorHash = new IntHashtable();
	int index = 0;
        for ( int row = 0; row < height; ++row )
            {
            for ( int col = 0; col < width; ++col )
                {
                int rgb = rgbPixels[row][col];
		boolean isTransparent = ( ( rgb >>> 24 ) < 0x80 );
		if ( isTransparent )
		    {
		    if ( transparentIndex < 0 )
			{
			transparentIndex = index;
			transparentRgb = rgb;
			}
		    else if ( rgb != transparentRgb )
			{
			rgbPixels[row][col] = rgb = transparentRgb;
			}
		    }
                GifEncoderHashitem item =
		    (GifEncoderHashitem) colorHash.get( rgb );
                if ( item == null )
		    {
		    if ( index >= 256 )
			throw new IOException( "too many colors for a GIF" );
                    item = new GifEncoderHashitem(
			rgb, 1, index, isTransparent );
		    ++index;
		    colorHash.put( rgb, item );
		    }
                else
                    ++item.count;
                }
            }

	int logColors;
	if ( index <= 2 )
	    logColors = 1;
	else if ( index <= 4 )
	    logColors = 2;
	else if ( index <= 16 )
	    logColors = 4;
	else
	    logColors = 8;

	int mapSize = 1 << logColors;
	byte[] reds = new byte[mapSize];
	byte[] grns = new byte[mapSize];
	byte[] blus = new byte[mapSize];
	for ( Enumeration e = colorHash.elements(); e.hasMoreElements(); )
	    {
	    GifEncoderHashitem item = (GifEncoderHashitem) e.nextElement();
	    reds[item.index] = (byte) ( ( item.rgb >> 16 ) & 0xff );
	    grns[item.index] = (byte) ( ( item.rgb >>  8 ) & 0xff );
	    blus[item.index] = (byte) (   item.rgb         & 0xff );
	    }

	GIFEncode(
	    out, width, height, interlace, (byte) 0, transparentIndex,
	    logColors, reds, grns, blus );
	}

    byte GetPixel( int x, int y ) throws IOException
	{
	GifEncoderHashitem item =
	    (GifEncoderHashitem) colorHash.get( rgbPixels[y][x] );
	if ( item == null )
	    throw new IOException( "color not found" );
	return (byte) item.index;
	}

    static void writeString( OutputStream out, String str ) throws IOException
        {
        byte[] buf = str.getBytes();
        out.write( buf );
        }


    int Width, Height;
    boolean Interlace;
    int curx, cury;
    int CountDown;
    int Pass = 0;

    void GIFEncode(
	OutputStream outs, int Width, int Height, boolean Interlace, byte Background, int Transparent, int BitsPerPixel, byte[] Red, byte[] Green, byte[] Blue )
	throws IOException
	{
	byte B;
	int LeftOfs, TopOfs;
	int ColorMapSize;
	int InitCodeSize;
	int i;

	this.Width = Width;
	this.Height = Height;
	this.Interlace = Interlace;
	ColorMapSize = 1 << BitsPerPixel;
	LeftOfs = TopOfs = 0;

	CountDown = Width * Height;

	Pass = 0;

	if ( BitsPerPixel <= 1 )
	    InitCodeSize = 2;
	else
	    InitCodeSize = BitsPerPixel;

	curx = 0;
	cury = 0;

	writeString( outs, "GIF89a" );

	Putword( Width, outs );
	Putword( Height, outs );

	B = (byte) 0x80;		// Yes, there is a color map
	B |= (byte) ( ( 8 - 1 ) << 4 );
	B |= (byte) ( ( BitsPerPixel - 1 ) );

	Putbyte( B, outs );

	Putbyte( Background, outs );

	Putbyte( (byte) 0, outs );

	for ( i = 0; i < ColorMapSize; ++i )
	    {
	    Putbyte( Red[i], outs );
	    Putbyte( Green[i], outs );
	    Putbyte( Blue[i], outs );
	    }

	if ( Transparent != -1 )
	    {
	    Putbyte( (byte) '!', outs );
	    Putbyte( (byte) 0xf9, outs );
	    Putbyte( (byte) 4, outs );
	    Putbyte( (byte) 1, outs );
	    Putbyte( (byte) 0, outs );
	    Putbyte( (byte) 0, outs );
	    Putbyte( (byte) Transparent, outs );
	    Putbyte( (byte) 0, outs );
	    }

	Putbyte( (byte) ',', outs );

	Putword( LeftOfs, outs );
	Putword( TopOfs, outs );
	Putword( Width, outs );
	Putword( Height, outs );

	if ( Interlace )
	    Putbyte( (byte) 0x40, outs );
	else
	    Putbyte( (byte) 0x00, outs );

	Putbyte( (byte) InitCodeSize, outs );

	compress( InitCodeSize+1, outs );

	Putbyte( (byte) 0, outs );

	Putbyte( (byte) ';', outs );
	}

    void BumpPixel()
	{
	++curx;

	if ( curx == Width )
	    {
	    curx = 0;

	    if ( ! Interlace )
		++cury;
	    else
		{
		switch( Pass )
		    {
		    case 0:
		    cury += 8;
		    if ( cury >= Height )
			{
			++Pass;
			cury = 4;
			}
		    break;

		    case 1:
		    cury += 8;
		    if ( cury >= Height )
			{
			++Pass;
			cury = 2;
			}
		    break;

		    case 2:
		    cury += 4;
		    if ( cury >= Height )
			{
			++Pass;
			cury = 1;
			}
		    break;

		    case 3:
		    cury += 2;
		    break;
		    }
		}
	    }
	}

    static final int EOF = -1;

    int GIFNextPixel() throws IOException
	{
	byte r;

	if ( CountDown == 0 )
	    return EOF;

	--CountDown;

	r = GetPixel( curx, cury );

	BumpPixel();

	return r & 0xff;
	}

    void Putword( int w, OutputStream outs ) throws IOException
	{
	Putbyte( (byte) ( w & 0xff ), outs );
	Putbyte( (byte) ( ( w >> 8 ) & 0xff ), outs );
	}

    void Putbyte( byte b, OutputStream outs ) throws IOException
	{
	outs.write( b );
	}




    static final int BITS = 12;

    static final int HSIZE = 5003;		// 80% occupancy


    int n_bits;				// number of bits/code
    int maxbits = BITS;			// user settable max # bits/code
    int maxcode;			// maximum code, given n_bits
    int maxmaxcode = 1 << BITS; // should NEVER generate this code

    final int MAXCODE( int n_bits )
	{
	return ( 1 << n_bits ) - 1;
	}

    int[] htab = new int[HSIZE];
    int[] codetab = new int[HSIZE];

    int hsize = HSIZE;		// for dynamic table sizing

    int free_ent = 0;			// first unused entry

    boolean clear_flg = false;


    int g_init_bits;

    int ClearCode;
    int EOFCode;

    void compress( int init_bits, OutputStream outs ) throws IOException
	{
	int fcode;
	int c;
	int ent;
	int disp;
	int hsize_reg;
	int hshift;

	g_init_bits = init_bits;

	clear_flg = false;
	n_bits = g_init_bits;
	maxcode = MAXCODE( n_bits );

	ClearCode = 1 << ( init_bits - 1 );
	EOFCode = ClearCode + 1;
	free_ent = ClearCode + 2;

	char_init();

	ent = GIFNextPixel();

	hshift = 0;
	for ( fcode = hsize; fcode < 65536; fcode *= 2 )
	    ++hshift;
	hshift = 8 - hshift;			// set hash code range bound

	hsize_reg = hsize;
	cl_hash( hsize_reg );	// clear hash table

	output( ClearCode, outs );

	outer_loop:
	while ( (c = GIFNextPixel()) != EOF )
	    {
	    fcode = ( c << maxbits ) + ent;
	    i = ( c << hshift ) ^ ent;		// xor hashing

	    if ( htab[i] == fcode )
		{
		ent = codetab[i];
		continue;
		}
	    else if ( htab[i] >= 0 )	// non-empty slot
		{
		disp = hsize_reg - i;	// secondary hash (after G. Knott)
		if ( i == 0 )
		    disp = 1;
		do
		    {
		    if ( (i -= disp) < 0 )
			i += hsize_reg;

		    if ( htab[i] == fcode )
			{
			ent = codetab[i];
			continue outer_loop;
			}
		    }
		while ( htab[i] >= 0 );
		}
	    output( ent, outs );
	    ent = c;
	    if ( free_ent < maxmaxcode )
		{
		codetab[i] = free_ent++;	// code -> hashtable
		htab[i] = fcode;
		}
	    else
		cl_block( outs );
	    }
	output( ent, outs );
	output( EOFCode, outs );
	}


    int cur_accum = 0;
    int cur_bits = 0;

    int masks[] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F,
		    0x001F, 0x003F, 0x007F, 0x00FF,
		    0x01FF, 0x03FF, 0x07FF, 0x0FFF,
		    0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

    void output( int code, OutputStream outs ) throws IOException
	{
	cur_accum &= masks[cur_bits];

	if ( cur_bits > 0 )
	    cur_accum |= ( code << cur_bits );
	else
	    cur_accum = code;

	cur_bits += n_bits;

	while ( cur_bits >= 8 )
	    {
	    char_out( (byte) ( cur_accum & 0xff ), outs );
	    cur_accum >>= 8;
	    cur_bits -= 8;
	    }

       if ( free_ent > maxcode || clear_flg )
	    {
	    if ( clear_flg )
		{
		maxcode = MAXCODE(n_bits = g_init_bits);
		clear_flg = false;
		}
	    else
		{
		++n_bits;
		if ( n_bits == maxbits )
		    maxcode = maxmaxcode;
		else
		    maxcode = MAXCODE(n_bits);
		}
	    }

	if ( code == EOFCode )
	    {
	    while ( cur_bits > 0 )
		{
		char_out( (byte) ( cur_accum & 0xff ), outs );
		cur_accum >>= 8;
		cur_bits -= 8;
		}

	    flush_char( outs );
	    }
	}


    void cl_block( OutputStream outs ) throws IOException
	{
	cl_hash( hsize );
	free_ent = ClearCode + 2;
	clear_flg = true;

	output( ClearCode, outs );
	}

    void cl_hash( int hsize )
	{
	for ( int i = 0; i < hsize; ++i )
	    htab[i] = -1;
	}


    int a_count;

    void char_init()
	{
	a_count = 0;
	}

    byte[] accum = new byte[256];

    void char_out( byte c, OutputStream outs ) throws IOException
	{
	accum[a_count++] = c;
	if ( a_count >= 254 )
	    flush_char( outs );
	}

    void flush_char( OutputStream outs ) throws IOException
	{
	if ( a_count > 0 )
	    {
	    outs.write( a_count );
	    outs.write( accum, 0, a_count );
	    a_count = 0;
	    }
	}

    }

class GifEncoderHashitem
    {

    public int rgb;
    public int count;
    public int index;
    public boolean isTransparent;

    public GifEncoderHashitem( int rgb, int count, int index, boolean isTransparent )
	{
	this.rgb = rgb;
	this.count = count;
	this.index = index;
	this.isTransparent = isTransparent;
	}

    }
```

File: acme.IntHashtable
```java

package acme;

import java.util.Dictionary;
import java.util.Enumeration;
import java.util.NoSuchElementException;


public class IntHashtable extends Dictionary implements Cloneable
    {
    private IntHashtableEntry table[];

    private int count;

    private int threshold;

    private float loadFactor;

    public IntHashtable( int initialCapacity, float loadFactor )
	{
	if ( initialCapacity <= 0 || loadFactor <= 0.0 )
	    throw new IllegalArgumentException();
	this.loadFactor = loadFactor;
	table = new IntHashtableEntry[initialCapacity];
	threshold = (int) ( initialCapacity * loadFactor );
	}

    public IntHashtable( int initialCapacity )
	{
	this( initialCapacity, 0.75f );
	}

    public IntHashtable()
	{
	this( 101, 0.75f );
	}

    public int size()
	{
	return count;
	}

    public boolean isEmpty()
	{
	return count == 0;
	}

    public synchronized Enumeration keys()
	{
	return new IntHashtableEnumerator( table, true );
	}

    public synchronized Enumeration elements()
	{
	return new IntHashtableEnumerator( table, false );
	}

    public synchronized boolean contains( Object value )
	{
	if ( value == null )
	    throw new NullPointerException();
	IntHashtableEntry tab[] = table;
	for ( int i = tab.length ; i-- > 0 ; )
	    {
	    for ( IntHashtableEntry e = tab[i] ; e != null ; e = e.next )
		{
		if ( e.value.equals( value ) )
		    return true;
		}
	    }
	return false;
	}

    public synchronized boolean containsKey( int key )
	{
	IntHashtableEntry tab[] = table;
	int hash = key;
	int index = ( hash & 0x7FFFFFFF ) % tab.length;
	for ( IntHashtableEntry e = tab[index] ; e != null ; e = e.next )
	    {
	    if ( e.hash == hash && e.key == key )
		return true;
	    }
	return false;
	}

    public synchronized Object get( int key )
	{
	IntHashtableEntry tab[] = table;
	int hash = key;
	int index = ( hash & 0x7FFFFFFF ) % tab.length;
	for ( IntHashtableEntry e = tab[index] ; e != null ; e = e.next )
	    {
	    if ( e.hash == hash && e.key == key )
		return e.value;
	    }
	return null;
	}

    public Object get( Object okey )
	{
	if ( ! ( okey instanceof Integer ) )
	    throw new InternalError( "key is not an Integer" );
	Integer ikey = (Integer) okey;
	int key = ikey.intValue();
	return get( key );
	}

    protected void rehash()
	{
	int oldCapacity = table.length;
	IntHashtableEntry oldTable[] = table;

	int newCapacity = oldCapacity * 2 + 1;
	IntHashtableEntry newTable[] = new IntHashtableEntry[newCapacity];

	threshold = (int) ( newCapacity * loadFactor );
	table = newTable;

	for ( int i = oldCapacity ; i-- > 0 ; )
	    {
	    for ( IntHashtableEntry old = oldTable[i] ; old != null ; )
		{
		IntHashtableEntry e = old;
		old = old.next;

		int index = ( e.hash & 0x7FFFFFFF ) % newCapacity;
		e.next = newTable[index];
		newTable[index] = e;
		}
	    }
	}

    public synchronized Object put( int key, Object value )
	{
	if ( value == null )
	    throw new NullPointerException();

	IntHashtableEntry tab[] = table;
	int hash = key;
	int index = ( hash & 0x7FFFFFFF ) % tab.length;
	for ( IntHashtableEntry e = tab[index] ; e != null ; e = e.next )
	    {
	    if ( e.hash == hash && e.key == key )
		{
		Object old = e.value;
		e.value = value;
		return old;
		}
	    }

	if ( count >= threshold )
	    {
	    rehash();
	    return put( key, value );
	    } 

	IntHashtableEntry e = new IntHashtableEntry();
	e.hash = hash;
	e.key = key;
	e.value = value;
	e.next = tab[index];
	tab[index] = e;
	++count;
	return null;
	}

    public Object put( Object okey, Object value )
	{
	if ( ! ( okey instanceof Integer ) )
	    throw new InternalError( "key is not an Integer" );
	Integer ikey = (Integer) okey;
	int key = ikey.intValue();
	return put( key, value );
	}

    public synchronized Object remove( int key )
	{
	IntHashtableEntry tab[] = table;
	int hash = key;
	int index = ( hash & 0x7FFFFFFF ) % tab.length;
	for ( IntHashtableEntry e = tab[index], prev = null ; e != null ; prev = e, e = e.next )
	    {
	    if ( e.hash == hash && e.key == key )
		{
		if ( prev != null )
		    prev.next = e.next;
		else
		    tab[index] = e.next;
		--count;
		return e.value;
		}
	    }
	return null;
	}

    public Object remove( Object okey )
	{
	if ( ! ( okey instanceof Integer ) )
	    throw new InternalError( "key is not an Integer" );
	Integer ikey = (Integer) okey;
	int key = ikey.intValue();
	return remove( key );
	}

    public synchronized void clear()
	{
	IntHashtableEntry tab[] = table;
	for ( int index = tab.length; --index >= 0; )
	    tab[index] = null;
	count = 0;
	}

    public synchronized Object clone()
	{
	try
	    {
	    IntHashtable t = (IntHashtable) super.clone();
	    t.table = new IntHashtableEntry[table.length];
	    for ( int i = table.length ; i-- > 0 ; )
		t.table[i] = ( table[i] != null ) ?
		    (IntHashtableEntry) table[i].clone() : null;
	    return t;
	    }
	catch ( CloneNotSupportedException e)
	    {
	    throw new InternalError();
	    }
	}

    public synchronized String toString()
	{
	int max = size() - 1;
	StringBuffer buf = new StringBuffer();
	Enumeration k = keys();
	Enumeration e = elements();
	buf.append( "{" );

	for ( int i = 0; i <= max; ++i )
	    {
	    String s1 = k.nextElement().toString();
	    String s2 = e.nextElement().toString();
	    buf.append( s1 + "=" + s2 );
	    if ( i < max )
		buf.append( ", " );
	    }
	buf.append( "}" );
	return buf.toString();
	}
    }


class IntHashtableEntry
    {
    int hash;
    int key;
    Object value;
    IntHashtableEntry next;

    protected Object clone()
	{
	IntHashtableEntry entry = new IntHashtableEntry();
	entry.hash = hash;
	entry.key = key;
	entry.value = value;
	entry.next = ( next != null ) ? (IntHashtableEntry) next.clone() : null;
	return entry;
	}
    }


class IntHashtableEnumerator implements Enumeration
    {
    boolean keys;
    int index;
    IntHashtableEntry table[];
    IntHashtableEntry entry;

    IntHashtableEnumerator( IntHashtableEntry table[], boolean keys )
	{
	this.table = table;
	this.keys = keys;
	this.index = table.length;
	}
	
    public boolean hasMoreElements()
	{
	if ( entry != null )
	    return true;
	while ( index-- > 0 )
	    if ( ( entry = table[index] ) != null )
		return true;
	return false;
	}

    public Object nextElement()
	{
	if ( entry == null )
	    while ( ( index-- > 0 ) && ( ( entry = table[index] ) == null ) )
		;
	if ( entry != null )
	    {
	    IntHashtableEntry e = entry;
	    entry = e.next;
	    return keys ? new Integer( e.key ) : e.value;
	    }
	throw new NoSuchElementException( "IntHashtableEnumerator" );
	}
    }
```

